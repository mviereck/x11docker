#! /bin/bash

# x11docker
# Run GUI applications and desktop environments in docker
#
# - Circumvents common X security leaks with additional X servers.
# - Improves container security restricting container capabilities.
# - Container user is same as host user to avoid root in container.
#
# Type 'x11docker --help' or scroll down to read usage information.
# More documentation at:  https://github.com/mviereck/x11docker

Version="5.0.0-beta"

usage() {               # --help: show usage information
  echo "
x11docker: Run GUI applications and desktop environments in docker.

Usage:
To run a docker image with new X server (auto-choosing X server):
  x11docker [OPTIONS] IMAGE [COMMAND]
  x11docker [OPTIONS] -- IMAGE [COMMAND [ARG1 ARG2 ...]]
  x11docker [OPTIONS] -- DOCKER_RUN_OPTIONS -- IMAGE [COMMAND [ARG1 ARG2 ...]]
To run a host application on a new X server:
  x11docker [OPTIONS] --exe COMMAND
  x11docker [OPTIONS] --exe -- COMMAND [ARG1 ARG2 ...]
To run only a new empty X server:
  x11docker [OPTIONS]

Optional features:
  * Hardware acceleration for OpenGL
  * Pulseaudio and ALSA sound
  * Clipboard sharing
  * Persistent home folders
  * Wayland support
  * Language locale creation
  * Init system support (systemd, SysVinit, OpenRC, runit, tini)
  * DBus in container
Focus on security:
  * Avoids X security leaks using additional X servers.
  * Container user is same as host user to avoid root in container.
  * Restricts container capabilities to bare minimum.

Dependencies on host:
  Depending on chosen options, x11docker needs some packages to be installed.
  It will check for them on startup and show messages if some are missing.
  List of possibly needed packages:
   * most recommended to allow security and convenience:
       X servers: Xephyr xpra nxagent (on Windows: VcXsrv or Xwin)
       X tools:   xauth xrandr xhost xinit
   * advanced GPU support:
       Desktop mode:  weston Xwayland
       Seamless mode: weston Xwayland xpra xdotool
   * less important:
       xclip xdpyinfo xdg-utils pulseaudio
   * least important:
       unzip wget xfishtank kwin_wayland Xvfb
       xserver-xorg-legacy xserver-xorg-video-dummy

Dependencies in image:
  Doesn't have dependencies inside of docker images, except for options:
   --gpu:  OpenGL packages, often already installed as package dependencies.
   --pulseaudio: sound with pulseaudio needs pulseaudio on host and in image.
   --lang: localedef to create missing language locales.
   --dbus, --dbus-system: needs dbus in image.
   --systemd, --runit,--openrc, --sysvinit: init systems need to be installed.

Options:
     --help            display this message and exit.
 -e, --exe             execute host application on new X server (no docker).
     --xonly           only create empty X server.

Basic settings: (especially influencing auto choosing X server)
 -d, --desktop         Indicate desktop environment in image.
 -g, --gpu             Hardware accelerated OpenGL rendering. Shares files in
                       /dev/dri. Works best with open source drivers installed
                       on host and OpenGL/Mesa in image.
                       For closed source nvidia drivers regard terminal output.
                       Degrades container isolation. Container access to GPU.
 -w, --wm COMMAND      Host window manager to use for single applications in
                       nested X server options like --xephyr.
                       To autodetect a host wm, use --wm=auto or short: -wm
                       To set default autodetected window manager:
                           update-alternatives --config x-window-manager

Shared folders:
 -m, --home            Share a host folder ~/x11docker/imagename as home folder
                       in container (to store persistent data).
     --homedir DIR     Specify custom host folder DIR for option --home.
     --homebasedir DIR Custom base folder for option --home.
                       (Compare --cachebasedir below).
     --sharedir DIR    Share host folder (or file) DIR with r/w access.
                       (Can be specified multiple times).

Clipboard, sound, language:
 -c, --clipboard       Share clipboard between X servers (works best with xpra.
                       Most other X servers need xclip to be installed).
 -p, --pulseaudio [=MODE]  Sound with pulseaudio. Degrades isolation.
                       Needs 'pulseaudio' on host and in image.
                       Optional arg MODE can be 'socket' (default) or 'tcp'.
     --alsa            Sound with ALSA. Shares devices in /dev/snd. You can
                       define desired sound card with: --env ALSA_CARD=cardname
                       Degrades isolation. Container access to sound hardware.
     --lang LOCALE     Language setting: search for utf8 LOCALE in image and
                       create it if missing. Needs package 'locale' im image.
                       LOCALE can be e.g. ru, en, de, zh_CN, cz, fr, fr_BE.
                       Same as host: --lang=\$LANG.

Special options:
     --env VAR=value   Set custom environment variable VAR=value
                       Special use case for user shell: '--env SHELL=/bin/sh'
     --name NAME       Specify container name NAME.
     --no-internet     Disable internet access for container.
     --no-entrypoint   Disable ENTRYPOINT in image to allow other commands, too
     --pw FRONTEND     Choose frontend for password prompt. Possible FRONTEND:
                         su sudo gksu gksudo lxsu lxsudo kdesu kdesudo
                         pkexec beesu none
     --runfromhost CMD Run host command CMD on new X server (you may need & ).
     --runasroot CMD   Run command CMD as root in container on startup.
     --sharessh        Share SSH agent authentication socket from host.
     --showenv         Echo new \$DISPLAY, \$XAUTHORITY and \$WAYLAND_DISPLAY.
                       For custom access to new X server. Get environment with:
                         read xenv < <(x11docker --showenv [...])
     --showid          Echo container ID on stdout.
     --showpid1        Echo host PID of container PID 1 on stdout.
     --stdin           Forward stdin of x11docker to image command.
     --sudouser        Allow su and sudo for container user. Use with care,
                       severe reduction of default x11docker security!
                         Password:  x11docker
     --workdir DIR     Set working directory DIR.

X server options:
     --auto            Auto choose X server (default).
                       (Regards options --desktop, --gpu, --wayland and --wm).
 -a, --xpra            Nested X server supporting seamless and --desktop mode.
                       Needs 'xpra' on host. For faster startup see --nxagent.
 -y, --xephyr          Nested X server for --desktop mode. Without --desktop,
                       a host window manager will be provided (option --wm).
                       (Needs 'Xephyr' or 'Xnest').
 -n, --nxagent         Nested X server supporting seamless and --desktop mode.
                       Faster than --xpra and more flexible than --xephyr, but
                       some compositing applications have issues.
                       (Needs 'nxagent', best since nxagent version 3.5.99).
 -A, --xpra-xwayland   Like --xpra, but supports option --gpu.
                       (Needs 'xpra', 'Xwayland', 'weston' and 'xdotool').
 -Y, --weston-xwayland Desktop mode like --xephyr, but supports option --gpu.
                       Runs from console, within X and within Wayland.
                       (Needs 'weston' and 'Xwayland'.)
 -h, --hostdisplay     Share host display :0. Quite bad container isolation!
                       Least overhead of all X server options.
                       Some apps may fail due to restricted untrusted cookies.
                       Remove restrictions by the way with option --clipboard.
 -x, --xorg            Core Xorg server. Runs ootb from console.
                       Switch tty with <CTRL><ALT><F1>....<F12>.
                       To run from within X, edit '/etc/X11/Xwrapper.conf' and
                       replace line:        allowed_users=console
                       with lines           allowed_users=anybody
                                            needs_root_rights=yes
                       Debian 9 and Ubuntu 16.04: Install xserver-xorg-legacy.

Special X servers:
     --kwin-xwayland   Like --weston-xwayland, but using kwin_wayland
                       (Needs 'kwin_wayland' and 'Xwayland').
 -X, --xwayland        Blanc Xwayland, needs a running Wayland compositor.
                       (Needs 'Xwayland' to be installed.)
     --xdummy          Invisible X server. (Needs Xorg's dummy video driver)
     --xvfb            Invisible X server. (Needs 'Xvfb')
                       --xdummy and --xvfb can be used for custom  VNC access.
                       Output of environment variables on stdout. (--showenv)
                       Along with option --gpu an invisible setup with Weston,
                       Xwayland and xdotool is used (instead of Xdummy or Xvfb).
     --xwin            X server for Windows to run on Cygwin/X.
     --vcxsrv          X server for Windows to run on MSYS2, Cygwin or WSL.
 -N, --nothing         Do not provide any X or Wayland server.

Wayland without X:
 -W, --wayland         Automatically set up a Wayland environment.
                       Chooses one of following options and regards --desktop.
                       Sets some Wayland environment variables and runs
                       dbus system daemon (--dbus-system) in container.
 -T, --weston          Weston without X for pure Wayland applications.
                       Runs in X or from console. (Needs package weston.)
 -K, --kwin            KWin without X for pure Wayland applications.
                       Runs in X or from console. (Needs kwin_wayland.)
 -H, --hostwayland     Share host Wayland without X for pure Wayland apps.
                       (Needs already running Wayland compositor like Gnome 3.)
                       (Can be combined with --hostdisplay.)

X and Wayland appearance options:
 -f, --fullscreen      Run Xephyr, nxagent or Weston in fullscreen mode.
     --size XxY        Screen size of new X server (e.g. 800x600).
 -l, --scale N         Scale/zoom factor N for xpra, Xorg or Weston.
                       Allowed for --xpra, --xorg --xpra-xwayland: 0.25...8.0.
                       Allowed for --weston and --weston-xwayland: 1...9.
                       (Mismatching font sizes can be adjusted with --dpi).
     --rotate N        Rotate display (--xorg, --weston and --weston-xwayland)
                       Allowed values: 0, 90, 180, 270, flipped, flipped-90,
                       flipped-180, flipped-270.  (flipped = mirrored)
     --dpi N           dpi value (dots per inch) to submit to clients.
                       Influences font size of some applications.
     --output-count N  Multiple outputs for Weston, KWin or Xephyr.
     --xfishtank       Show fish tank on new X server (needs 'xfishtank').

X authentication:
     --xhost STR       Set \"xhost STR\" on new X server (see 'man xhost').
                       (Use with care. '--xhost +' allows access for everyone).
 -o, --no-xhost        Disable any access to host X server granted by xhost.
     --no-auth         Allow access to X for everyone. Security risk!
     --trusted         Use trusted cookies for --hostdisplay
     --untrusted       Create untrusted cookies. Restricts X access.
                       Default for --hostdisplay to avoid keylogging and
                       MIT-SHM errors. If --gpu is set, --trusted is used.

X and Wayland configuration:
     --display N       Use display number N for new X server.
     --vt N            Use vt / tty N (affects --xorg, --xdummy, --xpra).
     --keymap LAYOUT   Set keyboard layout for new X server, e.g. de, us, ru.
                       For possible LAYOUT look at /usr/share/X11/xkb/symbols.
     --xtest           Enable XTEST. Default for --xvfb, --xdummy, --xpra.
     --no-xtest        Disable XTEST. Default for most options.
     --westonini FILE  Custom weston.ini for --weston and --weston-xwayland.

User settings:
     --user N          Create container user N (N=name or N=uid). Default:
                       same as host user. N can also be an unknown user id.
                       You can specify a group id with N being 'user:gid'.
     --hostuser USER   Run X (and container user) as user USER. Default is
                       result of \$(logname). (x11docker must run as root).
     --group-add GROUP Additional group GROUP for container user.

Init system and dbus daemon:
     --tini            Default: init system tini (built-in of docker).
     --no-init         No init system in container. Image command is PID 1.
     --runit           Init system runit. Degrades container isolation.
                       Needs 'runit' installed in image. 'dbus' is recommended.
     --openrc          Init system OpenRC. Degrades container isolation a bit,
                       but needs less capabilities than --runit and --systemd.
                       Needs 'openrc' installed in image. 'dbus' recommended.
     --sysvinit        Init system SysVinit. Degrades container isolation a bit,
                       but needs less capabilities than  others.
                       Needs 'sysvinit' installed in image. 'dbus' recommended.
     --systemd         Init system systemd. Degrades container isolation.
                       For faster startup mask services that fail in container.
                       Needs 'systemd' installed in image.
                       Old systemd versions in image need --sys-admin, too.
     --sharecgroup     Share /sys/fs/cgroup. Allows elogind in container if
                       used with --dbus-system or init options.
 -b, --dbus            Run dbus user session daemon for image command.
     --dbus-system     Run dbus system daemon in container (includes --dbus).
                       Default for --wayland and for init options except --tini.

Container capabilities:
     --hostipc         Sets docker option --ipc=host, disables IPC namespacing.
                       Severe reduction of container isolation! Shares
                       host interprocess communication and shared memory.
                       Allows MIT-SHM extension of X servers.
     --hostnet         Set docker run option --net=host, disables network
                       namespacing. Severe reduction of container isolation!
                       Shares host network stack, allows dbus communication.
     --cap-default     Allow default docker container capabilities and
                       disable container security hardening of x11docker.
     --sys-admin       Add capability SYS_ADMIN. Please avoid that.
       Custom capabilities can be added with --cap-add=CAP after  --

Miscellaneous:
     --starter         Create starter on desktop and exit. You can move the
                       created .desktop file to ~/.local/share/applications
                       to get a menu entry.
     --cachebasedir DIR  Custom base folder for cache files.
     --license         Show license of x11docker (MIT) and exit.
     --ps              Preserve container and cache files on exit.
     --cleanup         Clean up orphaned containers and cache files.

Verbosity options:
 -v, --verbose         Be verbose. Output of logfile on stderr.
     --silent          Do not show terminal messages.
     --debug           Debug mode: Show some debug output,
     --stdout          Show stdout of container applications.
     --stderr          Show stderr of container applications.

Installation options (need root permissions):
     --install         Install x11docker and x11docker-gui from current folder.
     --update          Download and install latest release from github.
     --update-master   Download and install latest master version from github.
     --remove          Remove x11docker from your system.

x11docker version: $Version
Please report issues and get help at: https://github.com/mviereck/x11docker
"
}
license() {             # --license: show license (MIT)
echo 'MIT License

Copyright (c) 2015, 2016, 2017, 2018 Martin Viereck

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.'
}
alertbox() {            # X alert box with title $1 and message $2
  local Title= Message=
  Title=${1:-}
  Message=${2:-}

  Message="$(echo "$Message" | LANG=C sed "s/[\x80-\xFF]//g" | fold -w120 )" # remove UTF-8 special chars; line folding at 120 chars

  # try some tools to show alert message. If all tools fail, return 1
  command -v   xmessage     >/dev/null && [ -n "${DISPLAY:-}" ] && {
    echo "$Title

$Message" | xmessage  -file - -default okay ||:
  } || {
    command -v gxmessage    >/dev/null && [ -n "${DISPLAY:-}" ] && {
      echo "$Title

$Message" | gxmessage -file - -default okay ||:
    }
  } || {
    command -v zenity       >/dev/null && [ -n "${DISPLAY:-}" ] && {
      zenity --error --no-markup --ellipsize --title="$Title" --text="$Message" 2>/dev/null ||:
    }
  } || {
    command -v yad          >/dev/null && [ -n "${DISPLAY:-}" ] && {
      yad  --image "dialog-error" --title "$Title" --button=gtk-ok:0 --text "$(echo "$Message" | sed 's/\\/\\\\/g')" --fixed 2>/dev/null ||:
    }
  } || {
    command -v kaptain      >/dev/null && [ -n "${DISPLAY:-}" ] && {
      echo 'start "'$Title'" -> message @close=" cancel" ;
            message "'$(echo "$Message" | sed 's/\\/\\\\\\/g' | sed 's/"/\\"/g' | sed -E ':a;N;$!ba;s/\r{0,1}\n/\\n/g' )'" -> @fill ;'  | kaptain ||:
    }
  } || {
    command -v kdialog      >/dev/null && [ -n "${DISPLAY:-}" ] && {
      kdialog --title "$Title" --error "$(echo "$Message" | sed 's/\\/\\\\/g' )" 2>/dev/null ||:
    }
  } || {
    command -v xterm        >/dev/null && [ -n "${DISPLAY:-}" ] && {
      xterm -title "$Title" -e "echo '$(echo "$Message" | sed "s/'/\"/g")' ; read -n1" ||:
    }
  } || {
    [ -n "$Anyterminal" ] && [ -e "$Cachefolder" ] && [ "$Xserver" != "--nothing" ] && {
      mkfile $Cachefolder/message
      echo "#! /bin/bash
echo '$Title

$Message
(Press any key to close window)'
read -n1
" >> $Cachefolder/message
      $Anyterminal /bin/bash $Cachefolder/message
      :
    }
  } || {
    notify-send "$Title:

$Message" 2>/dev/null
  } || return 1
  return 0
}
traperror() {           # trap ERR: --debug: Output for 'set -o errtrace'
  debugnote "Command at Line ${2:-} returned with error code ${1:-}:
  ${4:-}
  ${3:-} - ${5:-}"
}
error() {               # show error messages on stderr and exit
  local Message=

  # If there was already an error message, just show follow-up error as warning only.
  [ -e "$Cachefolder/error" ] && warning "$*" && waitfortheend
  [ -d "$Cachefolder" ] && $Mksu "touch $Cachefolder/error"   # also regarded by finish() for exit code

  sleep 1
  Message="$*

  Type 'x11docker --help' for usage information
  For debugging, run x11docker in terminal and/or enable option '--verbose'
  or look afterwards at logfile $Logbackup
  Please report issues at https://github.com/mviereck/x11docker"
  
  Message="$(rmcr <<< "$Message")"

  # output to terminal
  [ "$Verbose" = "no" ] && echo -e "
${Colredbg}x11docker ERROR:${Colnorm} $Message
" >&2

  # output to logfile
  logentry "x11docker ERROR: $Message
"

  # output to X dialogbox
  [ -n "$Hostdisplay" ] && export ${Hostxenv:-DISPLAY} || { [ -n "$Newdisplay" ] && export ${Newxenv:-DISPLAY} ; }
  [ -n "$Newdisplay" ] && {
    [ "$Tty" = "yes" ] && export ${Newxenv:-DISPLAY}
    case $Xserver in
      --xorg) [ -e "$Newxsocket" ] && export ${Newxenv:-DISPLAY} ;;
    esac
  }
  [ "$Silent" = "no" ] && alertbox "x11docker ERROR" "$Message"

  finish 1
}
warning() {             # show warning messages
  [ "$Verbose" = "no" ] && echo "${Colyellow}x11docker WARNING:${Colnorm} $*
" >&3
  logentry "x11docker WARNING: $*
"
}
note() {                # show notice messages
  [ "$Verbose" = "no" ] && echo "${Colgreen}x11docker note:${Colnorm} $*
" >&3
  logentry "x11docker note: $*
"
}
verbose() {             # show verbose messages
  # only logfile notes here, terminal output is done with tail in part:verbose
  # if $1 = -d then show debug note, too
  [ "$1" = "-d" ] && shift && debugnote "$*"
  logentry "x11docker: $*
"
}
debugnote() {           # show debug output $*
  [ "$Debugmode" = "yes" ] && {
    logentry "DEBUGNOTE: $*"
    [ "$Verbose" = "no" ] && echo "${Colblue}DEBUGNOTE:($(date +%T))${Colnorm} $*" >&3
  } ||:
}
logentry() {            # write into logfile
  [ "$Logfile" ] && echo "$*" >>$Logfile ||:
}
killpid() {             # kill PID $1 with codename $2 [and process name $3]
  verbose -d "Terminating ${1:-} (${2:-}) ${3:-}: $(pspid ${1:-})"
  ps -p ${1:-} >/dev/null && kill ${1:-} 2>/dev/null
}
finish_sigint() {       # trap SIGINT to activate debug mode on finish()
  Debugmode="yes"
  debugnote "Received SIGINT"
  finish
}
finish() {              # trap EXIT routine to clean up background processes and cache
  local Pid= Name= Zeit= Catlogfilepid= Exitcode= Pid1pid=
  trap - EXIT
  #set -x
  Pid1pid=$(cat $Containerpid1pidfile 2>/dev/null)

  verbose -d "Terminating x11docker."
  [ -z "$Winsubsystem" ] && checkpid $Pid1pid && verbose -d "Process tree of container:
$(pstree -p $Pid1pid 2>&1 ||:)"

  debugnote "List of stored background processes:
$(cat $Bgpidfile 2>/dev/null)"

  [ "$$" = "$BASHPID" ] || saygoodbye finish-subshell
  [ "$Sudo" ] && Sudo="sudo -n" # no password prompt here, rather fail

  # check for background processes stored in $Bgpidfile
  [ -s "$Bgpidfile" ] && {
    while read -r Line ; do
      Pid=$(echo $Line  | awk '{print $1}')
      Name=$(echo $Line | awk '{print $2}')
      debugnote "Checking: $Pid ($Name): $(pspid $Pid ||:)"
      checkpid $Pid && {        
        case $Name in
          xinit)                  killpid $Pid $Name xinit ;;
          Xserver)                killpid $Pid $Name 'Xorg|Xephyr|Xvfb|Xwayland|nxagent|vcxsrv.exe|Xwin' ;;
          containershell)         killpid $Pid $Name x11docker ;;
          windowmanager)          killpid $Pid $Name ;;
          xpraserver|xpraclient)  killpid $Pid $Name xpra ;;
          compositor)             killpid $Pid $Name 'weston|kwin_wayland' ;;
          waitfortheend|xpraloop|watchpidlist)
                                  killpid $Pid $Name x11docker ;;
          watchmessagefifo)       [ "$$" = "$BASHPID" ] && killpid $Pid $Name x11docker || Pid= ;;
          tailstdout|tailstderr)  Pid= ;;     # tail terminates itself after exit of $$
          catstdin)               killpid $Pid $Name ;;
          hostexe|shareclipboard) killpid $Pid $Name bash ;;
          xfishtank)              killpid $Pid $Name xfishtank ;;
          container)
            Containerpid=$Pid
            Pid=
            # Send TERM to PID1 of container
            checkpid  $Pid1pid 2>&1 && {
              verbose -d "Sending TERM to PID 1 of container: $(pspid $Pid1pid)"
              killpid $Pid1pid containerPID1 2>/dev/null || note "Could not terminate PID 1 of container: $(pspid $Pid1pid)"
              # Give container a bit time for graceful shutdown
              for Count in 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0; do
                checkpid $Pid1pid || break
                sleep $( awk "BEGIN { print $Count * 0.1 }")
                debugnote "Waiting for container PID 1: $Pid1pid to terminate"
              done
            }
            # Try 'docker stop' if TERM failed
            checkpid $Containerpid && {
              $Sudo $Dockerexe stop $Containername >>$Containerlogfile 2>&1 || verbose -d "docker stop failed"
            }
          ;;
          *) # should never happen (tm)
            note "Found remaining background process $Line
$(ps -p $Pid)"
            killpid $Pid $Name
          ;;
        esac
        checkpid $Pid && {
          sleep 1
          checkpid $Pid && verbose -d "Issue terminating $Line: $(pspid $Pid)" && kill -s KILL $Pid
        }
      }
    done < <(tac $Bgpidfile)
  }
  
  # Possibly stored Windows pid to terminate. Currently only VcXsrv in WSL.
  [ "$Winpidlist" ] && for Line in $Winpidlist ; do verbose -d "Terminating Windows PID $Line: $(taskkill.exe /F /PID $Line 2>&1 | rmcr)" ; done

  saygoodbye "finish"

  # Check if container is still running.
  # if kill of PID 1 failed in loop above, most times terminating X server will already have stopped GUI applications.
  checkpid $Containerpid && {
    $Sudo $Dockerexe stop $Containername >>$Containerlogfile 2>&1 || {
      note "Found remaining container process. Most probably the X session was
  interrupted. Can not stop container because x11docker does not run as root.
  Will wait up to 10 seconds for docker to finish."
      Zeit=$(date +%s)
      while checkpid $Containerpid ; do
        note "Waiting for container to terminate ..."
        sleep 1
        [ 10 -lt $(($(date +%s) - $Zeit)) ] && break
      done
      if checkpid $Containerpid ; then
        note "Container did not terminate as it should.
  Will not clean cache to avoid file permission issues.
  You can remove the new container with command:
    docker rm -f $Containername
  Afterwards, remove cache files with:
    rm -R $Cachefolder
  or let x11docker do the cleanup work for you:
    x11docker --cleanup"
        Preservecachefiles="yes"
      else
        note "Container terminated successfully"
      fi
    }
  }
  [ "$Winsubsystem" ] && [ "$Pid1pid" ] && [ "$Containername" ] && {
    verbose -d "Stopping container $Containername"
    $Sudo $Dockerexe stop $Containername >/dev/null 2>&1 || {
      $Sudo $Dockerexe inspect $Containername >/dev/null 2>&1 && {
        warning "Failed to stop container $Containername.
  Will not clean cache to avoid file permission issues."
        Preservecachefiles="yes"
      }
    }  
  }

  Exitcode=${1:-0}
  [ -e "$Cachefolder/error" ] && Exitcode=1
  verbose -d "Exitcode $Exitcode"

  [ -e "$Logfile" ] && {
    [ "$Verbose" = "yes" ] && sleep 1
    rmcr $Logfile
    $Mksu "cp '$Logfile' '$Logbackup'"
    [ "$(dirname $Logfile)" = "$Cachebasefolder" ] && rm $Logfile
  }

  # close additional file descriptors
  for i in 3 4 6 7 8 9; do
    { >&$i ;} 2>/dev/null && exec >&$i-
  done

  [ "$Preservecachefiles" = "no" ] && grep -q cache <<<$Cachefolder && grep -q x11docker <<<$Cachefolder && [ "x11docker" != "$(basename "$Cachefolder")" ] && $Mksu "rm -f -R '$Cachefolder'"

  exit $Exitcode
}
saygoodbye() {          # create file signaling watching processes to terminate
  verbose -d "time to say goodbye ($*)"
  [ -e "$Sharefolder" ] && {
    echo timetosaygoodbye >> $Timetosaygoodbye
    echo timetosaygoodbye >> $Timetosaygoodbyefifo
  }
}
mywatch() {             # repeat $1 untils its output changes
  local Watchoutput=
  Watchoutput="$(sh -c "${1:-}" 2>&1)"

  verbose -d "Watching output of: sh -c \"'${1:-}'\" 2>&1
  Current output:
$Watchoutput"

  while rocknroll; do
    [ "$Watchoutput" = "$(sh -c "${1:-}" 2>&1)" ] || break
    sleep 1
  done

  verbose -d "Stopped watching output of: sh -c \"'${1:-}'\" 2>&1
  Current output:
$(sh -c "${1:-}" 2>&1)"
}
watchpidlist() {        # watch list of important pids
  # terminate x11docker if a PID in $Watchpidlist terminates
  # serves mainly watching X server, Wayland compositor, container and hostexe
  # echo PIDs to watch into >&9 (setonwatchpidlist())
  local Pid= Containername=
  while rocknroll ; do
    read -t1 Pid <&9 ||:
    [ "$Pid" ] && {
      [ "${Pid:0:9}" = "CONTAINER" ] && {
        Containername=${Pid#CONTAINER}
        verbose -d "Watching Container: $Containername"
      } || {
        Watchpidlist="$Watchpidlist $Pid"
        debugnote "Watching pids: $Watchpidlist"
      }
    }
    for Pid in $Watchpidlist; do
      [ -e /proc/$Pid ] || {
        debugnote  "watchpidlist: PID $Pid has terminated"
        saygoodbye "watchpidlist $Pid"
      }
    done
    [ "$Containername" ] && {
      # Container PID not watchable in MSYS2/Cygwin/WSL.
      $Dockerexe inspect $Containername >/dev/null 2>&1 || {
        debugnote "watchpidlist: Container $Containername has terminated"
        saygoodbye "watchpidlist $Containername"
      }
    }
    [ "$Winsubsystem" ] && sleep 2
  done
  saygoodbye "watchpidlist"
}
setonwatchpidlist() {   # add PID $1 to watchpidlist()
  #echo ${1:-} >&9
  debugnote "Set pid ${1:-} on watchlist: ${2:-}"
  echo "${1:-}" >>$Watchpidfifo
}
watchmessagefifo() {    # watch for messages out of container or dockerrc
  # message in fifo must end with :$Messagetype
  local Line= Message= Messagetype=
  while rocknroll ; do
    IFS= read -r Line <&6 ||:
    [ "$Line" ] || sleep 2  # sleep for MSYS2/CYGWIN workaround
    [ "$Line" ] && Message="$Message
$Line"
    grep -q -E ":WARNING|:NOTE|:DEBUGNOTE|:VERBOSE|:ERROR|:STDOUT" <<< "$Line" && {
      Messagetype=":$(echo $Line | rev | cut -d: -f1  | rev)"
      Message="${Message%$Messagetype}"
      Message="$(tail -n +2 <<< "$Message")" # remove leading newline
      case "$Messagetype" in
        :WARNING)   warning   "$Message" ;;
        :NOTE)      note      "$Message" ;;
        :DEBUGNOTE) debugnote "$Message" ;;
        :ERROR)     error     "$Message" ;;
        :VERBOSE)   [ "-d " = "$(cut -c1-3 <<<"$Message" | head -n1)" ] && verbose -d "$(tail -c +4 <<< "$Message")" || verbose "$Message" ;;
        :STDOUT)    echo "$Message" ;;
      esac
      Message=
      Messagetype=
    }
  done
}
rocknroll() {           # check if x11docker is still running
  [ -s "$Timetosaygoodbye" ] && return 1
  [ -e "$Timetosaygoodbye" ] || return 1
  return 0
}
waitfortheend() {       # wait for end of x11docker
  # signal is byte in $Timetosaygoodbyefifo
  # decent read to wait for signal to terminate
  case $Winsubsystem in
    "")
      while rocknroll; do
        bash -c "read -n1 -t1 <&8 ||:"
      done
    ;;
    *)
      while rocknroll; do
        sleep 2
      done
    ;;
  esac
}
waitforfilecreation() { # similar to inotify-wait: wait up to 15s for file $1 to be created
  # $1 file to wait for
  # $2 time to wait. default: 15s. possible: infinity
  local Zeit= Warten= Dauer= Count=
  Zeit=$(date +%s)
  verbose -d "Waiting for file creation of ${1:-}"
  case ${2:-} in
    "")           Warten=15 ;;
    infinity|inf) Warten=32000 ;; # nearly infinity in fast-moving today ...
    *)            Warten=${2:-} ;;
  esac
  while [ ! "$(find  "${1:-}" 2>/dev/null)" ] ; do
    Count=$(( Count + 1 ))
    Dauer=$(( $(date +%s) - $Zeit ))
    sleep $(awk "BEGIN { print $Count * 0.1 }")
    [ $Warten -lt $Dauer ] && {
      warning "Failed to wait for file creation of
  ${1:-}"
      return 1
    }
    verbose "Waiting since ${Dauer}s for ${1:-} to be created, will wait up to $Warten seconds."
    rocknroll || {
      verbose -d "Stopped waiting for ${1:-} due to terminating signal."
      return 1
    }
  done
  verbose "Found new created file $(ls ${1:-})"
  return 0
}
waitforfilecontent() {  # wait for file $1 to be not empty
  # $1 file to look at
  local Zeit= Warten= Dauer= Count=
  Zeit=$(date +%s)
  case "${2:-}" in
    infinity) Warten=32000 ;;
    "")       Warten=15 ;;
    *)        Warten="${2:-}" ;;
  esac
  verbose -d "Waiting for file content in ${1:-}"
  while [ ! -s "${1:-}" ] ; do
    Count=$(( Count + 1 ))
    Dauer=$(( $(date +%s) - $Zeit ))
    sleep $(awk "BEGIN { print $Count * 0.1 }")
    [ $Warten -lt $Dauer ]  && return 1
    verbose "Waiting since ${Dauer}s for ${1:-} to have content, will wait up to $Warten seconds."
    rocknroll || {
      verbose -d "Stopped waiting for file content of ${1:-} due to terminating signal."
      return 1
    }  done
  verbose "Found file content in ${1:-}"
  return 0
}
waitforlogentry() {     # wait for entry $3 in logfile $2 of application $1
  # $1 is the application we are waiting for to be ready
  # $2 points to logfile
  # $3 keyword to wait for
  local Zeit= Warten= Dauer= Count=

  Zeit=$(date +%s)
  Warten=60

  while ! grep -q "${3:-}" <"${2:-}" ; do
#    grep -i -q -E 'error|Failed to process Wayland|failed to create display|] fatal:' <"${2:-}" && {
    grep -i -q -E 'Failed to process Wayland|failed to create display|] fatal:' <"${2:-}" && {
      warning "Found error message for ${1:-} in logfile
  ${2:-}
$(grep -i -E 'error|failed|fatal'  <"${2:-}")"
      return 1
    }

    Count=$(( Count + 1 ))
    Dauer=$(( $(date +%s) - $Zeit ))
    verbose "Waiting since ${Dauer}s for ${1:-} to be ready."
    sleep $(awk "BEGIN { print $Count * 0.1 }")
    [ $Warten -lt $Dauer ] && return 1

    rocknroll || {
      verbose -d "Stopped waiting for logentry in ${2:-} of ${1:-} due to terminating signal."
      return 1
    }
  done

  verbose "${1:-} is ready."
  return 0
}
storepid () {           # store pid $1 and name $2 of background process in file $Bgpidfile.
  # store Pid and process name of background processes in file
  # for use on exit / with trap to clean up with background processes
  # this subroutine has a twin in xinitrc
  echo ${1:-} ${2:-} >> $Bgpidfile
  verbose -d "Stored background pid ${1:-} of ${2:-}"
  disown ${1:-} 2>/dev/null ||:
}
checkpid() {            # check if PID $1 is active
  ps -p ${1:-} >/dev/null 2>&1
}
pspid() {               # ps -p $1 --no-headers
  ps -p ${1:-} | tail -n+2
}
no_xhost() {            # remove any access to X server granted by xhost
  local Line=
  command -v xhost >/dev/null || {
    warning "Command 'xhost' not found.
  Can not check for possibly allowed network access to X.
  Please install 'xhost'."
    return 1
  }
  #xhost
  xhost 2>&1 | rmcr | tail -n +2  /dev/stdin | while read -r Line ; do  # read all but the first line (header)
    verbose -d "xhost: Removing entry $Line"
    xhost -$Line | rmcr                                  # disable every entry
  done
  xhost - | rmcr                                         # enable access control
  [ "$(xhost 2>&1 | rmcr | wc -l)" -gt "1" ] && {
    warning "Remaining xhost permissions found on display $DISPLAY
$(xhost 2>&1 | rmcr)"
    return 1
  }
  return 0
}
mkfile() {              # create file $1 owned by $Hostuser
  :> "${1:-}"
  chown $Hostuser    "${1:-}"
  chgrp $Hostusergid "${1:-}"
  [ -n "${2:-}" ] && chmod ${2:-} "${1:-}" ||:
}
depends() {             # check dependencies on host for X server option $1
  # Return 1 if something is missing
  local Return= Message=
  case $Autochooseserver in
    yes) Message="verbose -d" ;;
    no)  Message="warning" ;;
  esac
  case ${1:-} in
    --xephyr|--xpra|--nxagent|--xorg|--xvfb|--xdummy|--xwayland|--weston-xwayland|--kwin-xwayland|--xwin)
      command -v xinit >/dev/null || {
        $Message "${1:-}: xinit not found."
        Return=1
      }
    ;;
  esac
  case ${1:-} in
    --xpra|--xpra-xwayland)
      command -v "xpra" >/dev/null || {
        $Message "${1:-}: xpra not found."
        Return=1
      } ;;
    --xephyr)
      command -v "Xephyr" >/dev/null || command -v "Xnest" >/dev/null || {
        $Message "${1:-}: Neither Xephyr nor Xnest found."
        Return=1
      } ;;
    --nxagent)
      command -v "nxagent" >/dev/null || {
        $Message "${1:-}: nxagent not found."
        Return=1
      } ;;
    --xvfb)
      command -v "Xvfb" >/dev/null || {
        $Message "${1:-}: Xvfb not found."
        Return=1
      } ;;
    --xorg|--xdummy)
      command -v "Xorg" >/dev/null || {
        $Message "${1:-}: Xorg not found."
        Return=1
      } ;;
    --xwin)
      command -v "xwin" >/dev/null || {
        $Message "${1:-}: Xwin not found. 
  Need 'xinit' package from Cygwin (X11 section)."
        Return=1
      } ;;
    --vcxsrv)
      Vcxsrvpath="$Winsubmount/c/Program Files/VcXsrv/vcxsrv.exe"
      command -v "$Vcxsrvpath" >/dev/null || {
        $Message "${1:-}: X server VcXsrv not found."
        Return=1
        [ "$Winsubsystem" ] && note "To run x11docker within MSYS2, Cygwin or WSL on MS Windows,
  please install X server VcXsrv (or Xwin on Cygwin).
  Searching for vcxsrv.exe in: 
    C:\Program Files\VcXsrv"
      }
      Vcxsrvpath="$(echo "$Vcxsrvpath" | rev | cut -d/ -f2- | rev)"
      [ -z "$Winsubsystem" ] && Return=1 && $Message "${1:-}: X server VcXsrv is available on MS Windows only."
    ;;
  esac
  case $Xserver in
    --vcxsrv|--xwin)
      [ "$Hostip" ] || {
        warning "Failed to get host IP for $Xserver."
        Return=1
      } ;;
  esac
  case ${1:-} in
    --weston|--xpra-xwayland|--weston-xwayland|--xdummy-xwayland)
      command -v "weston" >/dev/null || {
        $Message "${1:-}: weston not found."
        Return=1
      } ;;
    --kwin|--kwin-xwayland)
      command -v "kwin_wayland" >/dev/null || {
        $Message "${1:-}: kwin_wayland not found."
        Return=1
      } ;;
  esac
  case ${1:-} in
    --xpra-xwayland|--weston-xwayland|--kwin-xwayland|--xwayland|--xdummy-xwayland)
      command -v "Xwayland" >/dev/null || {
        $Message "${1:-}: Xwayland not found."
        Return=1
      } ;;
  esac
  case ${1:-} in
    --xpra-xwayland|--xdummy-xwayland)
      command -v "xdotool" >/dev/null || {
        $Message "${1:-}: xdotool not found."
        Return=1
      } ;;
  esac
  case ${1:-} in
    --hostdisplay|--xpra|--xpra-xwayland|--xephyr|--nxagent)
      [ "$Hostdisplay" ] || {
        $Message "${1:-} needs a running X server. DISPLAY is empty."
        Return=1
      }
    ;;
    --hostwayland|--xwayland)
      [ "$Hostwaylandsocket" ] || {
        $Message "${1:-} needs a running Wayland compositor. WAYLAND_DISPLAY is empty."
        Return=1
      }
    ;;
  esac
  case $Xserver in
    --xpra|--xpra-xwayland)
      [ "$Return" = "1" ] || {
        # check xpra version
        [ "$Xpraversion" ] || {
          Xpraversion="$(xpra --version)"
          Xprarelease="$(echo $Xpraversion | cut -s -d- -f2)"
          verbose "Xpra version: $Xpraversion"
        }
        ! verlte "$Xprarelease" "r18663" && verlte $Xprarelease "r19519" && {
          [ "$Sharehostipc" = "no" ] && {
            $Message "Your xpra version has a MIT-SHM bug that would force
  x11docker to share host IPC namespace. That would reduce container isolation.
  Current installed version: $Xpraversion
  Please update to at least xpra v2.3.1-19519 or xpra v2.4-r19520,
  or downgrade to xpra v2.2.5 or lower, or use another X server option.
  If you insist on using current xpra, set insecure option --hostipc.
  Fallback: will search for another available X server setup."
            Return=1
          }
        }
      }
    ;;
  esac

  debugnote "Dependency check for ${1:-}: ${Return:-0}"
  [ "$Return" = "1" ] && {
    $Message "${1:-} not possible: missing dependencies."
    Autochooseserver="yes"
  }
  return ${Return:-"0"}
}
cleanup() {             # --cleanup : check for non-removed containers and left cache files
  # e X11DOCKER_LASTCLEANFOLDER may be set by x11docker-gui to spare its cache folder.

  local Orphanedcontainers= Orphanedfolders= Line=

  note "x11docker will check for orphaned containers from earlier sessions.
  This can happen if docker was not closed successfully.
  x11docker will look for those containers and will clean up x11docker cache.
  Caution: any currently running x11docker sessions will be terminated, too."

  cd $Cachebasefolder || error "Could not cd to cache folder '$Cachebasefolder'."

  grep -q .cache/x11docker <<<$Cachebasefolder && Orphanedfolders=$(find "$Cachebasefolder" -mindepth 1 -maxdepth 1 -type d | sed s%$Cachebasefolder/%% | grep -v x11docker-gui)
  [ "${X11DOCKER_LASTCLEANFOLDER:-}" ] && Orphanedfolders="$(echo "$Orphanedfolders" | grep -v $X11DOCKER_LASTCLEANFOLDER)"
  Orphanedcontainers="$($Dockerexe ps -a --filter name=x11docker_X --format "{{.Names}}")"
  Orphanedcontainers="$Orphanedcontainers $(find "$Cachebasefolder" -mindepth 2 -maxdepth 2 -type f -name 'container.id' -exec cat {} \;)"
  Orphanedcontainers="$(env IFS='' echo $Orphanedcontainers)"
  
  # check for double entrys name/id, check for already non-existing containers
  for Line in $Orphanedcontainers; do
    $Dockerexe inspect $Line -f '{{.Id}}' >/dev/null 2>/dev/null && {
      echo $Line | grep -q x11docker_X && {
        $Dockerexe inspect $Line -f '{{.Id}}'
        Line=$($Dockerexe inspect $Line -f '{{.Id}}')
        Orphanedcontainers=$(sed s/$Line// <<< $Orphanedcontainers)
      } ||:
    } || Orphanedcontainers=$(sed s/$Line// <<< $Orphanedcontainers)
  done

  [ -z "$Orphanedcontainers$Orphanedfolders" ] && {
    note "No orphaned containers or cache files found. good luck!"
  } || {
    note "Found orphaned containers:
$Orphanedcontainers"
    note "Found orphaned folders in $Cachebasefolder:
$Orphanedfolders"

    for Line in $Orphanedfolders ; do
      [ -d "$Cachebasefolder/$Line/share" ] && [ ! -s "$Cachebasefolder/$Line/share/timetosaygoodbye" ] && {
        note "Found possibly active container $Line.
  Will summon it to terminate itself."
        echo timetosaygoodbye >> "$Cachebasefolder/$Line/share/timetosaygoodbye"
        sleep 2
      }
    done

    [ -n "$Orphanedcontainers" ] && {
      note "Removing containers with: $Dockerexe rm -f $Orphanedcontainers"
      bash -c "$Dockerexe rm -f $Orphanedcontainers" 2>&1
    }
    [ -n "$Orphanedfolders" ] && {
      note "Removing cache files with: rm -R -f $Orphanedfolders"
      rm -R -f $Orphanedfolders 2>&1
    }
  }

  [ "${X11DOCKER_LASTCLEANFOLDER:-}" ] && {
    echo timetosaygoodbye >>$X11DOCKER_LASTCLEANFOLDER/share/timetosaygoodbye
    echo timetosaygoodbye >>$X11DOCKER_LASTCLEANFOLDER/share/timetosaygoodbye.fifo
    sleep 2
  }

  Logfile=

  note "Removing remaining files with: rm -Rf -v $Cachebasefolder/*"
  rm -Rf -v $Cachebasefolder/*

  note "Removing cache base folder with: rmdir -v $Cachebasefolder"
  cd
  [ "$(basename $Cachebasefolder)" = x11docker ] && rmdir -v $Cachebasefolder  || warning "Did not succeed in removing cache folder
  $Cachebasefolder
  Please run 'x11docker --cleanup' as root."

  $Dockerexe info >/dev/null 2>/dev/null || warning "Could not check for docker images.
  Please run 'x11docker --cleanup' as root
  to make sure that no orphaned containers are left."

  note "Cleanup ready."
}
installer() {           # --install, --update, --update-master, --remove: Installer for x11docker
  # --install:
  #   - copies x11docker and x11docker-gui to /usr/bin
  #   - installs icon in /usr/share/icons
  #   - creates x11docker.desktop file in /usr/share/applications
  # --update:
  #   - download and install latest release from github
  # --update-master:
  #   - download and install latest master version from github
  # --remove
  #   - remove installed files
  local Key1= Key2= Oldversion= Newversion=
  export PATH="$PATH:/usr/local/bin"  # avoid bug on opensuse where root does not have this in $PATH. Will become obsolete as new default is /usr/bin

  # Prepairing
  case ${1:-} in
    --install)
      [ -f "./x11docker" ]             || { error "File x11docker not found in current folder.
  Try 'x11docker --update' instead." ; }
      command -v x11docker > /dev/null && { warning "x11docker seems to be installed already.
  Will overwrite existing installation.
  Consider to use option '--update' or '--update-master' instead." ; }
    ;;
    --update|--update-master)
      Oldversion="$($0 --version)"
      note "Current installed version: x11docker $Oldversion"

      [ -d /tmp/x11docker-install ] && rm -R /tmp/x11docker-install
      mkdir -p /tmp/x11docker-install && cd /tmp/x11docker-install || error "Could not create or cd to /tmp/x11docker-install"
      command -v wget >/dev/null  || error "wget not found. Need 'wget' for download.
  Please install wget."
      command -v unzip >/dev/null || error "Can not unpack archive. Please install 'unzip'."

      case ${1:-} in
        --update-master)
          note "Downloading latest x11docker master version from github"
          wget https://github.com/mviereck/x11docker/archive/master.zip -O x11docker-update.zip || error "Could not download x11docker-master from github"
        ;;
        --update)
          wget https://raw.githubusercontent.com/mviereck/x11docker/master/CHANGELOG.md || error "Could not download CHANGELOG.md from github."
          Releaseversion="v$(cat CHANGELOG.md | grep "## \[" | grep -v 'Unreleased' | head -n1 | cut -d[ -f2 | cut -d] -f1)"
          note "Downloading latest x11docker release $Releaseversion from github"
          wget "https://github.com/mviereck/x11docker/archive/$Releaseversion.zip" -O x11docker-update.zip || error "Could not download latest x11docker release from github"
        ;;
      esac

      note "Unpacking archive"
      unzip x11docker-update.zip || error "Could not unzip archive"

      echo ""
      cd /tmp/x11docker-install/$(ls -l | grep drwx | rev | cut -d' ' -f1 | rev) || error "could not cd to /tmp/x11docker-update/$(ls -l | grep drwx | rev | cut -d' ' -f1 | rev)"
    ;;
  esac

  # Doing
  case ${1:-} in
    --install|--update|--update-master)
      note "Installing x11docker and x11docker-gui in /usr/bin"
      [ -e /usr/local/bin/x11docker ]     && rm -v /usr/local/bin/x11docker
      [ -e /usr/local/bin/x11docker-gui ] && rm -v /usr/local/bin/x11docker-gui
      cp x11docker /usr/bin/            || error "Could not copy x11docker to /usr/bin"
      chmod 755 /usr/bin/x11docker      || error "Could not set executeable bit on x11docker"
      cp x11docker-gui /usr/bin/  && chmod 755 /usr/bin/x11docker-gui || warning "x11docker-gui not found"

      note "Installing icon for x11docker with xdg-icon-resource"
      xdg-icon-resource install --context apps --novendor --mode system --size 64 "$(pwd)/x11docker.png" x11docker || warning "Could not install icon for x11docker.
  Is 'xdg-icon-resource' installed on your system?"
      xdg-icon-resource uninstall --size 72 x11docker ||:  # deprecated icon size, may still be present.

      note "Creating application entry for x11docker"
      [ -e "/usr/bin/x11docker-gui" ] && {
        echo "[Desktop Entry]
  Version=1.0
  Type=Application
  Name=x11docker
  Comment=Run GUI applications in docker images
  Exec=x11docker-gui
  Icon=x11docker
  Categories=System
" > /usr/share/applications/x11docker.desktop
      } || note "Did not create desktop entry for x11docker-gui"
      command -v kaptain >/dev/null || note "Could not find 'kaptain' for x11docker-gui.
  Consider to install 'kaptain' (version 0.73 or higher).
  It's useful for x11docker-gui only, though. x11docker itself doesn't need it.
  If your distributions does not provide kaptain, look at kaptain repository:
    https://github.com/mviereck/kaptain
  Fallback: x11docker-gui will try to use image x11docker/kaptain."

      note "Storing README.md, CHANGELOG.md and LICENSE.txt in
  /usr/share/doc/x11docker"
      mkdir -p /usr/share/doc/x11docker && {
        cp README.md    /usr/share/doc/x11docker/
        cp CHANGELOG.md /usr/share/doc/x11docker/
        cp LICENSE.txt  /usr/share/doc/x11docker/
      } || note "Error while creating /usr/share/doc/x11docker"

      Newversion="$(/usr/bin/x11docker --version)"
      note "Installed x11docker version $Newversion"
    ;;
    --remove)
      note "Removing x11docker from your system"
      cleanup
      [ -x /usr/local/bin/x11docker ] && {    # from older installations. /usr/bin is default now as /usr/local/bin can miss in $PATH for root
        rm -v /usr/local/bin/x11docker
        rm -v /usr/local/bin/x11docker-gui
      }
      [ -x /usr/bin/x11docker ] && {
        rm -v /usr/bin/x11docker
        rm -v /usr/bin/x11docker-gui
      }
      [ -e "/usr/share/applications/x11docker.desktop" ] && rm -v /usr/share/applications/x11docker.desktop
      [ -e "/usr/share/doc/x11docker" ]                  && rm -R -v /usr/share/doc/x11docker
      [ -e "/usr/share/icons/x11docker.png" ]            && rm /usr/share/icons/x11docker.png
      xdg-icon-resource uninstall --size 64 x11docker ||:
      xdg-icon-resource uninstall --size 72 x11docker ||:  # deprecated icon size, may still be present.
      note "Will not remove files in your home folder.
  There may be files left in \$HOME/.local/share/x11docker
  The symbolic link \$HOME/x11docker may exist, too.
  The cache folder \$HOME/.cache/x11docker should be removed already."
    ;;
  esac

  # Cleanup
  case ${1:-} in
    --update|--update-master)
      note "Removing downloaded temporary files ..."
      cd ~
      rm -R /tmp/x11docker-install
    ;;
  esac

  # Changelog excerpt
  case ${1:-} in
    --update)
      echo "$Oldversion" | grep -q beta && {
        warning "You are switching from master branch to stable releases.
  To get latest master beta version, use option --update-master instead"
        Key1="\[${Newversion}\]"
        Key2="https:\/\/github.com\/mviereck\/x11docker\/releases"
      } || {
        Key1="\[${Newversion}\]"
        Key2="\[${Oldversion}\]"
        [ "$Newversion" = "$Oldversion" ] && {
          Key2="https:\/\/github.com\/mviereck\/x11docker\/releases"
          note "Version $Newversion was already installed before this update.
  If you want the latest beta version from master branch, use --update-master."
        }
      }
    ;;
    --update-master)
      echo "$Oldversion" | grep -q beta && {
        Key1="\[Unreleased\]"
        Key2="https:\/\/github.com\/mviereck\/x11docker\/releases"
      } || {
        Key1="\[Unreleased\]"
        Key2="\[${Oldversion}\]"
      }
    ;;
  esac
  case ${1:-} in
    --update|--update-master)
      note "Excerpt of x11docker changelog:
$(sed -n '/'$Key1'/,/'$Key2'/p' /usr/share/doc/x11docker/CHANGELOG.md | head -n-1)"
    ;;
  esac

  note "Ready."
}
convertpath() {         # convert path $1 into --volume syntax regarding Windows subsystem pathes
  local Patharg Volumecode
  Patharg="${1:-}"
  case $Winsubsystem in
    "") # regular handling on real linux
      Volumecode="'$Patharg':'$Patharg'" 
    ;;
    
    *) # special cases for Windows subsystems

      # replace \ with /
      Patharg="$(tr '\\' '/' <<< "$Patharg")"
      # Path is already formated like /c/ ?
      # -> leave as it is
      [ "$(cut -c1,3 <<< "$Patharg")" = "//" ] && Volumecode="'$Patharg':'$Patharg'" || {
        [ "$(cut -c2 <<< "$Patharg")" = ":" ] && {
          # Path begins with e.g. C: or D: ?
          # -> change e.g. C: to /c/
          Patharg="$(tr -d : <<< "$Patharg")"
          Patharg="/${Patharg,}"
          Volumecode="'$Patharg':'$Patharg'"
        } || {
          [ "$Winsubmount" ] && [ "$(cut -c1-${#Winsubmount} <<< "$Patharg" | tr [:upper:] [:lower:])" = "$Winsubmount" ] && {
            # Path points to Win host over mountpoint in subsystem subfolder
            # -> remove mountpoint of subsystem to have e.g. /c/ at begin
            Volumecode="'${Patharg#$Winsubmount}':'${Patharg#$Winsubmount}'"
          }
        } || {
          # Path is part of subsystem ?
          # -> add Windows path leading to subsystem
          Volumecode="'$Winsubpath$Patharg':'$Patharg'"
          [ "$Winsubsystem" = "WSL" ] && error "Can not share pathes within WSL with docker containers.
  Failing: $Patharg"
        }
      }
    ;;
  esac
  echo "$Volumecode"
}
rmcr() {                # remove carriage return to translate DOS/Windows newlines into UNIX newlines
  # convert stdin if $1 is empty. Otherwise convert file $1.
  case "${1:-}" in
    "") sed    "s/$(printf "\r")//g" ;;
    *)  sed -i "s/$(printf "\r")//g"  "${1:-}"
  esac
}
verlte() {              # version number check $1 less than or equal $2
  [  "${1:-}" = "$(echo -e "${1:-}\n${2:-}" | sort -V | head -n1)" ] && return 0 || return 1
}
verlt() {               # version number check $1 less than $2
  [ "${1:-}" = "${2:-}" ] && return 1 || { verlte "${1:-}" "${2:-}" && return 0 || return 1 ; }
}
isnum() {               # check if $1 is a number
  [ "1" = "$(awk -v a="${1:-}" 'BEGIN {print (a == a + 0)}')" ]
}
escapestring() {        # escape special chars of $1
  # escape all characters except those described in [^a-zA-Z0-9,._+@=:/-]
  echo "${1:-}" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@=:/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}
writeaccess() {         # check if useruid $1 has write access to folder $2
  local dirVals= gMember= IFS=
  if IFS=$'\t' read -a dirVals < <(stat -Lc "%U	%G	%A" "${2:-}") && (
    ( [ "$(id -u $dirVals)" == "${1:-}" ] && [ "${dirVals[2]:2:1}" == "w" ] ) ||
    ( [ "${dirVals[2]:8:1}" == "w" ] ) ||
    ( [ "${dirVals[2]:5:1}" == "w" ] && (
        gMember=($(groups ${1:-} 2>/dev/null)) &&
        [[ "${gMember[*]:2}" =~ ^(.* |)${dirVals[1]}( .*|)$ ]]
    ) ) )
  then
    return 0
  else
    [ "w" = "$(getfacl -pn "${2:-}" | grep user:${1:-}: | rev | cut -c2)" ] && return 0 || return 1   # FIXME: could check write access for gid, if uid access fails.
  fi
}

{ #### part: declare variables
trap finish EXIT
trap finish_sigint SIGINT

#PS4='+\t ' && set -x

export IFS=$' \n\t'                             # set IFS to default
# redirects for use in parts with >xy 2>xy
exec 3>&2                                       # stderr channel for warning() and error()
exec 4>&2                                       # stderr channel for --stderr

export PATH="$PATH:/usr/games:/usr/local/bin"          # may miss for root, but can be needed for --exe and --xfishtank
export PATH="$PATH:/usr/sbin:/sbin"                    # may miss for unprivileged users, but can be needed for `ip`

Bgpidfile=backgroundpids                        # file to store pids and names of background processes that shut be killed on exit
Timetosaygoodbye=timetosaygoodbye               # file giving term signal to all parties
Timetosaygoodbyefifo=timetosaygoodbye.fifo
Watchpidfifo=watchpid.fifo
Watchpidlist=""
Messagefifo=message.fifo

# x11docker log
Logfile=""

# terminal colors
Esc="$(printf '\033')"
Colblue="${Esc}[35m"
Colyellow="${Esc}[33m"
Colgreen="${Esc}[32m"
Colgreenbg="${Esc}[42m"
Colred="${Esc}[31m"
Colredbg="${Esc}[41m"
Coluline="${Esc}[4m"
Colnorm="${Esc}[0m"

# Users
Startuser="$(id -un)"                           # user who started x11docker
Lognameuser=""                                  # $(logname) or $SUDO_USER or $PKEXEC_USER
Hostuser=""                                     # $Lognameuser or --hostuser. Unprivileged user for non-root commands
Hostuseruid=""
Hostusergid=""
Hostuserhome=""
Homebasefolder=""
Benutzer=""                                     # option --user: container user. Default: same as $Hostuser.
Benutzeruid=""
Benutzergid=""
Benutzerhome=""
Benutzergruppe=""
Benutzerpasswdentry=""
Benutzerpasswort="sac19FwGGTx/A"                # encrypted password "x11docker", suits /etc/shadow. Generated with:  perl -e 'print crypt("x11docker", "salt"),"\n"'
Mksu=""                                         # prefix to run unprivileged commands (auto or --hostuser)
Mksubenutzer=""                                 # prefix to run commands as user defined by --user
Hostgidaudio=""                                 # host GID of group audio. Can differ from container GID
Hostgidvideo=""                                 # host GID of group video. Can differ from container GID
Groupadd=""                                     # option --group-add: additional groups for container user

# Gaining root privileges to run docker
Passwordfrontend=""                             # --pw: method to prompt for password. one of pkexec, su, sudo, gksu, gksudo, kdesu, kdesudo, lxsu, lxsudo, beesu, auto, none
Passwordcommand=""                              # generated command for password prompt
Sudo=""                                         # "sudo", "sudo -n", or empty
Passwordneeded="yes"                            # password needed to run docker? assume yes, check later

# Cache folders
Cachebasefolder=""                              # base cache folder to store temporary files
Cachefolder=""                                  # subfolder of $Cachebasefolder for current container
Sharefolder=share                               # subfolder of $Cachefolder for files shared with container
Cshare=/x11docker                               # mountpoint of $Sharefolder in container

# Parsed arguments
X11dockermode="run"                             # can be either "xonly", "run" or "exe", depends on options. while parsing, xonly changes to run or exe
X11dockerargs="$*"                              # arguments for x11docker, stored for logfile and for --starter
Imagename=""                                    # name of image to run
Imagecommand=""                                 # image command [+args]
Imagecommandbasename=""                         # image command without path or args
Imagenametr=""                                  # image name with : and / replaced by - for use with container name and --home folder
Hostexe=""                                      # option --exe: contains host executable
Hostexebasename=""                              # option --exe: host executeable name without path or options
Customdockeroptions=""                                # custom options for "docker run". Provide after -- and before image name, encapsulated with "" (or without whitespaces)

# docker variables
Containername=""                                # generated container name
Containerpid=""                                 # container PID
Nonewprivileges="yes"                           # docker run option --security-opt=no-new-privileges. Default: yes. Disabled by options --cap-default and --sudouser.

# docker related files
Dockerrc=dockerrc                               # generated script to check image, set up host and create $Imagecommandscript
Containerrootsetupscript=container.rootsetup.sh # generated script to set up container. runs as root in container.
Imagecommandscript=container.CMD.sh             # generated script starting image comand in container
Containerlogfile=container.log                  # file to log output of container
Containerpidfile=container.pid                  # file to store container PID
Containeridfile=container.id                    # file to store container ID
Containeripfile=container.ip                    # file to store container IP
Containerpid1pidfile=container.pid1pid          # file to store host PID of container PID 1

# X server config files, log files and such stuff
Xinitrc=xinitrc                                 # generated xinitrc script
Xtermrc=xtermrc                                 # generated script for password prompt
Pullrc=pullrc                                   # generated script for pull dialog
Xinitlogfile=xinit.log                          # logfile for xinit/X server
Xpraserverlogfile=xpraserver.log                # logfile for xpra server
Xpraclientlogfile=xpraclient.log                # logfile for xpra client
Westonini=weston.ini                            # generated config file for weston
Customwestonini=""                              # --westonini: custom config file for weston
Xdummyconf=xdummy.xorg.conf                     # generated xorg.conf for dummy video driver
Xorgwrapper=Xorgwrapper                         # fork from xpra to wrap Xorg for Xdummy
Xservercookie=Xservercookie                     # generated X server cookie
Xclientcookie=Xclientcookie                     # generated X client cookie. Normally same as $Xservercookie, except for --hostdisplay and --nxagent
Xkbkeymapfile=xkb_keymap                        # file to store output of host keymap in xinitrc: 'setxkbmap -display $Hostdisplay -print'

# stdin stdout stderr
Forwardstdin="no"                               # option --stdin: forward stdin to image command
Cmdstdinfile=stdin                              # stdin for image command. fifo/named pipe to forward stdin of x11docker to image command
Cmdstdoutlogfile=stdout                         # stdout for image command
Cmdstderrlogfile=stderr                         # stderr for image command

# host environment
Hostsystem="$(source /etc/os-release 2>/dev/null; echo $ID)"
Hostdisplay="$DISPLAY"                          # store environment variable containing name of current display
Hostdisplaynumber="$(echo $Hostdisplay | cut -d: -f2 | cut -d. -f1)"                         # display number without ":" and ".0"
Hostxauthority="Xauthority-$Hostdisplaynumber"                                               # file to store copy of $XAUTHORITY
[ -n "$Hostdisplay" ] && Hostxsocket="/tmp/.X11-unix/X$Hostdisplaynumber" || Hostxsocket=""  # X socket from host, needed for --hostdisplay
[ -e "$Hostxsocket" ] || Hostxsocket=""                                                      # can miss in SSH session
Hostip=""
Hostxenv=""                                                                                  # collection of host X environment variables
Hostlibc="unknown"                                                                           # check libc:glibc, musl or others. Needed to eventually provide time zone file.
ldd --version 2>&1 | grep -q 'musl libc'          && Hostlibc='musl'
ldd --version 2>&1 | grep -q -E 'GLIBC|GNU libc'  && Hostlibc='glibc'
Hostlocaltime="$(realpath /etc/localtime)"                                                   # find time zone file in /usr/share/zoneinfo
Hostutctime=$(date +%:::z) ; [ "$(cut -c1 <<< "$Hostutctime")" = "+" ] && Hostutctime="UTC-$(cut -c2- <<< "$Hostutctime")" || Hostutctime="UTC+$(cut -c2- <<< "$Hostutctime")" # offset of UTC if time zone file cannot be provided
Ssh=""
Tty=""
Ttyinuse=""

# Check for MS Windows subsystem
Winsubsystem=""
Winsubmount=""
Winsubpath=""
#grep -q "/mnt/c/Windows/System32" <<< ${PATH:-} && Winsubsystem="WSL"
uname -r | grep -q Microsoft                    && Winsubsystem="WSL"
command -v cygcheck.exe >/dev/null && {
  cygcheck.exe -V | rmcr | grep -q "(cygwin)"   && Winsubsystem="CYGWIN"
  cygcheck.exe -V | rmcr | grep -q "(msys)"     && Winsubsystem="MSYS2"
}
case $Winsubsystem in
  MSYS2|CYGWIN) 
    Winsubpath="$(convertpath "$(cygpath.exe -w "/" | rmcr)" | cut -d "'" -f2)" 
    Winsubmount="$(cygpath.exe -u "c:/" | sed s%/c/%%)" ;;
  WSL)          
    Winsubpath="CANNOT_SHARE_WSL_PATH"
    Winsubmount="/mnt" ;;
esac
# Needed for Windows subsystems only
Dockerexe="docker"
[ "$Winsubsystem" ] && {
  export PATH="$PATH:$Winsubmount/c/Program Files/docker:$Winsubmount/c/Program Files/Docker/Docker/resources/bin"
  Dockerexe="docker.exe"
}
Vcxsrvpath=""                                   # path to vcxsrv.exe and xauth.exe
Tasklistold=""                                  # Output of tasklist.exe to get Windows pid of vcxsrv.exe
Tasklistnew=""
Winpidlist=""                                   # List of stored Windows pids (currently vcxsrv.exe on WSL only)
Xauth="xauth"                                   # either 'xauth' or 'xauth.exe'

# X server settings
Xserver=""                                      # X server option to use
Xcommand=""                                     # created command to start X server
Newdisplay=""                                   # new display for new X server
Newdisplaynumber=""                             # new display number for new X server. Without ':'
Newxsocket=""                                   # New X socket
Newxenv=""                                      # environment variables for new X server DISPLAY XAUTHORITY XSOCKET WAYLAND_DISPLAY
Newxvt=""                                       # option --vt or automatically: number of virtual console to use for --xorg (>7)
Newxlock=""                                     # .Xn-lock - exists for running X server with socket n
Xlegacywrapper=""                               # option --xorg: /etc/X11/Xwrapper.config is configured to run within X yes/no
Xserveroptions=""                               # created options for new X server
Xpraservercommand=""                            # created xpra server command
Xpraclientcommand=""                            # created xpra client command
Xpraserverpid=""                                # pid of xpra server
Xpraclientpid=""                                # pid of xpra client
Xpracrashcount=""                               # count of xpra server crashes. x1docker restarts it a few times and disables --mmap before giving up
Xpraoptions=""                                  # options for xpra server and client
Xprashm=""                                      # content XPRA_XSHM=0 disables usage of MIT-SHM in xpra
Xpraversion=""                                  # $(xpra --version) to decide some xpra options and messages
Xprarelease=""                                  # release number from $Xpraversion
Nxagentoptions=""                               # options for nxagent
Xephyroptions=""                                # options for Xephyr
Xephyrglamor="yes"                              # former option '--glamor': enable Xephyr glamor 2D acceleration (deprecated, now always yes)
Xfishtank="no"                                  # option --xfishtank: fish tank on new X server
Xtest=""                                        # enable extension Xtest yes/no. If empty, yes for --xpra/--xdummy/--xvfb, otherwise no
Xkblayout=""                                    # option '--keymap': Layout for keymap, compare /usr/share/X11/xkb/symbols
Xinitpid=""
Xserverpid=""

# Main X server options
Autochooseserver="yes"                          # option '--auto': automatically choose X server (default)
Desktopmode="no"                                # option --desktop: image contains a desktop enironment.
Windowmanager=""                                # option '-w, --wm': window manager to use. If not given but needed, autodetection is used
Sharegpu="no"                                   # option '--gpu': Use hardware accelerated OpenGL, share files in /dev/dri

# --gpu: nvidia
Nvidiadriver=""                                 # option '--gpu': nvidia driver installer for container in [...]local/share/x11docker
Nvidiaversion=""                                #   "        "    nvidia driver version on host

# Screensize and related X server adjustments
Screensize=""                                   # option --size XxY
Xaxis=""                                        # virtual screen width
Yaxis=""                                        # virtual screen height
Modeline=""                                     # screen modeline describing display size, see "man cvt"
Maxxaxis=""                                     # maximal screen size of display to support fullscreen beside windowed desktop
Maxyaxis=""
Fullscreen="no"                                 # option '-f, --fullscreen': use fullscreen mode (Xephyr only)
Scaling=""                                      # option --scale: Scaling factor for xpra and weston
Rotation=""                                     # option --rotate: Rotation for --weston and --weston-xwayland 0/90/180/270/flipped/flipped-90/..
Dpi=""                                          # option --dpi: dots per inch to tell the clients.
Outputcount="1"                                 # option --output-count, quantum of virtual screens for Weston and Xephyr

# Wayland and Weston
Hostwaylandsocket="$WAYLAND_DISPLAY"            # store host wayland socket name
Newwaylandsocket=""                             # Wayland socket of $Compositorcommand
Compositorcommand=""                            # command to start Weston or KWin
Waylandtoolkitenv="XDG_SESSION_TYPE=wayland GDK_BACKEND=wayland QT_QPA_PLATFORM=wayland CLUTTER_BACKEND=wayland SDL_VIDEODRIVER=wayland ELM_DISPLAY=wl ELM_ACCEL=opengl ECORE_EVAS_ENGINE=wayland_egl"
Westonoutput=""                                 # Xn, WLn (nested mode) or monitor identifier (drm mode on tty)
Sharewayland="no"                               # share wayland socket and WAYLAND_DISPLAY
Setwaylandenv="no"                              # set environment variables $Waylandtoolkitenv
Compositorpid=""                                # PID of weston or kwin_wayland
Compositorpidfile=compositor.pid                # file to store PID of compositor
Compositorlogfile=compositor.log                # logfile for weston or kwin_wayland
Xwaylandpid=""                                  # PID of Xwayland during screen size check in Wayland enviroments

# Available terminal emulators
Passwordterminal=""                             # terminal emulator to use for password prompt (if no terminal emulator is needed, it will be 'bash -c')
Pullterminal=""                                 # terminal emulator to show progress of 'docker pull'
Anyterminal=""                                  # terminal emulator for alert()
Terminallist=""                                 # list of possible terminal emulators. Only a few work on wayland

# regular options
Sudouser="no"                                   # option --sudouser: Create user and root with sudo permissions with password 'x11docker'
Benutzerhosthome="no"                           # option '-m, --home' (or '--homedir'): share a folder ~/.local/share/x11docker/Imagename with created container
Benutzerhosthomefolder=""                       #   "        "   : path to shared folder.
Sharevolumes=""                                 # option --volume: host folders to share, array
Sharevolumescount="0"                           # counts shared folders in array
Shareclipboard="no"                             # option '-c, --clipboard' enable clipboard sharing
Shareclipboardscript=clipboard.bash             #    "              "      created script for text clipboard sharing
Alsa="no"                                       # option --alsa: enable ALSA sound, share /dev/snd
Noentrypoint="no"                               # option --no-entrypoint: disable entrypoint in image
Internetaccess="yes"                            # option --no-internet: disable internet access
Langwunsch=""                                   # option --lang: search or create UTF-8 locale and set LANG

# --pulseaudio
Pulseaudiomode=""                               # option --pulseaudio: 'tcp' or 'socket'
Pulseaudiologfile=pulseaudio.log
Pulseaudioconf=pulseclient.conf
Lowerport=""
Upperport=""
Pulseaudioport=""

# verbosity options
Verbose="no"                                    # option '-v, --verbose': if "yes", be verbose
Showstdout="no"                                 # option --stdout: show image command stdout
Showstderr="no"                                 # option --stderr: show image command stderr
Silent="no"                                     # option --silent: do not show messages
Showdisplayenvironment="no"                     # option -E, --env: output of environment variables of new display on stdout
Showcontainerid="no"                            # option --showid: output of container id on stdout
Showcontainerpid1pid="no"                       # option --showpid1: output of host PID of container PID 1
Verbosecolors="yes"                             # colored output for --verbose and delete some systemd error messages.
Debugmode="no"                                  # option --debug: Throw it all out
DebugPS4='+ \033[32m${LINENO}:${FUNCNAME[0]:+${FUNCNAME[0]}(): }\033[0m'

# advanced options
Customenvironment=""                            # option '--env': set custom environment variables
Capdropall="yes"                                # option --cap-default: (don't) drop all container capabilities
Adminusercaps="no"                              # options --sudouser, --systemd: add capabilities for general sys administration
Switchcontaineruser="no"                        # options for init systems: user switching to toggle login daemons
Switchcontainerusercaps="no"                    # options --dbus, --sudouser and initsystems: add capabilities for su/sudo user switching
Sharehostipc="no"                               # option --hostipc, set --ipc=host.
Sharehostnet="no"                               # option --hostnet, set --ipc=net
Preservecachefiles="no"                         # if yes, dont delete cache files
Capsysadmin="no"                                # option --sys-admin: add capability SYS_ADMIN (deprecated)
Runfromhost=""                                  # option --runfromhost: add host command to xinitrc
Runasroot=""                                    # option --runasroot: add command running as root to container setup script
Workdir="/tmp"                                  # option --workdir: set working directory

# init and dbus
Initsystem="tini"                               # options --systemd --openrc --runit --sysvinit --tini --no-init:Init system in container
Sharecgroup="no"                                # options --systemd, --cgroup: share /sys/fs/cgroup
Dbuslaunch="no"                                 # option '--dbus': run image command with dbus-launch
Dbusdaemon="no"                                 # option '--dbus-dameon': set up dbus daemon in container
Tinibinary=""                                   # option --tini/default: binary for tini; either /usr/bin/docker-exec or provided by user in ...share/x11docker

# X authentication
Xauthentication="yes"                           # option '--no-auth' use cookie authentication yes/no
Trusted="yes"                                   # Create trusted or untrusted cookies,  --hostdisplay uses untrusted cookies
Forcetrusted="no"                               # option --trusted: enforce trusted cookies for --hostdisplay
Noxhost="no"                                    # option '--no-xhost': if yes, disable all X server access granted by xhost
Xhost=""                                        # option '--xhost': xhost + on new X server

# special options not starting X or docker
Checkorphaned="no"                              # option '--cleanup': check for non-removed containers and maybe root-owned files in cache
Createdesktopstarter="no"                       # option '--starter': create desktop starter and exit yes/no
Installermode=""                                # options --install/--update/--remove

# some temporary or loop variables
Pid=""
Name=""
Zeit=""
Line=""
Count=""

# these window managers are known to work well with x11docker (alphabetical order)(excluding $Wm_not_recommended and $Wm_ugly):
Wm_good="amiwm blackbox cinnamon compiz ctwm enlightenment fluxbox flwm fvwm"
Wm_good="$Wm_good jwm kwin lxsession mate-session mate-wm marco metacity notion olwm olvwm openbox ororobus pekwm"
Wm_good="$Wm_good sawfish twm wmaker w9wm xfwm4"
# these wm's are recommended and lightweight, but cannot show desktop options. best first:
Wm_recommended_nodesktop_light="xfwm4 metacity marco sawfish"
# these wm's are recommended and heavy, but cannot show desktop options (especially exiting themselves). best first:
Wm_recommended_nodesktop_heavy="kwin compiz"
# these wm's are recommended, lightweight AND desktop independent. best first:
Wm_recommended_desktop_light="flwm blackbox fluxbox jwm mwm wmaker afterstep amiwm fvwm ctwm pekwm olwm olvwm openbox"
# these wm's are recommended, heavy AND desktop independent. best first:
Wm_recommended_desktop_heavy="lxsession mate-session enlightenment cinnamon cinnamon-session plasmashell"
# these wm's are not really useful (please don't hit me) (best first):
Wm_not_recommended="awesome evilwm herbstluftwm i3 lwm matchbox miwm spectrwm subtle windowlab wmii wm2"
# these wm's cannot be autodetected by wmctrl if they are already running
Wm_nodetect="aewm aewm++ afterstep awesome ctwm mwm miwm olwm olvwm sapphire windowlab wm2 w9wm"
# these wm's can cause problems (they can be beautiful, though):
Wm_ugly="icewm sapphire aewm aewm++"
# these wm's doesn't work:
Wm_bad="budgie-wm clfswm tinywm tritium mutter muffin gnome-shell"
# List of all working window managers, recommended first: (excluding $Wm_bad)
Wm_all="$Wm_recommended_nodesktop_light $Wm_recommended_nodesktop_heavy  $Wm_recommended_desktop_light $Wm_recommended_desktop_heavy $Wm_good $Wm_ugly $Wm_not_recommended $Wm_nodetect"

Messagefifofuncs='
warning() {
  echo "$*:WARNING"   >>$Messagefile
}
note() {
  echo "$*:NOTE"      >>$Messagefile
}
verbose() {
  echo "$*:VERBOSE"   >>$Messagefile
}
debugnote() {
  echo "$*:DEBUGNOTE" >>$Messagefile
}
error() {
  echo "$*:ERROR"     >>$Messagefile
  exit 1
}
stdout() {
  echo "$*:STDOUT"    >>$Messagefile
}'
}

{ #### part: parsing cli options
  Shortoptions="aAbcdefgGhHKml:MnNopPrsutTvw:WxXyY"
  Longoptions="auto,x,X,xpra,xephyr,x11,xorg,hostdisplay,xwayland,weston-xwayland,xpra-xwayland,nxagent,wayland"           # X servers
  Longoptions="$Longoptions,weston,hostwayland,kwin,kwin-xwayland,xdummy,xvfb,nothing,vcxsrv,xwin"                         # more X/Wayland servers
  Longoptions="$Longoptions,wm:,desktop,exe,xonly"
  Longoptions="$Longoptions,fullscreen,size:,scale:,rotate:,dpi:,output-count:,gpu,xfishtank"                              # X appearance options
  Longoptions="$Longoptions,xhost:,no-auth,vt:,display:,xtest,no-xtest,env:,showenv,showid,showpid1"                       # X and environment options
  Longoptions="$Longoptions,home,clipboard,pulseaudio::,alsa,lang:"                                                        # comfort options
  Longoptions="$Longoptions,no-xhost,trusted,untrusted,dbus,dbus-system,pw:,no-internet,workdir:,sharessh"                 # advanced options
  Longoptions="$Longoptions,homedir:,sharedir:,cachebasedir:,homebasedir:"                                                 # host folders
  Longoptions="$Longoptions,tini,no-init,systemd,runit,openrc,sysvinit,sys-admin,sharecgroup"                              # init system options
  Longoptions="$Longoptions,starter,cleanup,license,licence,help,version,install,update,update-master,remove,wmlist"       # special options without starting X or container
  Longoptions="$Longoptions,verbose,silent,debug,stdout,stderr,stdin"                                                      # verbose options
  Longoptions="$Longoptions,hostipc,hostnet,ps,cache,cap-default,sudouser,hostuser:,user:,group-add:,name:"                # capabilities, users
  Longoptions="$Longoptions,keymap:,name:,no-entrypoint,runfromhost:,runasroot:,westonini:"                                # developer options
  Longoptions="$Longoptions,cachedir:"                                                                                     # deprecated
  
  Parsedoptions="$(getopt --options $Shortoptions --longoptions $Longoptions --name "$0" -- "$@" 2>/tmp/x11docker_parsererror)"
  [ -e /tmp/x11docker_parsererror ] && Parsererror=$(cat /tmp/x11docker_parsererror) && rm /tmp/x11docker_parsererror
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  
  [ "$*" = "-h --" ] &&    usage         && exit 0         # catch single -h for usage info, otherwise it means --hostdisplay

  while { [ $# -gt 0 ] && [ -z "$Imagename" ] ;}; do
    case "${1:-}" in
      --help)              usage         && exit 0  ;;     # show help/usage and exit
      --license|--licence) license       && exit 0  ;;     # show MIT license and exit
      --version)           echo $Version && exit 0  ;;     # output version number and exit

      -e|--exe)        X11dockermode="exe"   ;;            # execute application from host instead of running docker image
         --xonly)      X11dockermode="xonly" ;;            # only create X erver

     #### X servers
         --auto)                                                   Autochooseserver="yes" ;; # use xpra or --xephyr, --xorg or hostdisplay, --xpra-xwayland or --weston-xwayland
      -a|--xpra)                     Xserver="--xpra" ;            Autochooseserver="no"  ;; # use xpra on host
      -y|--xephyr)                   Xserver="--xephyr" ;          Autochooseserver="no"  ;; # use Xephyr
      -x|--xorg|--x11)               Xserver="--xorg" ;            Autochooseserver="no"  ;; # use core Xorg
      -h|--hostdisplay)              Xserver="--hostdisplay" ;     Autochooseserver="no"  ;; # use host display :0 with shared X socket
      -X|--xwayland)                 Xserver="--xwayland" ;        Autochooseserver="no"  ;; # Xwayland needs already running Wayland
      -A|--xpra-xwayland)            Xserver="--xpra-xwayland" ;   Autochooseserver="no"  ;; # Xpra with Xwayland
      -Y|--weston-xwayland)          Xserver="--weston-xwayland" ; Autochooseserver="no"  ;; # Weston-Xwayland as Wayland compositor with Xwayland, runs in X or standalone from console
         --xdummy)                   Xserver="--xdummy" ;          Autochooseserver="no" ; Showdisplayenvironment="yes" ;;  # use Xdummy. Invisible on host. For custom network setups with VNC or xpra
         --xvfb)                     Xserver="--xvfb" ;            Autochooseserver="no" ; Showdisplayenvironment="yes" ;;  # use Xvfb. Invisible on host. For custom network setups with VNC or xpra
      -N|--nothing)                  Xserver="--nothing" ;         Autochooseserver="no"  ;; # Do not provide any X nor Wayland
      -T|--weston)                   Xserver="--weston" ;          Autochooseserver="no"  ;; # Wayland in Weston only, no X
      -H|--hostwayland)              [ "$Xserver" = "--hostdisplay" ] || Xserver="--hostwayland" # share host wayland. Allow coexistence with option --hostdisplay
                                     Sharewayland="yes" ;          Autochooseserver="no"  ;;
      -K|--kwin)                     Xserver="--kwin" ;            Autochooseserver="no"  ;;
         --kwin-xwayland)            Xserver="--kwin-xwayland" ;   Autochooseserver="no"  ;;
      -n|--nxagent)                  Xserver="--nxagent" ;         Autochooseserver="no"  ;;
         --vcxsrv)                   Xserver="--vcxsrv" ;          Autochooseserver="no"  ;;
         --xwin)                     Xserver="--xwin" ;            Autochooseserver="no"  ;;

     #### Influencing X server
      -d|--desktop)    Desktopmode="yes" ;;                # image contains a desktop environment.
      -g|--gpu)        Sharegpu="yes" ;;                        # share files in /dev/dri, allow GPU usage
      -w|--wm)         case ${2:-} in                      # choose host window manager
                         ""|"n"|"none") Windowmanager="none" ;;
                         "m"|"auto")    Windowmanager="auto" ;;
                         *)             Windowmanager=${2:-} ;;
                       esac
                       shift
                       Desktopmode="yes" ;;
      -W|--wayland)    Sharewayland="yes"                  # set up wayland environment, regards --desktop
                       Setwaylandenv="yes"
                       Dbusdaemon="yes" ;;

     #### Appearance
      -f|--fullscreen) Fullscreen="yes"  ;;                # fullscreen mode for Xephyr and Weston
         --size)       Screensize="${2:-}" ;  shift ;;     # set virtual screen size
      -l|--scale)      Scaling=${2:-} ; shift ;;           # zoom
         --rotate)     Rotation=${2:-} ; shift ;;          # rotation and mirroring
         --dpi)        Dpi=${2:-} ; shift ;;               # dots per inch / influences font size
         --output-count) Outputcount="${2:-}" ; shift ;;   # number of virtual outputs
         --xfishtank)   Xfishtank="yes" ;;                 # Run xfishtank on new X server

     #### Options
      -m|--home)       Benutzerhosthome="yes" ;;           # share folder ~/x11docker/Imagename with container
      -c|--clipboard)  Shareclipboard="yes"  ;;            # share host clipboard with dockered applications (xpra only)
         --alsa)       Alsa="yes" ;;                       # enable ALSA sound (shares /dev/snd)
      -p)              Pulseaudiomode="socket" ;;          # enable pulseaudio sound
         --pulseaudio) Pulseaudiomode="${2:-}" ; shift     # enable pulseaudio sound
                       [ "$Pulseaudiomode" ] || Pulseaudiomode="socket" ;;
         --lang)       Langwunsch=${2:-} ; shift ;;        # locale/language setting

     #### Advanced options
      -b|--dbus)       Dbuslaunch="yes" ;;                 # run image command with dbus-launch or dbus-run-session
         --no-entrypoint) Noentrypoint="yes" ;;            # don't use ENTRYPOINT of image
         --no-internet)Internetaccess="no" ;;              # disallow internet access
         --workdir)    Workdir="$(escapestring "${2:-}")" ; shift ;; # set working directory
         --pw)         Passwordfrontend="${2:-}" ; shift ;;  # frontend for password prompt
         --runfromhost) Runfromhost="$Runfromhost
${2:-}"                ; shift ;;                          # add custom host command in xinitrc
         --runasroot)  Runasroot="$Runasroot
${2:-}"                ; shift ;;        # add custom root command in container setup script
         --stdin)      Forwardstdin="yes" ;;                # forward stdin to image command


     #### Verbose options
      -v|--verbose)    Verbose="yes"  ;;                   # be verbose
         --stdout)     Showstdout="yes" ;;                 # show stdout of image command
         --stderr)     Showstderr="yes" ;;                 # show stderr of image command
         --silent)     Silent="yes" ; exec 3>/dev/null ;;  # do not show warnings or errors
         --debug)      Debugmode="yes" ;;                      # debugging mode

     #### Developer options
         --sharessh)   [ -e "${SSH_AUTH_SOCK:-}" ] && {                # share host folder at same location in container with rw access
                         Sharevolumescount=$(($Sharevolumescount + 1))
                         Sharevolumes[$Sharevolumescount]=$(dirname $SSH_AUTH_SOCK)
                         Customenvironment="SSH_AUTH_SOCK=$(escapestring "${SSH_AUTH_SOCK:-}")
$Customenvironment"
                       } || warning "Option --sharessh: environment variable \$SSH_AUTH_SOCK not set:" ; ;;
       ## User settings
         --user)       Benutzer="${2:-}"  ; shift ;;       # set container user instead of host user
         --hostuser)   Hostuser="${2:-}" ; shift ;;        # set host user different from logged in user
         --sudouser)   Sudouser="yes" ;;                   # give container user sudo without password
         --group-add)  Groupadd="$Groupadd ${2:-}" ; shift ;; # additional groups for user

       ## init system
         --no-init)    Initsystem="none" ;;                # no init, image command is PID 1
         --tini)       Initsystem="tini" ;;                # default init system tini (run option --init)
         --runit)      Initsystem="runit" ;;               # run runit as init system and image command as a service
         --openrc)     Initsystem="openrc" ;;
         --systemd)    Initsystem="systemd" ;;             # run systemd as init system and image command as a service
         --sysvinit)   Initsystem="sysvinit" ;;
         --sharecgroup)Sharecgroup="yes" ;;                # share /sys/fs/cgroup. default for --systemd, possible use with --openrc
         --sys-admin)  Capsysadmin="yes" ;;                # add capability SYS_ADMIN for older systemd versions in image (i.e. debian 9 needs it, debian 10 runs well)
         --dbus-system) Dbusdaemon="yes" ;;                # set up dbus system daemon

       ## Environment
         --showid)     Showcontainerid="yes" ;;            # output of container id on stdout
         --showenv)    Showdisplayenvironment="yes" ;;     # output of display number and cookie file on stdout. Catch with  ~$ read xdenv < <(x11docker --showenv)
         --showpid1)   Showcontainerpid1pid="yes" ;;       # output of host PID of container PID 1
         --env)        Customenvironment="$(escapestring "${2:-}")
$Customenvironment"    ;  shift ;;                         # set custom environment variables
         --vt)         Newxvt="${2:-}" ;         shift ;;  # set virtual console to use
         --display)    Newdisplaynumber=${2:-}             # display number to use
                       [ "$(echo $Newdisplaynumber | cut -c1)" = ":" ] && Newdisplaynumber="$(echo $Newdisplaynumber | cut -c2-)"
                       shift ;;
         --xtest)      Xtest="yes" ;;                      # allow extension XTEST. default for xvfb, xdummy and xpra
         --no-xtest)   Xtest="no" ;;                       # disable extension XTEST. default for most X server options
         --keymap)     Xkblayout="${2:-}" ; shift ;;       # keymap layout for xkbcomp. Compare /usr/share/X11/xkb/symbols

       ## X Authentication
         --xhost)      Xhost="$2" ; shift ;;               # custom xhost setting on new X server
         --no-auth)    Xauthentication="no" ;;             # disable cookie authentication
      -o|--no-xhost)   Noxhost="yes"  ;;                   # disable any access granted by xhost
         --trusted)    Forcetrusted="yes"  ;;              # force trusted cookies for --hostdisplay
      -t|--untrusted)  Trusted="no"  ;;                    # create untrusted cookies


       ## host folders
         --homedir)    Benutzerhosthomefolder="${2:-}" ; Benutzerhosthome="yes" ; shift ;; # set host folder to share as home folder instead of ~/x11docker/NAME
         --homebasedir)  Homebasefolder="${2:-}" ; shift ;;
         --cachebasedir) Cachebasefolder="${2:-}" ; shift ;; # set cache folder instead of default $Cachebasefolder
         --cachedir)     Cachebasefolder="${2:-}" ; shift 
                         note "Option --cachedir is deprecated.
  Please use instead: --cachebasedir" ;;
         --sharedir)   [ -z "$Winsubsystem" ] && [ ! -e "${2:-}" ] && warning "Option --sharedir: file or folder not found:
  ${2:-}"             || {
                         # share host folder at same location in container with rw access
                         Sharevolumescount=$(($Sharevolumescount + 1))
                         Sharevolumes[$Sharevolumescount]="${2:-}"
                       }
                       shift ;;

       ## docker options
         --hostipc)    Sharehostipc="yes" ;;               # docker run option --ipc=host
         --hostnet)    Sharehostnet="yes" ;;               # docker run option --net=host
         --cap-default) Capdropall="no" ;;                 # don't use --cap-drop=ALL
         --name)    Containername="${2:-}" ; shift ;;      # set container name

       ## miscellaneous
         --ps)         Preservecachefiles="yes"  ;;        # preserve container instead of removing it with 'docker run --rm'
         --westonini)  Customwestonini="${2:-}" ; shift ;; # custom weston.ini

     #### special options not starting X or docker
      --starter)       Createdesktopstarter="yes" ;;       # create desktop starter and exit
      --cleanup)       Checkorphaned="yes"  ;;             # check for orphaned containers and files owned by root, created by docker)
      --install|--update|--update-master|--remove) Installermode="${1:-}" ;;   # installer
      --wmlist)        echo $Wm_all ; exit 0 ;;            # special option for x11docker-gui to retrieve list of window managers

     ##### custom docker options / image name + image command
      --) shift
        [ "$(cut -c1 <<< "${1:-}")"  = "-" ] && grep -q " -- "  <<< "$*" && {
          Customdockeroptions="$(sed 's/ -- .*//' <<< "$*" )"
          Imagecommand="$(sh -c 'echo "${0#* -- }"' "$*" )"
          Imagename="$(cut -d ' ' -f1 <<< "$Imagecommand")"
          Imagecommand="$(cut -d ' ' -f2- -s <<< "$Imagecommand")"
          break
        }
        while [ $# -gt 0 ] ; do
          [ -n "${1:-}" ] && [ -z "$Imagename" ] && [ "$(echo "${1:-}" | cut -c1)"  = "-" ]  && Customdockeroptions="$Customdockeroptions ${1:-}"
          [ -n "${1:-}" ] && [ -z "$Imagename" ] && [ "$(echo "${1:-}" | cut -c1)" != "-" ]  && Imagename="${1:-}" && shift
          [ -n "${1:-}" ] && [ -n "$Imagename" ] && Imagecommand="$Imagecommand${1:-} "
          shift
        done
        [ -z "$Imagename" ] && X11dockermode="xonly"
      ;;
      '') ;;
      *) error "Unknown option ${1:-}
  Parsed options:
  $Parsedoptions" ;;
    esac
    shift
  done
}

{ #### part: check host user
  # check host user, want an unprivileged one to run X server
  # default behaviour:
  #  x11docker started as unprivileged user:          starting X server as this user and create same user in container
  #  x11docker started as root:                       determine real user with $(logname), instead of root use real user like above
  #  x11docker started as root with --hostuser=root:  root runs X server and root is container user (discouraged)
  #                                                   if you want root in container, just use --user=root
  #  x11docker with --user=someuser                   container user is someuser, host user is unprivileged user $(logname)
  #
  # root permissions are only needed to run docker. If started unprivileged, a password prompt appears.

  # not root? Use current user.
  [ -z "$Hostuser" ] && [ "$Startuser" != "root" ] && Hostuser="$Startuser"

  # root? find unprivileged user
  Lognameuser="$(logname 2>/dev/null)"
  [ -z "$Lognameuser" ] && [ -z "$Hostuser" ] && note "Your terminal seems to be not POSIX compliant.
  Command 'logname' does not return a value.
  Consider to use another terminal emulator.
  Fallback: Will try to check \$SUDO_USER and \$PKEXEC_UID."
  [ -z "$Lognameuser" ] && [ -n "${SUDO_USER:-}" ]  && Lognameuser="${SUDO_USER:-}"  && [ -z "$Hostuser" ] && note "Will use \$SUDO_USER = ${SUDO_USER:-} as host user."
  [ -z "$Lognameuser" ] && [ -n "${PKEXEC_UID:-}" ] && Lognameuser="${PKEXEC_UID:-}" && [ -z "$Hostuser" ] && note "Will use user with uid \$PKEXEC_UID = ${PKEXEC_UID:-} as host user."
  [ -z "$Lognameuser" ] &&                             Lognameuser="$Startuser"      && [ -z "$Hostuser" ] && note "Will use \$(id -un) = $Lognameuser as host user."

  # option --hostuser
  [ -z "$Hostuser" ] && Hostuser=$Lognameuser
  [ "$Hostuser" != "$Lognameuser" ] && {
    [ "$Startuser" = "root" ] || error "x11docker must run as root to choose a host user
  different from user '$Lognameuser'. (option --hostuser)"
  }
  getent passwd $Hostuser >/dev/null 2>&1 || {
    [ -e /etc/passwd ] || warning "Your system misses /etc/passwd"
    warning "Could not find user '$Hostuser' in /etc/passwd."
  }
  Hostuser=$(id -un $Hostuser)
  Hostuseruid=$(id -u $Hostuser)
  Hostusergid=$(id -g $Hostuser)
  Hostuserhome=$(getent passwd $Hostuser 2>/dev/null | cut -d: -f6)
  [ -z "$Hostuserhome" ] && {
    warning "Could not read your home directory from /etc/passwd.
  Will try HOME=${HOME:-<not found>} instead."
    Hostuserhome=${HOME:-}
  }
  [ -z "$Hostuserhome" ] && {
    warning "Please set \$HOME with a valid path.
  Fallback: setting HOME=/tmp"
    Hostuserhome="/tmp"
  }

  # Mksu: prefix to run command as unprivileged host user
  [ "$Hostuser" = "$Startuser" ] && Mksu="bash -c" || Mksu="su $Hostuser -c"  # differenciated as only root can use su on itself and others without password

  [ "$Hostuser" = "root" ] && warning "Running as user root.
  Maybe \$(logname) did not provide an unprivileged user.
  Please use option --hostuser=USER to specify an unprivileged user.
  Otherwise, new X server runs as root, and container user will be root."

  [ -z "$Hostuserhome" ] && error "No home directory found for user '$Hostuser'.
  You need to specify option --cachedir.
  (Also specify --homedir if you want to use option --home)."
  
  # Need host GIDs to use in container
  Hostgidaudio=$(getent group audio | cut -d: -f3)
  Hostgidvideo=$(getent group video | cut -d: -f3)
}

{ #### part: some init

  # base cache folder
  [ "$Cachebasefolder" ] || {
    case $Winsubsystem in
      "") Cachebasefolder="$Hostuserhome/.cache/x11docker" ;;
      *)  Cachebasefolder="$Winsubmount$(convertpath "$(cmd.exe /C "echo %userprofile%")" | rmcr | cut -d"'" -f2)/x11docker/cache" ;;
    esac
  }
  $Mksu "mkdir -p $Cachebasefolder"         || error "Could not create cache folder
  $Cachebasefolder"
  writeaccess $Hostuseruid $Cachebasefolder || error "User $Hostuser does not have write access to
  cache folder $Cachebasefolder"  # can happen with --cachedir

  # Logfiles. $Logfile will be moved to $Sharefolder later
  Mycookie=$(mcookie | cut -b1-6)
  [ -z "$Mycookie" ] && Mycookie=$RANDOM
  Logfile="$Cachebasefolder/x11docker.log.$Mycookie"
  mkfile "$Logfile"
  Logbackup="$Cachebasefolder/x11docker.log"       # afterward copy of $Logfile in $Cachebasefolder

  grep -q beta <<<$Version && note "You are running a beta version of x11docker.
  Beta versions change often and may introduce temporary new bugs.
  If you prefer latest stable release, run 'x11docker --update'.
  If you prefer to follow development, run 'x11docker --update-master'.

  You can contribute to x11docker if you find bugs and report them at:
    https://github.com/mviereck/x11docker"

  verbose -d "x11docker version $Version
docker version: $($Dockerexe --version 2>&1)
Host system:    $(source /etc/os-release 2>/dev/null; echo "$PRETTY_NAME")
Command:        $0 $X11dockerargs
Parsed options: $Parsedoptions"
  Wisdom="$(fortune -s 2>/dev/null || echo "Install fortunes to find wisdom.")"
  verbose "
$(cowsay "$Wisdom" 2>/dev/null || echo "Wanda the fish says: $Wisdom")"

  [ "$Debugmode" = "yes" ] && {
    #PS4="$DebugPS4"    # useful output for set -x
    #set -x             # show every executed line
    set -Eu -o pipefail
    trap 'traperror $? $LINENO $BASH_LINENO "$BASH_COMMAND" $(printf "::%s" ${FUNCNAME[@]})'  ERR
  }

  # Check ssh and tty
  pstree -ps $$ 2>/dev/null | grep -q sshd && Ssh="yes" || Ssh="no"  # check if running over SSH            ### FIXME pstree is not available everywhere
  command -v pstree >/dev/null || {
    [ "${SSH_CLIENT:-}" ] && Ssh="yes" || note "Could not check whether x11docker is running over ssh.
  Please install pstree."
  }
  tty | grep -q tty     && Tty="yes" || Tty="no"  # check if running on X or on tty
  [ "$Winsubsystem"   ] && Tty="no"
  XDG_VTNR=${XDG_VTNR:-}

  [ "$Cachebasefolder" != "$(echo $Cachebasefolder | sed -e 's/ *//g')" ] && error "Cache root folder must not contain whitespaces.
  $Cachebasefolder"

  # options --install --update --remove
  [ -n "$Installermode" ] && {
    [ "$Startuser" = "root" ] || error "Must run as root to install, update or remove x11docker."
    installer $Installermode
    exit
  }

  # option --cleanup: check for non-removed containers and left cache files
  [ "$Checkorphaned" = "yes" ] && {
    cleanup
    exit
  }

  # Weston and Xwayland need XDG_RUNTIME_DIR
  [ -z "${XDG_RUNTIME_DIR:-}" ] && [ -e "/run/user/$Hostuseruid" ] && export XDG_RUNTIME_DIR="/run/user/$Hostuseruid"
  [ -z "${XDG_RUNTIME_DIR:-}" ] && {
    export XDG_RUNTIME_DIR=/tmp/XDG_RUNTIME_DIR.x11docker.$Hostuseruid
    $Mksu "mkdir -p $XDG_RUNTIME_DIR"
    $Mksu "chmod 700 $XDG_RUNTIME_DIR"
  }

  # --westonini
  [ -n "$Customwestonini" ] && [ ! -e "$Customwestonini" ] && {
    warning "Custom weston.ini (option --westonini) not found.
  $Customwestonini"
    Customwestonini=""
  }

  # validate $WAYLAND_DISPLAY
  [ -n "$Hostwaylandsocket" ] && [ ! -S "$XDG_RUNTIME_DIR/$Hostwaylandsocket" ] && {
    warning "WAYLAND_DISPLAY $Hostwaylandsocket is set, but does not exist
  or is not a socket.
  $XDG_RUNTIME_DIR/$Hostwaylandsocket"
    Hostwaylandsocket=""
  }
  
  # host IP needed for --pulseaudio over tcp, --vcxsrv and --xwin
  case $Winsubsystem in
    "") Hostip="$(ip -4 -o a | awk '{print $4}' | cut -d/ -f1 | grep -v 127.0.0.1 | head -n1)" ;;
    *)  Hostip="$(ipconfig.exe | grep 'IPv4' | grep -o '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*' | grep "^10\.0\.*" )" ;;
  esac
  verbose -d "Host IP: $Hostip"
  
  # provide dos->unix conversion to $Mksu commands
  export -f rmcr
}

{ #### part: check run/--exe/--xonly
  [ -z "$Imagename" ] && X11dockermode="xonly"
  case $X11dockermode in
    run)
      command -v $Dockerexe >/dev/null || error "docker is not installed.
  To run docker images, you need to install docker."
      verbose "Image name: $Imagename"
      verbose "Image command: $Imagecommand"
      Imagecommandbasename=$(basename $(echo $Imagecommand | cut -d' ' -f1) 2>/dev/null | tr -cd '[:alpha:][:digit:][:blank:]-_.')
    ;;
    exe)
      Hostexe="$Imagename $Imagecommand"
      Hostexebasename=$(basename $(echo $Hostexe | cut -d' ' -f1) | tr -cd '[:alpha:][:digit:][:blank:]-_.')
      Imagename=""
      Imagecommand=""
      command -v $Hostexe >/dev/null || error "Command '$Hostexe' not found."
      verbose "Host application to execute: $Hostexe"
    ;;
    xonly)
      Showdisplayenvironment="yes"
      Hostexe="sleep infinity"
      Imagename=""
      Imagecommand=""
      Hostexebasename=""
      X11dockermode="exe"
    ;;
  esac
}

{ #### part: check X server dependencies, auto-choose X server

  ## default option '--auto': Try to automatically choose best matching and available X server
  [ "$Autochooseserver" = "yes" ] && {                              Xserver="--xpra"
    [ "$Sharegpu" = "yes" ]                                      && Xserver="--xpra-xwayland"
    [ "$Xfishtank" = "yes" ]                                     && Xserver="--xephyr"
    [ "$Desktopmode" = "yes"  ]                                  && Xserver="--xephyr"
    [ -z "$Imagename$Hostexebasename" ]                          && { Xserver="--xephyr" ; Desktopmode="yes" ; }
    [ "$Xserver" = "--xephyr" ] && { depends --xephyr            || Xserver="--weston-xwayland" ; }
    [ "$Sharegpu" = "yes" ]     && [ "$Xserver" = "--xephyr" ]   && Xserver="--weston-xwayland"
    [ "$Outputcount" != "1" ]                                    && Xserver="--weston-xwayland"
    [ -n "$Rotation" ]                                           && Xserver="--weston-xwayland"
    [ "$Scaling" ]              && [ "$Sharegpu" = "yes" ]       && Xserver="--xpra-xwayland"
    [ "$Scaling" ]              && [ "$Sharegpu" = "no" ]        && Xserver="--xpra"
    [ "$Tty" = "yes" ]                                           && Xserver="--weston-xwayland"
    [ "$Scaling" ]              && [ "$Tty" = "yes" ]            && Xserver="--xorg"
    [ "$Screensize" ]           && [ "$Tty" = "yes" ]            && Xserver="--xorg"
    [ -z "$Hostdisplay" ]       && [ -n "$Hostwaylandsocket" ]   && Xserver="--weston-xwayland"
    [ "$Sharewayland" = "yes" ] && { [ -n "$Hostwaylandsocket" ] && [ "$Desktopmode" = "no" ] && Xserver="--hostwayland" || Xserver="--weston" ; }
    [ "$Winsubsystem" ]                                          && Xserver="--vcxsrv"
    [ "$Winsubsystem" = "CYGWIN" ]                               && Xserver="--xwin"
#    nxagent is disabled as favorized X server due to nxagent issues with X extension Composite.
#    { [ "$Xserver" = "--xpra" ] || [ "$Xserver" = "--xephyr" ];} && Xserver="--nxagent"
  }

  [ "$Sharegpu" = "yes" ] && case $Xserver in
    --xpra)
      note "Option --xpra does not support GPU access.
  Fallback: Will try to use option --xpra-xwayland."
      Xserver="--xpra-xwayland"
    ;;
    --xephyr)
      note "Option --xephyr does not support GPU access.
  Fallback: Will try to use option --weston-xwayland."
      Xserver="--weston-xwayland"
    ;;
    --nxagent)
      case "$Desktopmode" in
        yes)
          note "Option --nxagent does not support GPU access.
  Fallback: Will try to use option --weston-xwayland."
          Xserver="--weston-xwayland"
        ;;
        no)
          note "Option --nxagent does not support GPU access.
  Fallback: Will try to use option --xpra-xwayland."
          Xserver="--xpra-xwayland"
        ;;
      esac
    ;;
    --xdummy|--xvfb)
      note "Using special setup with Weston, Xwayland and xdotool
  instead of Xdummy or Xvfb to allow GPU access."
      Xserver="--xdummy-xwayland"
    ;;
  esac

  [ "$Tty" = "no" ] && [ "$Ssh" = "no" ] && [ -z "$Hostdisplay$Hostwaylandsocket" ] && [ "$Xserver" != "--nothing" ] && [ -z "$Winsubsystem" ] && {
    warning "Environment variables DISPLAY and WAYLAND_DISPLAY are empty,
  but it seems x11docker was started within X, not from console.
  Please set DISPLAY and XAUTHORITY.
  If you have started x11docker with su or sudo, su/sudo may be configured to
  unset X environment variables. It may work if you run x11docker with
    sudo -E x11docker [...]
  If your system does not support 'sudo -E', you can try
    sudo env DISPLAY=\$DISPLAY XAUTHORITY=\$XAUTHORITY x11docker [...]
  Otherwise, you can use tools like gksu/gksudo/kdesu/kdesudo/lxsu/lxsudo."

    [ -n "${PKEXEC_UID:-}" ] && note "It seems you have started x11docker with pkexec.
  Can not determine DISPLAY and XAUTHORITY, can not use your X server.
  To allow other X server options, please provide environment variables with
    pkexec env DISPLAY=\$DISPLAY XAUTHORITY=\$XAUTHORITY x11docker [ARGS]."

    Xserver="--xorg"
  }

  [ "$Ssh" = "yes" ] && [ -z "$Hostdisplay$Hostwaylandsocket" ] && [ "$Xserver" != "--nothing" ] && [ "$Autochooseserver" = "yes" ] && {
    error "You are running x11docker over SSH without providing a display.
  Please run with 'ssh -X' or 'ssh -Y'.
  (If you insist, you can run with option '--xorg', but won't see the result.)"
  }
  
  ## check if dependencies for chosen X server are installed, fall back to best alternatives if not
  [ "$Xserver" = "--xephyr" ]          && { depends --xephyr          || Xserver="--nxagent" ; }
  [ "$Xserver" = "--xvfb" ]            && { depends --xvfb            || Xserver="--xdummy"  ; }
  [ "$Xserver" = "--hostwayland" ]     && { depends --hostwayland     || Xserver="--weston"  ; }
  [ "$Xserver" = "--nxagent" ]         && { depends --nxagent         || { [ "$Desktopmode" = "yes" ] && Xserver="--xephyr"        || Xserver="--xpra" ; } ; }
  [ "$Xserver" = "--xpra" ]            && { depends --xpra            || { depends --nxagent          && Xserver="--nxagent"       || Xserver="--xephyr" ; } ; }
  [ "$Xserver" = "--xorg" ]            && { depends --xorg            || Xserver="--weston-xwayland" ; }
  [ "$Xserver" = "--xpra-xwayland" ]   && { depends --xpra            || Xserver="--weston-xwayland" ; }
  [ "$Xserver" = "--xwayland" ]        && { depends --xwayland        || Xserver="--weston-xwayland" ; }
  [ "$Xserver" = "--xpra-xwayland" ]   && { depends --xpra-xwayland   || { [ "$Desktopmode" = "yes" ] && Xserver="--kwin-xwayland" || Xserver="--hostdisplay" ; } ; }
  [ "$Xserver" = "--kwin-xwayland" ]   && { depends --kwin-xwayland   || Xserver="--weston-xwayland" ; }
  [ "$Xserver" = "--kwin" ]            && { depends --kwin            || Xserver="--weston" ; }
  [ "$Xserver" = "--weston-xwayland" ] && { depends --weston-xwayland || Xserver="--kwin-xwayland" ; }
  [ "$Xserver" = "--weston" ]          && { depends --weston          || Xserver="--kwin" ; }
  [ "$Xserver" = "--xdummy-xwayland" ] && { depends --xdummy-xwayland || Xserver="--kwin-xwayland" ; }
  [ "$Xserver" = "--xwin" ]            && { depends --xwin            || Xserver="--vcxsrv" ; }
  [ "$Xserver" = "--vcxsrv" ]          && { depends --vcxsrv          || Xserver="--hostdisplay" ; }

  [ "$Sharewayland" = "yes" ]          && { depends $Xserver || error "Failed to set up a Wayland environment.
  Please install 'weston' or 'kwin_wayland'." ; }

   # Xephyr as fallback for all options. Last fallback: Xorg
  depends $Xserver || Xserver="--xephyr"
  [ "$Xserver" = "--xephyr" ]         && {  depends --xephyr || {
                                              depends --kwin-xwayland   && Xserver="--kwin-xwayland"
                                              depends --hostdisplay     && [ "$Desktopmode" = "no" ] && Xserver="--hostdisplay"
                                              depends --vcxsrv          && Xserver="--vcxsrv"
                                              depends --xwin            && Xserver="--xwin"
                                              depends --nxagent         && Xserver="--nxagent"
                                              depends --weston-xwayland && Xserver="--weston-xwayland"
                                              depends --xpra            && Xserver="--xpra"
                                            }
    [ "$Sharegpu" = "yes" ] && case $Desktopmode in
      yes)                                  depends --weston-xwayland && Xserver="--weston-xwayland" ;;
      no)                                   depends --hostdisplay     && Xserver="--hostdisplay" ;;
    esac
    depends $Xserver || Xserver="--xorg"
  }

  depends $Xserver || {
    case $Winsubsystem in
      "")        error "Did not find a possibility to provide a display.
  Recommendations:
    To run within an already running X server, install one or all of:
      Xephyr xpra nxagent
    To run with GPU acceleration, install:
      weston and Xwayland, optionally also: xpra and xdotool
    To run from TTY or within Wayland, install:
      weston and Xwayland" ;;
      CYGWIN)    error "Did not find a possibility to provide a display.
  Please install Xwin (xinit package) in Cygwin,
  or VcXsrv on Windows host." ;;
      MSYS2|WSL) error "Did not find a possibility to provide a display.
  Please install X server VcXsrv on Windows host." ;;
    esac
  }

  [ "$Autochooseserver" = "yes" ] && note "Using X server option $Xserver" || verbose -d  "Using X server option $Xserver"
}

{ #### part: check multiple option interferences, change settings if needed

  # check if --xorg can run
  case $Xserver in
    --xorg)
      [ "$Autochooseserver" = "yes" ] && [ "$Hostexebasename" = "xonly" ] && error "Will not run an empty Xorg in auto-choosing mode.
  If you want this, please use option --xorg explicitly."

      [ -e "/etc/X11/Xwrapper.config" ] && sed 's/ //g' /etc/X11/Xwrapper.config | grep -xq "allowed_users=anybody" && sed 's/ //g' /etc/X11/Xwrapper.config | grep -xq "needs_root_rights=yes" && {
        Xlegacywrapper="yes"
      } || {
        Xlegacywrapper="no"
        [ "$Startuser" != "root" ] && [ "$Tty" = "no" ] && warning "Your configuration seems not to allow to start
  a second core Xorg server from within X. Option --xorg will probably fail.
  (Per default, only root or console users are allowed to run an Xorg server).

  Possible solutions:
  1.) Install one of nested X servers 'Xephyr', 'Xnest' or 'nxagent'.
      For --gpu support: install 'weston' and 'Xwayland'.
  2.) Switch to console tty1...tty6 with <CTRL><ALT><F1>...<F6>
      and start x11docker there.
  3.) Run x11docker as root.
  4.) Edit file '/etc/X11/Xwrapper.config' and replace line:
          allowed_users=console
      with lines
          allowed_users=anybody
          needs_root_rights=yes
      If the file does not exist already, you can create it.
      On Ubuntu 16.04 and debian 9 you need package xserver-xorg-legacy."
      }
    ;;
  esac
  
  # add VcXsrv folder to PATH to get vcxsrv.exe, xhost.exe and xauth.exe available
  [ "$Xserver" = "--vcxsrv" ] && export PATH="$PATH:$Vcxsrvpath"

  # check if a host window manager is needed
  [ "$Desktopmode" = "no" ] && [ -z "$Windowmanager" ] && case $Xserver in
    --xephyr|--weston-xwayland|--kwin-xwayland|--xorg|--xwayland)
      Windowmanager="auto"
      [ "$Autochooseserver" = "yes" ] && [ "$Tty" = "no" ] && {
        case $Sharegpu in
          no)  note "Did not find a nice solution to run a seamless application
  on your desktop. (Only insecure option --hostdisplay would work).
  It is recommended to install xpra or nxagent." ;;
          yes) note "Did not find a nice solution to run a seamless application with
  option --gpu on your desktop. (Only insecure option --hostdisplay would work).
  It is recommended to install xpra, weston, Xwayland and xdotool." ;;
        esac
      }
    ;;
  esac

  # check xauth
  [ "$Xauthentication" = "yes" ] && {
    command -v xauth.exe >/dev/null && Xauth="xauth.exe"
    command -v xauth     >/dev/null && Xauth="xauth"
    command -v $Xauth    >/dev/null || {
      warning "Command 'xauth' not found.
  Please install 'xauth' to allow X cookie authentication.
  Fallback: Disabling X authentication protocol. (option --no-auth)"
      Xauthentication="no"
    }
    command -v $Xauth | grep -q VcXsrv && {
      Vcxsrvversion="$(vcxsrv.exe -version 2>&1 | rmcr | grep Release | cut -d' ' -f2)"
      verlt "$Vcxsrvversion" "1.20.0.1" && {
        warning "Please update X server VcXsrv to at least version 1.20.0.1.
  Your currently installed version $Vcxsrvversion provides a buggy xauth.exe.
  Can not create a cookie for secure X connections.
  Fallback: Disabling X authentication protocol. (option --no-auth)"
        Xauthentication="no"
      }
    }
  }
  
  # --fullscreen is nonsense on tty at all. Avoids weston error on tty.
  [ "$Tty" = "yes" ] && Fullscreen="no"
          
  # --gpu
  [ "$Sharegpu" = "yes" ] && {
    case $Xserver in
      --xpra|--xdummy|--nxagent|--xephyr)
        note "Option $Xserver does not support hardware acceleration.
  Fallback: using software rendering, disabling option --gpu"
        Sharegpu="no"
      ;;
    esac
  }

  # trusted or untrusted cookies. untrusted cookies are default for --hostdisplay
  [ "$Sharegpu" = "yes" ]          && Forcetrusted="yes"
  [ "$Xserver" = "--hostdisplay" ] && Trusted="no"
  [ "$Forcetrusted" = "yes" ]      && Trusted="yes"

  # --hostdisplay --gpu
  [ "$Xserver" = "--hostdisplay" ] && [ "$Sharehostipc" = "no" ] && [ "$Sharegpu" = "yes" ] && {
    note "To allow GPU acceleration (option --gpu) with --hostdisplay,
  x11docker will share host resources with insecure option --hostipc
  and allow trusted cookies with option --trusted."
    Sharehostipc="yes"
    Trusted="yes"
  }

  # --hostdisplay with untrusted cookies: check xdpyinfo
  [ "$Xserver" = "--hostdisplay" ] && [ "$Trusted" = "no" ] && {
    command -v xdpyinfo >/dev/null && {
      xdpyinfo | grep -q SECURITY || {
        note "Your X server does not support untrusted cookies.
  Have to use trusted cookies and to enable insecure option --hostipc.
  Consider to use options --xpra or --nxagent instead of --hostdisplay."
        Trusted="yes"
        Sharehostipc="yes"
      }
    } || note "Command 'xdpyinfo' not found. Need it to check
  whether Xorg supports untrusted cookies for --hostdisplay.
  Please install 'xdpyinfo'."
  }

  # --clipboard
  [ "$Shareclipboard" = "yes" ] && {
    case $Xserver in
      --weston|--kwin) note "Sharing clipboard with $Xserver is not supported" ;;
      --hostwayland) note "Sharing clipboard may or may not work.
  Cannot enable or disable it, it depends on your Wayland compositor." ;;
      --hostdisplay)
        warning "To allow clipboard sharing with option --hostdisplay,
  trusted cookies and insecure option --hostipc will be enabled.
  No protection against X security leaks is left!
  Please consider to use another X server option."
        Trusted="yes"
        Sharehostipc="yes"
      ;;
    esac
    case $Xserver in
      --xpra|--xpra-xwayland|--hostdisplay|--kwin|--weston|--nothing|--vcxsrv|--xwin) ;;
      *) note "Sharing picture clips with option --clipboard
  is only possible with options --xpra, --xpra-xwayland and --hostdisplay." ;;
    esac
  }

  # --hostdisplay with SSH
  [ "$Xserver" = "--hostdisplay" ] && [ "$Ssh" = "yes" ] && {
    [ "$Sharehostipc" = "no" ] || [ "$Trusted" = "no" ] || [ "$Sharehostnet" = "no" ]  && {
      warning "For SSH connection with option --hostdisplay
  x11docker must enable options --hostipc, --hostnet and --trusted.
  It is recommended to use other X server options
  like --xpra, --xephyr or --nxagent."
      Sharehostipc="yes"
      Sharehostnet="yes"
      Trusted="yes"
    }
  }

  # --hostnet --no-internet
  [ "$Sharehostnet" = "yes" ] && [ "$Internetaccess" = "no" ] && {
    note "You have chosen --hostnet and --no-internet. That does not work.
  You can not share host network stack (--hostnet) and forbid internet access
  at the same time (except you disconnect your host from internet).
  Fallback: disabling option --hostnet, keeping --no-internet."
    Sharehostnet="no"
  }

  # --scale
  [ "$Scaling" ] && {
    case $Xserver in
      --weston|--weston-xwayland)
        [[ $Scaling =~ ^[1-9]$ ]] || {
          note "The scale factor for option $Xserver must be
  one of   1  2  3  4  5  6  7  8  9
  Fallback: disabling option --scale"
          Scaling=""
        }
      ;;
      --xpra|--xpra-xwayland|--xorg)
        isnum $Scaling || {
          note "Option --scale needs a number. '$Scaling' is not allowed.
  Fallback: disabling option --scale"
          Scaling=""
        }
      ;;
      *)
        note "Option $Xserver does not support option --scale.
  Available for --xpra, --xpra-xwayland and --xorg (float values possible)
  and for --weston and --weston-xwayland (full integer values only).
  Fallback: disabling option --scale"
        Scaling=""
      ;;
    esac
    case $Xserver in
      --xpra|--xpra-xwayland)
        verlt "$Xpraversion" "xpra v0.16" && {
          note "Your xpra version is quite old and does not support --scale.
  You need at least xpra version 0.16
  Fallback: disabling option --scale"
          Scaling=""
        }
      ;;
    esac
    case $Xserver in
      --weston-xwayland) note "Weston does not work well with Xwayland in scaled mode.
  In summary, Xwayland does not get the right screen resolution from Weston.
  (Bug report at https://bugzilla.redhat.com/show_bug.cgi?id=1498669 ).
  Try out if it works for you. Otherwise, you can combine
  '--xpra-xwayland --desktop --scale $Scaling' for better desktop scaling support.
  --scale for single applications works best with --xpra / --xpra-xwayland.
  --scale in desktop mode works best with option --xorg."
      ;;
      --xpra-xwayland)
        [ "1" = "$(awk -v a="${Scaling:-1}" 'BEGIN {print (a < 1)}')" ] && {
          command -v weston >/dev/null || {
            note "Option --xpra-xwayland needs weston
  for scale factor smaller than 1.
  Fallback: disabling option --scale"
            Scaling=""
          }
        }
      ;;
      --xorg)
        [ "1" = "$(awk -v a="$Scaling" 'BEGIN {print (a < 1)}')" ] && [ -n "$Rotation" ] && note "--xorg does not work well with combination
  of --scale smaller than 1 and rotation diferent from 0."
      ;;
    esac
  }

  # --rotate
  [ -n "$Rotation" ] && {
    case $Xserver in
      --weston|--weston-xwayland|--xorg)
        echo "0 90 180 270 flipped flipped-90 flipped-180 flipped-270" | grep -q "$Rotation" || {  # fuzzy test, have been lazy
          note "Unsupported value '$Rotation' for option --rotate.
  Must be one of 0 90 180 270 flipped flipped-90 flipped-180 flipped-270
  Fallback: disabling option --rotate"
          Rotation=""
        }
      ;;
      *)
        note "Option $Xserver does not support option --rotate.
  Rotation is possible for --xorg, --weston and --weston-xwayland.
  Fallback: disabling option --rotate"
        Rotation=""
      ;;
    esac
  }
  [ "$Rotation" = "0" ] && Rotation="normal"

  # xrandr: --scale --size --rotate
  command -v xrandr >/dev/null || case $Xserver in
    --xorg) { [ "$Scaling" ] || [ -n "$Rotation" ] || [ -n "$Screensize" ] ; } && note "Option --xorg needs 'xrandr' to support
  options --size, --scale and --rotate.
  Please install 'xrandr'."
    ;;
  esac

  # --dpi
  [ -n "$Dpi" ] && case $Xserver in
    --weston|--kwin|--hostwayland|--hostdisplay)
      note "Option --dpi has no effect with option $Xserver"
      Dpi=
    ;;
  esac

  # --output-count
  [ "$Outputcount" != "1" ] && {
    case $Xserver in
      --xephyr|--weston|--kwin|--weston-xwayland|--kwin-xwayland|--vcxsrv|--xwin)
        [[ "$Outputcount" =~ ^[1-9]$ ]] || {
          note "Option --output-count: Value must be one of 1 2 3 4 5 6 7 8 9
  Disabling invalid value $Outputcount"
          Outputcount="1"
        }
        [ "$Tty" = "yes" ] && {
          note "Option --outputcount only works in nested/windowed mode,
  but not on tty. Fallback: disabling --outputcount"
          Outputcount="1"
        }
      ;;
      *) note "$Xserver does not support option --output-count.
  Only available for Weston, KWin and Xephyr, thus for options
  --weston, --weston-xwayland, --kwin, --kwin-xwayland, --xephyr."
        Outputcount="1"
      ;;
    esac
  }

  # --xfishtank: fish tank
  [ "$Xfishtank" = "yes" ] && {
    command -v xfishtank >/dev/null || {
      note "xfishtank not found. Can not show a fish tank.
  Please install 'xfishtank' for option --xfishtank to show a fish tank."
      Xfishtank="no"
    }
    case $Xserver in
      --xpra|--xpra-xwayland|--nxagent)
        [ "$Desktopmode" = "no" ] && [ -z "$Windowmanager" ] && Windowmanager="auto" && Desktopmode="yes" ;;
      --weston|--kwin|--hostwayland|--hostdisplay|--nothing)
        note "Option --xfishtank is not supported for $Xserver."
        Xfishtank="no"
      ;;
    esac
  }
  
  # MSYS2, Cygwin, WSL
  [ "$Winsubsystem" ] && {
    grep -q "/c/" <<< "$Cachebasefolder" && [ -z "$Homebasefolder" ] && note "Per default x11docker stores its cache files on drive C:.
  docker setup may not allow to share files from drive C:.
  If startup fails with an 'access denied' error,
  please either allow access to drive C: or specify a custom folder for cache
  storage with option '--cachebasedir D:/some/cache/folder'.
  Same issue can occur with option '--home'. 
  Use option '--homebasedir D:/some/home/folder' in that case."
    [ "$Initsystem" = "systemd" ] && {
      note "Option --systemd is not possible on MSYS2/Cygwin/WSL.
  systemd needs a running linux kernel with cgroup support.
  Fallback: Disabling option --systemd, enabling option --dbus-system"
      Initsystem="tini"
      Dbusdaemon="yes"
    } 
    [ "$Sharecgroup" = "yes" ] && { 
      note "Option --sharecgroup is not possible on MSYS2/Cygwin/WSL.
  Fallback: Disabling option --sharecgroup."
      Sharecgroup="no"
    }
  }
}

{ #### part: some messages depending on options, but not changing settings

  # X server specific messages
  case $Xserver in
    --hostdisplay)
      [ "$Autochooseserver" = "yes" ] && note "To allow protection against X security leaks,
  please install one or more of:
    xpra, Xephyr, nxagent, weston+Xwayland, kwin_wayland+Xwayland or Xnest,
  or run a second Xorg server with option --xorg."
      [ "$Trusted" = "no" ] && {
        warning "Option --hostdisplay provides only low container isolation!
  It is recommended to use another X server option like --xpra or --nxagent.

  To improve security with --hostdisplay x11docker uses untrusted cookies.
  This can lead to strange behaviour of some applications.

  If you encounter application ${Colredbg}errors${Colnorm}, enable option --clipboard
  that disables security restrictions for --hostdisplay as a side effect."
      } || {
        warning "Option --hostdisplay with trusted cookies provides
      QUITE BAD CONTAINER ISOLATION !
  Keylogging and controlling host applications is possible!"
        [ "$Sharehostipc" = "no" ] && warning "Using --hostdisplay with --trusted but without
  insecure option --hostipc can lead to graphical issues and RAM access errors."
      }
      [ "$Desktopmode" = "yes" ] && note "Can not avoid to use host window manager
  along with option --hostdisplay.
  You may get strange interferences with your host desktop.
  Can be interesting though, having two overlapping desktops."
    ;;

    --xorg)
      [ "$Hostsystem" = "opensuse" ] && [ "$Tty" = "no" ] && [ "$Startuser" != "root" ] && warning "openSUSE does not support starting a second Xorg server
  from within X. Possible solutions:
  1.) Install nested X server 'Xephyr', 'nxagent' or 'Xnest',
      or for --gpu support: install 'Weston' and 'Xwayland'.
  2.) Switch to console tty1...tty6 with <CTRL><ALT><F1>...<F6>
      and start x11docker there.
  3.) Run x11docker as root."

      [ "$Autochooseserver" = "yes" ] && [ -n "$Hostdisplay" ] && note "Could not find Xephyr, Xnest, nxagent,
  xpra, weston+Xwayland or kwin_wayland+Xwayland to run a nested X server.
  Consider to install one of them."

      case $Xlegacywrapper in
        yes) warning "Although x11docker starts Xorg as unprivileged user,
  most system setups wrap Xorg to give it root permissions (setuid).
  Evil containers may try to abuse this.
  Other x11docker X server options like --xephyr are more secure at this point." ;;
        no) [ "$Startuser" = "root" ] && warning "x11docker will run Xorg as root." ;;
      esac

      [ "$Ssh" = "yes" ] && warning "x11docker can run Xorg on another tty (option --xorg),
  but you won't see it in your SSH session.
  Rather install e.g. Xephyr on ssh server and use option --xephyr."
    ;;

    --xpra|--xpra-xwayland)
      verlt "$Xpraversion" "xpra v1.0" && {
        note "Your xpra version '$Xpraversion' is out of date. It is
  recommended to install at least xpra v1.0."
        [ "$Desktopmode" = "yes" ] && {
          note "Your xpra version does not support desktop mode.
  Please use another X server option like --xephyr or --nxagent."
        } ||:
      }
      [ "$Desktopmode" = "yes" ] && verlt "$Xpraversion" "xpra v2.2-r17117" && note "Xpra desktop mode works best since xpra v2.2-r17117.
  You have installed lower version $Xpraversion.
  It is recommended to use --xephyr or --nxagent instead.
  Rendering issues can be reduced disabling OpenGL in Xpra tray icon. Screen
  size issues can be avoided with non-integer scaling (e.g. --scale=1.01)."
      [ "$Desktopmode" = "no" ] && note "Xpra startup is rather slow. For faster startup
  with seamless applications,   try --nxagent.
  If security is not a concern, try --hostdisplay."
      [ "$Sharegpu" = "yes" ] && note "If performance of GPU acceleration with $Xserver
  is not satisfying, you can try insecure '--hostdisplay --gpu'."
    ;;

    --xephyr) note "Xephyr is a quite stable nested X server.
  Less stable, but resizeable is nxagent with option --nxagent."
    ;;

    --nxagent)
      [ "$Hostsystem" = "mageia" ] && {
        [ "$Desktopmode" = "no" ] && [ "$Autochooseserver" = "yes" ] && Desktopmode="yes" && Windowmanager="auto"
        [ "$Desktopmode" = "no" ] && warning "nxagent version 3.5.0 on Mageia 6 is known to crash
  in seamless mode. (Detected version: '$(strings --bytes 20 /usr/libexec/nx/nxagent | grep "NXAGENT - Version")').
  If you encounter issues, please try seamless --xpra (secure),
  --hostdisplay (insecure), or run --nxagent in desktop mode with a
  host window manager (--wm=WINDOWMANAGER or --wm=auto or short -wm)."
      }
      note "A few applications do not work well with --nxagent
  or do not appear at all (e.g. atom editor, kodi, cinnamon).
  In that case, please try another X server option like --xephyr or --xpra."
    ;;

    --weston|--kwin|--hostwayland)
      note "You are running a pure Wayland environment.
  X applications without Wayland support will fail."
      [ "$Xserver" = "--kwin" ] && note "kwin_wayland (option --kwin) does not support the xdg_shell
  interface in all versions. Some GTK3 Wayland applications depend on it.
  If application startup fails, try --weston instead."
    ;;
  esac

  # --fullscreen
  [ "$Fullscreen" = "yes" ] && {
    case $Xserver in
      --xephyr|--weston|--weston-xwayland|--nxagent|--xpra|--xpra-xwayland|--vcxsrv|--xwin) ;;
      --xdummy|--xdummy-xwayland|--xvfb|--xorg) ;;
      *) note "$Xserver does not support option --fullscreen" ;;
    esac
  }

  # --hostipc
  [ "$Sharehostipc" = "yes" ] && warning "Security risk:
  Option --hostipc causes severe reduction of container isolation!
  Drawback: IPC namespace remapping is disabled.
  Advantage: X extension MIT-SHM is possible."

  # --hostnet
  [ "$Sharehostnet" = "yes" ] && warning "Security risk:
  Option --hostnet causes severe reduction of container isolation!
  Network namespacing is disabled.
  Drawback: Container shares host network stack.
  Advantage: dbus communication between host and container is possible."

  # --keymap: XKB keyboard layount
  [ -n "$Xkblayout" ] && case $Xserver in
    --kwin|--kwin-xwayland)
      [ "$Tty" = "yes" ] && note "Option --keymap does not work with option $Xserver
  if running from console."
    ;;
  esac

  # --output-count
  [ "$Outputcount" != "1" ] && {
    case $Xserver in
      --weston-xwayland) note "Xwayland sometimes does not position itself well
  at origin 0+0 of first virtual screen, and some screens appear to be unused.
  You may need to move Xwayland manually with [META]+[LeftMouseButton].
  (Bug report at https://bugzilla.redhat.com/show_bug.cgi?id=1498665 )" ;;
      --xephyr) note "Xinerama support would be best for multiple outputs,
  but is disabled in Xephyr because Xephyr does not handle it well.
  Different window managers handle this different. Just try out." ;;
    esac
  }

  # --cap-default
  [ "$Capdropall" = "no" ] && warning "Option --cap-default disables security hardening
  for containers. Granting docker's default capabilities is considered insecure."

  # --sys-admin
  [ "$Capsysadmin" = "yes" ] && warning "Option --sys-admin may be dangerous.
  It adds insecure capability SYS_ADMIN to container.
  It is needed to run debian 9 images with option --systemd.
  Debian 10 images run well without --sys-admin."

  # --sudouser
  [ "$Sudouser" = "yes" ] && warning "Option --sudouser severly reduces container security.
  Container gains additional capabilities to allow sudo and su.
  If an application breaks out of container, it can harm your system
  in every way without you noticing. Password: x11docker"
}

{ #### part: check free display, create temporary cache subfolder and cache files

  [ -z "$Newdisplaynumber" ] && {
    # Look for next free display and change some display specific variables
    case $Xserver in               # set initial value for searching free display number
      --xorg)                            Newdisplaynumber="8"   ;;
      --hostdisplay)                     Newdisplaynumber="50"  ;; # dummy number to look for free cache folder, DISPLAY will be $Hostdisplay
      --xpra|--xpra-xwayland)            Newdisplaynumber="100" ;;
      --xephyr)                          Newdisplaynumber="200" ;;
      --weston-xwayland)                 Newdisplaynumber="250" ;;
      --xdummy|--xvfb|--xdummy-xwayland) Newdisplaynumber="300" ;;
      --nxagent)                         Newdisplaynumber="400" ;;
      --xwayland)                        Newdisplaynumber="500" ;;
      --hostwayland)                     Newdisplaynumber="550" ;; # dummy number to look for free cache folder, DISPLAY will be empty
      --weston)                          Newdisplaynumber="600" ;;
      --kwin)                            Newdisplaynumber="700" ;;
      --kwin-xwayland)                   Newdisplaynumber="750" ;;
      --nothing)                         Newdisplaynumber="900" ;; # dummy number to look for free cache folder
      --vcxsrv)                          Newdisplaynumber="1000" ;;
      --xwin)                            Newdisplaynumber="1050" ;;
    esac

    # search free X socket number and free Wayland socket number, passing already used cache folders
    while :; do
      [ -n "$(find /tmp/.X11-unix/X$Newdisplaynumber /tmp/.X$Newdisplaynumber-lock /tmp/.X11-unix/X$Newdisplaynumber $XDG_RUNTIME_DIR/wayland-$Newdisplaynumber $Cachebasefolder/X$Newdisplaynumber-* 2>/dev/null)" ] || { 
        case $Xserver in
          --vcxsrv) grep -q -E 'Authorization|Absolute' <<< "$(xwininfo.exe -display $Newdisplay -root 2>&1)" || break ;;
          *) break ;;
        esac
      }
      Newdisplaynumber=$(($Newdisplaynumber + 1))
    done
  }

  Newdisplay=":$Newdisplaynumber"
  Newxsocket="/tmp/.X11-unix/X$Newdisplaynumber"
  Newxlock="/tmp/.X$Newdisplaynumber-lock"
  [ "$Xserver" != "--hostdisplay" ] && [ -n "$(find $Newxsocket $Newxlock 2>/dev/null)" ] && error "Display $Newdisplay is already in use."

  Imagenametr=$(echo $Imagename | tr / - | cut -d: -f1)
  [ "$Imagenametr" ] || Imagenametr=${Xserver#--}

  Cachefolder="$Cachebasefolder/X$Newdisplaynumber-$Imagenametr"
  [ -d "$Cachefolder" ] && error "Cache folder already exists:
  $Cachefolder"

  [ "$Cachefolder" != "$(escapestring "$Cachefolder")" ] && error "Invalid name created for cache folder:
    $Cachefolder
  Most probably provided image name (or --exe command) is invalid in some way:
    $(escapestring "$Imagename")
  For special setups like command chains use a syntax like:
    x11docker IMAGENAME  --  sh -c \"cd /etc && xterm\""

  Sharefolder="$Cachefolder/$Sharefolder"
  $Mksu "mkdir -p $Sharefolder"
  export Cachefolder Sharefolder

  case $Xserver in
    --hostdisplay)
      Newdisplay=$Hostdisplay
      Newdisplaynumber=$(echo $Newdisplay | cut -d: -f2 | cut -d. -f1)
      [ -e "$Hostxsocket" ] && Newxsocket=$Hostxsocket || Newxsocket=
      Newxlock="/tmp/.X$Newdisplaynumber-lock"
      [ -e "$Newxlock" ] || Newxlock=""
    ;;
    --vcxsrv)
      Newxsocket=""
      Newdisplay="$Hostip:$Newdisplaynumber"
    ;;
  esac

  Timetosaygoodbye="$Sharefolder/$Timetosaygoodbye"                 && mkfile $Timetosaygoodbye
  Xinitrc="$Cachefolder/$Xinitrc"                                   && mkfile $Xinitrc
  Xinitlogfile="$Cachefolder/$Xinitlogfile"                         && mkfile $Xinitlogfile
  Xtermrc="$Cachefolder/$Xtermrc"                                   && mkfile $Xtermrc
  Pullrc="$Cachefolder/$Pullrc"                                     && mkfile $Pullrc
  Containerlogfile="$Cachefolder/$Containerlogfile"                 && mkfile $Containerlogfile
  Containerpidfile="$Cachefolder/$Containerpidfile"                 && mkfile $Containerpidfile
  Containeridfile="$Cachefolder/$Containeridfile"                   && mkfile $Containeridfile
  Containerpid1pidfile="$Cachefolder/$Containerpid1pidfile"         && mkfile $Containerpid1pidfile
  Dockerrc="$Cachefolder/$Dockerrc"                                 && mkfile $Dockerrc
  Containerrootsetupscript="$Sharefolder/$Containerrootsetupscript" && mkfile $Containerrootsetupscript
  Containeripfile="$Cachefolder/$Containeripfile"                   && mkfile $Containeripfile
  Xservercookie="$Cachefolder/$Xservercookie"                       && mkfile $Xservercookie
  Xclientcookie="$Sharefolder/$Xclientcookie"                       && mkfile $Xclientcookie
  Hostxauthority="$Cachefolder/$Hostxauthority"                     && mkfile $Hostxauthority
  Xpraserverlogfile="$Cachefolder/$Xpraserverlogfile"               && mkfile $Xpraserverlogfile
  Xpraclientlogfile="$Cachefolder/$Xpraclientlogfile"               && mkfile $Xpraclientlogfile
  Compositorlogfile="$Cachefolder/$Compositorlogfile"               && mkfile $Compositorlogfile
  Compositorpidfile="$Cachefolder/$Compositorpidfile"               && mkfile $Compositorpidfile
  Pulseaudioconf="$Cachefolder/$Pulseaudioconf"                     && mkfile $Pulseaudioconf
  Pulseaudiologfile="$Cachefolder/$Pulseaudiologfile"               && mkfile $Pulseaudiologfile
  Bgpidfile="$Cachefolder/$Bgpidfile"                               && mkfile $Bgpidfile
  Imagecommandscript="$Sharefolder/$Imagecommandscript"             && mkfile $Imagecommandscript
  Shareclipboardscript="$Cachefolder/$Shareclipboardscript"         && mkfile $Shareclipboardscript
  Westonini="$Cachefolder/$Westonini"                               && mkfile $Westonini
  Xdummyconf="$Cachefolder/$Xdummyconf"                             && mkfile $Xdummyconf
  Xorgwrapper="$Cachefolder/$Xorgwrapper"                           && mkfile $Xorgwrapper
  Xkbkeymapfile="$Cachefolder/$Xkbkeymapfile"                       && mkfile $Xkbkeymapfile

  mv $Logfile $Sharefolder/x11docker.log
  Logfile="$Sharefolder/x11docker.log"

  # Cache folder for x11docker-gui. Created here to store image list in dockerrc for x11docker-gui
  mkdir -p $Cachebasefolder/x11docker-gui && chown $Hostuser $Cachebasefolder/x11docker-gui

  # standard streams for container
  Cmdstdoutlogfile="$Sharefolder/$Cmdstdoutlogfile"                 && mkfile $Cmdstdoutlogfile 666
  Cmdstderrlogfile="$Sharefolder/$Cmdstderrlogfile"                 && mkfile $Cmdstderrlogfile 666
  mkfile "$Sharefolder/environment"
}

{ #### part: option --xorg: check free vt / tty
  [ "$Newxvt" ] || case $Xserver in
    --xorg)
      # if started from console, use current tty
      [ "$Tty" = "yes" ] && {
        Newxvt="$(tty | rev | cut -d/ -f1 | rev)"
        Newxvt="${Newxvt#tty}"
      }

      # check ttys currently in use
      [ "$Newxvt" ] || {
        for Line in $(find /sys/class/vc/vcsa*); do
          Ttyinuse="$Ttyinuse ${Line#/sys/class/vc/vcsa} "
        done
        verbose -d "TTYs currently known to kernel: $Ttyinuse"
      }

      [ "$Newxvt" ] && grep -q " $Newxvt " <<<$Ttyinuse && warning "TTY $Newxvt seems to be already in use."

      # try to find free tty within range of 8..12
      [ "$Newxvt" ] || {
        for ((Newxvt=8 ; Newxvt<=12 ; Newxvt++)) ; do
          grep -q " $Newxvt " <<< "$Ttyinuse" || break
        done
      }

      # try to find free tty within range of 1..7
      [ "$Newxvt" ] || {
        for ((Newxvt=1 ; Newxvt<=7 ; Newxvt++)) ; do
          grep -q " $Newxvt " <<< "$Ttyinuse" || break
        done
      }

      # try to find free tty with fgconsole. Fails in some cases within X.
      [ "$Newxvt" ] || Newxvt=$(fgconsole --next-available 2>/dev/null ||:)
      [ "$Newxvt" ] || Newxvt=$(fgconsole --next-available 2>/dev/null </dev/tty$XDG_VTNR ||:)

      # try to find free tty within range of 13..63
      [ "$Newxvt" ] || {
        for ((Newxvt=13 ; Newxvt<=63 ; Newxvt++)) ; do
          grep -q " $Newxvt " <<< "$Ttyinuse" || break
        done
      }

      [ "$Newxvt" ] || error "Could not identify a free tty for --xorg."

      [ "$XDG_VTNR" ] && [ "$Hostdisplay$Hostwaylandsocket" ] && note "Current X server $Hostdisplay runs on tty $XDG_VTNR.
  Access it with [CTRL][ALT][F$XDG_VTNR]."

      [ "${Newxvt:-999}" -gt "12" ] && {
        fgconsole --next-available 1>/dev/null 2>/dev/null || note "Could not check for a free tty below or equal to 12.
  Would need to use command fgconsole for a better check.
  Possibilities:
  1.) Run x11docker as root.
  2.) Add user to group tty (not recommended, may be insecure).
  3.) Use display manager gdm3.
  4.) Run x11docker directly from console."
        note "To access X on tty$Newxvt, use command 'chvt $Newxvt'"
      } || {
        note "New Xorg server $Newdisplay will run on tty $Newxvt.
  Access it with [CTRL][ALT][F$Newxvt]."
      }

      warning "On debian 9, switching often between multiple X servers can
  cause a crash of one X server. This bug may be debian specific and is probably
  some sort of race condition. If you know more about this or it occurs on
  other systems, too, please report at https://github.com/mviereck/x11docker.

  You can avoid this issue with switching to a black tty before switching to X."
    ;;
    --xpra|--xdummy)
      ### FIXME vt number 128 out of range 1..63 seems to work even for multiple xpra/Xdummy instances.
      ### A check like for --xorg should be cleaner, but may cause issues if a later starting X accesses same tty.
      ### Running Xdummy with a vt number does not create entry in /sys/class/vc, but must not run on same vt as a real X.
      [ "$Newxvt" ] || Newxvt=128
    ;;
  esac
}

{ #### part: options --verbose, --stdout, --stderr
  # create summary logfile
  tail --pid=$$ --retry -n +1 -F $Containerlogfile $Pulseaudiologfile \
                                 $Cmdstdoutlogfile $Cmdstderrlogfile ${Journallogfile:-} \
                                 $Xpraserverlogfile $Xpraclientlogfile \
                                 $Xinitlogfile $Compositorlogfile 2>/dev/null >>$Logfile &

  # option --verbose
  [ "$Verbose" = "yes" ] && {
    [ "$Initsystem" = "systemd" ] && note "x11docker deletes some systemd error messages
  that are harmless but numerous to get a better readable output.
  It deletes all lines with: 'Failed to add fd to store',
  'Failed to set invocation ID' and 'Failed to reset devices.list'."
    case $Verbosecolors in
      no)  tail --pid=$$ --retry -n +1 -F $Logfile 2>/dev/null >&3 & ;;
      yes) tail --pid=$$ --retry -n +1 -F $Logfile 2>/dev/null | sed "
                                      /\(Failed to add fd to store\|Failed to set invocation ID\|Failed to reset devices.list\)/d;
                                      s/\(ERROR\|Error\|error\|FAILURE\|FATAL\|Fatal\|fatal\)/${Colredbg}\1${Colnorm}/g;
                                      s/\(Failed\|failed\|Failure\|failure\)/${Colred}\1${Colnorm}/g;
                                      s/\(WARNING\|Warning\|warning\)/${Colyellow}\1${Colnorm}/g;
                                      s/\(DEBUGNOTE\)/${Colblue}\1${Colnorm}/g;
                                      s/^==>.*/${Coluline}\0${Colnorm}/;
                                      s/\(Starting\)/${Colgreen}\0${Colnorm}/;
                                      s/\(Started\|Reached target\)/${Colgreenbg}\0${Colnorm}/;
                                      s/^\(+\|++\|+++\)/${Colgreenbg}\0${Colnorm}/ ;
                                      s/^x11docker/${Colgreen}\0${Colnorm}/ " >&3 & ;;
    esac
  }

  # options --stdout, --stderr
  [ "$Showstdout" = "yes" ] && {
    {
      waitforfilecontent $Containerpid1pidfile infinity
      tail --pid=$$ --retry -n +1 -F $Cmdstdoutlogfile     2>/dev/null
    } & storepid $! tailstdout
  }
  [ "$Showstderr" = "yes" ] && {
    {
      tail --pid=$$ --retry -n +1 -F $Cmdstderrlogfile >&4 2>/dev/null
    } & storepid $! tailstderr
  }

  verbose "Logfile: $Logfile
In container: $Cshare/x11docker.log
After finish: $Logbackup"
}

{ #### part: create $Hostxenv: Environment variables for host X display
  # get cookie from host display
  [ -n "$Hostdisplay" ] && {
    $Xauth nlist $Hostdisplay 2>/dev/null | rmcr | $Mksu "$Xauth -f $Hostxauthority nmerge - 2>/dev/null"
    chown $Hostuser $Hostxauthority
    chmod 600 $Hostxauthority
  } || {
    Hostdisplay=""
    Hostxauthority=""
    Hostxsocket=""
  }

  Hostxenv="DISPLAY=$Hostdisplay"
  [ -s "$Hostxauthority" ] && {
    Hostxenv="$Hostxenv XAUTHORITY=$Hostxauthority"
    export XAUTHORITY=$Hostxauthority
  } || {
    Hostxauthority=
    unset XAUTHORITY
  }

  [ -n "$Hostxsocket" ] && Hostxenv="$Hostxenv XSOCKET=$Hostxsocket"
  [ -n "$Hostwaylandsocket" ] && Hostxenv="$Hostxenv WAYLAND_DISPLAY=$Hostwaylandsocket"
  Hostxenv="$Hostxenv XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR"
  [ -n "$Hostdisplay" ] && [ -z "$Hostxauthority" ] && warning "Your host X server runs without cookie authentication."
}

{ #### part: check physical and virtual screen size
  # Dummy start of Xwayland to detect screen size in pure Wayland environments
  [ -z "$Hostdisplay" ] && [ -n "$Hostwaylandsocket" ] && command -v Xwayland >/dev/null && {
    verbose -d "Running Xwayland to get screen size"
    Xwayland $Newdisplay -rootless -extension GLX +extension RANDR >>$Xinitlogfile 2>&1 & Xwaylandpid=$! && disown
    waitforfilecreation $Newxsocket
    export DISPLAY=$Newdisplay
  }

  # check whole display size, can include multiple monitors
  [ -n "$Hostdisplay" ] && {
    command -v xrandr >/dev/null && {
      Line=$(xrandr 2>/dev/null | grep current | head -n1 | cut -d, -f2)
      Maxxaxis=$(xrandr 2>/dev/null | grep current | head -n1 | cut -d, -f2 | cut -d' ' -f3)
      Maxyaxis=$(xrandr 2>/dev/null | grep current | head -n1 | cut -d, -f2 | cut -d' ' -f5)
    }
    [ -z "$Maxxaxis" ] && command -v xdpyinfo >/dev/null && {
      Maxxaxis=$(xdpyinfo | grep dimensions | cut -dx -f1 | rev | cut -d ' ' -f1 | rev)
      Maxyaxis=$(xdpyinfo | grep dimensions | cut -dx -f2 | cut -d ' ' -f1)
    }
    [ -z "$Maxxaxis" ] && command -v xwininfo >/dev/null && {
      Maxxaxis=$(xwininfo -root -stats | rmcr | grep Width  | rev | cut -d' ' -f1 | rev)
      Maxyaxis=$(xwininfo -root -stats | rmcr | grep Height | rev | cut -d' ' -f1 | rev)
    }
    [ -z "$Maxxaxis" ] && note "Could not determine your screen size.
  Please improve this by installing one of xrandr, xdpyinfo or xwininfo.
  Or use option --size=XxY."
  }

  [ -n "$Maxxaxis" ] && {
    Xaxis=$Maxxaxis
    Yaxis=$Maxyaxis
  }

  [ "$Fullscreen" = "yes" ] && [ "$Tty" = "no" ] && [ -n "$Maxxaxis" ] && Screensize="${Maxxaxis}x${Maxyaxis}"

  # size for windowed desktops, roughly maximized relative to primary monitor
  case $Xserver in
    --xpra|--xpra-xwayland) [ "$Desktopmode" = "yes" ] && Xserver="${Xserver}-desktop" ;;
  esac
  case $Xserver in
    --xephyr|--weston-xwayland|--weston|--kwin|--kwin-xwayland|--nxagent|--xpra-desktop|--xpra-xwayland-desktop)
      [ "$Tty" = "yes" ] && {
        : # nothing to do on tty; maybe should check --size=$Screensize
      } || {
        command -v xrandr > /dev/null && xrandr 2>/dev/null | grep -q ' connected' && { # reduce size to primary monitor for windowed desktop
          Xaxis=$(xrandr 2>/dev/null | grep ' connected' | head -n1 | cut -dx -f1 | rev | cut -d' ' -f1 | rev)
          Yaxis=$(xrandr 2>/dev/null | grep ' connected' | head -n1 | cut -dx -f2 | cut -d' ' -f1 | cut -d+ -f1)
          Xaxis=$((Xaxis-96))
          Yaxis=$((Yaxis-96))
          Xaxis=$(( $(( $Xaxis / 8 )) * 8 ))  # avoid grey edge in Xwayland, needs full byte x width
        } || {
          note "Could not determine size of your primary display to
  create a roughly maximized window for $Xserver.
  Please install xrandr or use option --size=XxY.
  Fallback: setting virtual screen size 800x600"
          Xaxis="800"
          Yaxis="600"
        }
      }
    ;;
  esac
  Xserver=${Xserver%-desktop}

  [ -z "$Xaxis" ] && {       ### FIXME: arbitrary resolution. At least, --xorg checks again with xrandr in xinitrc
    Xaxis="4720"
    Yaxis="3840"
  }

  # regard scaling (option --scale)
  [ "$Scaling" ] && {
    Xaxis=$(awk -v a=$Xaxis -v b=$Scaling 'BEGIN {print (a / b)}')
    Xaxis=${Xaxis%.*}
    Yaxis=$(awk -v a=$Yaxis -v b=$Scaling 'BEGIN {print (a / b)}')
    Yaxis=${Yaxis%.*}
  }
  [ -n "$Screensize" ] && {  # regard --size, overwriting Xaxis/Yaxis from above
    Xaxis=${Screensize%x*}
    Yaxis=${Screensize#*x}
  }
  case $Xserver in
    --xorg) ;;  # Xorg autodetects screen size, preset only with option --size
    *) [ "$Tty" = "no" ] && Screensize="${Xaxis}x${Yaxis}" ;;
  esac
  [ -z "$Maxxaxis" ] && {
    Maxxaxis=$Xaxis
    Maxyaxis=$Yaxis
  }
  [ "$Xaxis" -gt "$Maxxaxis" ] && Maxxaxis=$Xaxis
  [ "$Yaxis" -gt "$Maxyaxis" ] && Maxyaxis=$Yaxis

  command -v cvt >/dev/null && Modeline="$(cvt $Xaxis $Yaxis | tail -n1 | cut -d' ' -f2-)"

  # kill dummy Xwayland process
  checkpid $Xwaylandpid && {
    verbose -d "Terminating Xwayland"
    kill $Xwaylandpid
  }
  export DISPLAY=$Hostdisplay

  verbose "Virtual screen size: $Screensize"
  verbose "Physical screen size:
  $(xrandr 2>/dev/null | grep Screen ||:)"
}

{ #### part: --gpu: check nvidia driver
  [ "$Sharegpu" = "yes" ] && {
    warning "Option --gpu degrades container isolation.
  Container gains access to GPU hardware.
  This allows reading host window content (palinopsia leak)
  and GPU rootkits (compare proof of concept: jellyfish)."
  }

  # check for closed source nvidia driver on host, provide automated installation, warn about disadvantages
  [ "$Sharegpu" = "yes" ] && [ -e "/proc/driver/nvidia" ] && {
    Nvidiaversion=$(head -n1 </proc/driver/nvidia/version | awk '{ print $8 }')
    verbose -d "Detected nvidia driver version $Nvidiaversion on host."
    Nvidiadriver=$(find /usr/local/share/x11docker/NVIDIA* $Hostuserhome/.local/share/x11docker/NVIDIA* 2>/dev/null | grep $Nvidiaversion )
    Nvidiadriver="$(realpath "$Nvidiadriver")"

    [ -e "$Nvidiadriver" ] && {
      verbose -d "Found proprietary closed source nvidia driver installer
  $Nvidiadriver"
      note "Will install closed source nvidia driver $Nvidiaversion in container.
  That slows down container startup. Startup will be much faster if image
  already includes modprobe and xz (packages 'kmod' and 'xz' or 'xz-utils').
  With free nouveau driver on host there would be no startup delay.
  Ask NVIDIA corporation to publish the closed source API of your hardware.
  Ask NVIDIA corporation to actively support free nouveau driver."

      [ "$Capdropall" = "yes" ] && warning "To install proprietary closed source nvidia driver,
  x11docker must give some capabilities to container that would be dropped
  otherwise for security reasons. Container security is reduced now.
  You would not have this issue with free nouveau driver on host."

      note "Installation of proprietary closed source nvidia driver
  fails in containers based on musl libc like NixOS and Alpine.
  Installation in openSUSE containers fails with a self-extraction error.

  For openSUSE images you can try to create a custom installation
  command with option --runasroot or to install a closed source nvidia driver
  in image itself that matches your nvidia driver version on host."

      case $Xserver in
        --hostdisplay|--xorg) ;;
        *)
          warning "Closed source nvidia driver has serious issues with Wayland.
  Chosen option $Xserver may fail to provide hardware acceleration.
  Only options --hostdisplay and --xorg will work reliably.
  Recommendation: Instead of closed nvidia driver use free nouveau driver."
        ;;
      esac

    } || {
      Nvidiadriver=""
      warning "You are using proprietary closed source nvidia driver.
  GPU acceleration will only work if you have installed the very same driver
  version in image. That makes images less portable.
  It is recommended to use free open source nouveau driver on host instead.
  Ask NVIDIA corporation to at least publish their closed source API,
  or even better to actively support open source drivers like nouveau."

      note "x11docker can try to automatically install nvidia driver
  version $Nvidiaversion in container on every container startup.
  Drawbacks: Container startup is slower and its security will be reduced.

  You can look here for a driver installer:
    https://www.nvidia.com/Download/index.aspx
    https://http.download.nvidia.com/
  A direct download URL may be:
   https://http.download.nvidia.com/XFree86/Linux-x86_64/$Nvidiaversion/NVIDIA-Linux-x86_64-$Nvidiaversion.run
  If you got a driver, store it at one of the following locations:
    $Hostuserhome/.local/share/x11docker/
    /usr/local/share/x11docker/

  Be aware that the version number must match exactly the version on host.
  The file name must begin with 'NVIDIA', contain the version number $Nvidiaversion
  and end with suffix '.run'.

  Automated installation fails on image systems not using glibc like Alpine
  and fails on openSUSE images with a self-extraction error.
  These issues cannot be fixed due to closed source policy of NVIDIA corporation.

  To avoid all this, use free nouveau driver on host
  instead of proprietary closed source nvidia driver."
    }
  }
}

{ #### part: check window manager (option --wm)
  case $Windowmanager in
    ""|"none") Windowmanager="" ;;
    *)
      [ "$Windowmanager" = "auto" ] && Windowmanager=""

      # check if one is chosen with option --wm
      [ "$Windowmanager" ] && {
        command -v $Windowmanager > /dev/null || {
          warning "Window manager '$Windowmanager' not found.
  Fallback: Will try to autodetect a window manager on host."
          Windowmanager=""
        }
      }

      # try to find window manager from alternatives system
      [ -z "$Windowmanager" ] && [ -e "/etc/alternatives/x-window-manager" ] && {
        note "Looking for windowmanager linked with x-window-manager.
  You can set the default one detected in auto mode with
    update-alternatives --config x-window-manager"
        Windowmanager=$(command -v $(ls -l /etc/alternatives/x-window-manager | cut -d ">" -f2))
      }

      # try to find one in list
      [ "$Windowmanager" ] || {
        verbose -d "Searching for window manager in list."
        for Windowmanager in $Wm_all "" ; do
          command -v $Windowmanager >/dev/null && break
        done
      }

      # try with wmctrl
      [ -z "$Windowmanager" ] && command -v wmctrl >/dev/null && {
        verbose -d "Searching for window manager with wmctrl"
        Windowmanager=$(wmctrl -m | grep 'PID' | awk '{print $2}')                 # wmtrl, if installed, can find already running wm. At first get pid
        [ -e "/proc/${Windowmanager:--1}" ] && {                                         # check if pid is valid
          Windowmanager=$(ls -l "/proc/$Windowmanager/exe" | awk '{print $11}')    # if yes, then get /path/executable
        } || {                                                                     # otherwise, try insecure way over name
          Windowmanager=$(wmctrl -m | grep 'Name' | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
        }
      }

      # check some special cases
      [ "$Windowmanager" ] && case $(basename $Windowmanager | cut -d' ' -f1) in
        cinnamon|cinnamon-session) Windowmanager="cinnamon --sm-disable";;
        compiz) # if none, create minimal config to have useable window decoration and can move windows
          [ -e "$Hostuserhome/.config/compiz-1/compizconfig/Default.ini" ] || {
            $Mksu "mkdir -p '$Hostuserhome/.config/compiz-1/compizconfig'"
            mkfile "$Hostuserhome/.config/compiz-1/compizconfig/Default.ini"
            echo '[core]
s0_active_plugins = core;composite;opengl;decor;resize;move;
' >> "$Hostuserhome/.config/compiz-1/compizconfig/Default.ini"
          }  ;;
        enlightenment|e17|e16|e19|e20|e) Windowmanager="enlightenment_start" ;;
        matchbox) Windowmanager="matchbox-window-manager"  ;;
        mate|mate-session) Windowmanager="mate-session -f" ;;
        mate-wm) Windowmanager="marco --sm-disable"  ;;
        openbox) Windowmanager="openbox --sm-disable" ;;
        gnome-shell|gnome-session) warning "$Windowmanager is known to cause segfaults.
  Please choose another one."
        Windowmanager="gnome-shell --sm-disable" ;;
        budgie-wm|mutter) warning "$Windowmanager is known to cause segfaults.
  Please choose another one." ;;
      esac

      [ "$Windowmanager" ] && case $(basename $Windowmanager | cut -d' ' -f1) in
        enlightenment_start|lxsession|mate-session|cinnamon)
          note "Using extensive window manager '$Windowmanager'.
  It is recommended to install and use a lightweight window manager like
  $Wm_recommended_nodesktop_light"
        ;;
        *) note "Using host window manager $Windowmanager"
      ;;
    esac

    [ "$Windowmanager" ] && ! command -v $Windowmanager >/dev/null && warning "No executeable window manager '$Windowmanager' found."
    [ "$Windowmanager" ] || note "Could not detect a host window manager.
  Please specify one with option --wm=WINDOWMANAGER or install one of
  $Wm_good"
  ;;
  esac
  [ "$Windowmanager" ] && verbose -d "As window manager from host serves: $Windowmanager"
}

{ #### part: check sound (options --pulseaudio and --alsa)

  # --alsa currently not supported on Windows
  [ "$Winsubsystem" ] &&  [ "$Alsa" = "yes" ]  && {
    note "Options --alsa does not work on $Winsubsystem.
  Fallback: Enabling --pulseaudio=tcp"
    Pulseaudiomode="tcp"
    Alsa="no"
  }    
  [ "$Winsubsystem" ] &&  [ "$Pulseaudiomode" = "socket" ]  && Pulseaudiomode="tcp"

  # option '--pulseaudio'
  [ "$Pulseaudiomode" ] && warning "Option --pulseaudio allows container applications
  to catch your audio output and microphone input."
  
  case $Pulseaudiomode in
    socket)
      Customenvironment="PULSE_SERVER=unix:$Cshare/pulseaudio.socket
PULSE_COOKIE=$Cshare/pulseaudio.cookie
$Customenvironment"

      echo "# Connect to the host's server using the mounted UNIX socket
default-server = unix:$Cshare/pulseaudio.socket
# Prevent a server running in the container
autospawn = no
daemon-binary = /bin/true
# Prevent the use of shared memory
enable-shm = false
" >> $Pulseaudioconf
      echo "Generated pulseaudio client.conf:
$(nl -ba <<<$Pulseaudioconf)" >>$Pulseaudiologfile
    ;;
    tcp)
      case $Winsubsystem in
        "")
          read Lowerport Upperport < /proc/sys/net/ipv4/ip_local_port_range 2>/dev/null
          [ "$Lowerport" ] || Lowerport=33000
          [ "$Upperport" ] || Upperport=60000
          while : ; do
            Pulseaudioport="$(shuf -i $Lowerport-$Upperport -n1)"
            ss -lpn | grep -q ":$Pulseaudioport " || break
          done
        ;;
        *)
          note "Option --pulseaudio: Pulseaudio daemon will continue
  to run after x11docker terminates. You can kill pulseaudio manually with:
      taskkill.exe /PID pulseaudio.exe /F"
          [ -e "$Winsubmount/c/cygwin64/bin/pulseaudio.exe" ] || { 
            warning "--pulseaudio: Did not find C:/cygwin64/bin/pulseaudio.exe.
  Please install Cygwin with pulseaudio.
  Fallback: Disabling option --pulseaudio"
            Pulseaudiomode=""
          }
          Line="$(netstat -n)"
          while :; do
            Pulseaudioport="$(shuf -i 34000-54000 -n1)"
            grep -q $Pulseaudioport <<<"$Line" || break
          done
          env XDG_RUNTIME_DIR="" HOME="" cmd.exe /C "C:/cygwin64/bin/pulseaudio.exe -D 2>&1" 2>&1 >>$Pulseaudiologfile
        ;;
      esac
      [ "$Pulseaudiomode" ] && Customenvironment="PULSE_SERVER=tcp:$Hostip:$Pulseaudioport
$Customenvironment"
    ;;
    "") ;;
    *) 
      warning "Unknown pulseaudio mode: $Pulseaudiomode
  Allowed are --pulseaudio=socket or --pulseaudio=tcp
  Fallback: disabling option --pulseaudio"
      Pulseaudiomode=""
    ;;  
  esac

  # option --alsa
  [ "$Alsa" = "yes" ] && {
    warning "ALSA sound with option --alsa degrades container isolation.
  Shares device files in /dev/snd, container gains access to sound hardware.
  Container applications can catch audio output and microphone input."

    note "You can specify the sound card to use setting environment
  variable ALSA_CARD. Example:  --env ALSA_CARD=Generic
  Following sound cards found on your system:
$(grep ':' </proc/asound/cards | cut -d"[" -f2 | cut -d"]" -f1)
  Option --alsa allows a general access to real sound cards.
  To use virtual ALSA devices like dmix, too, install ALSA libraries in image.
  (Example: debian images would need package libasound2)."

    pgrep pulseaudio >/dev/null && note "It seems that pulseaudio is running on your host.
  Pulseaudio can interfere with ALSA sound (option --alsa).
  Host sound may not work while container is playing sound and vice versa.
  Alternative: with pulseaudio on host and in image, use option --pulseaudio."
  
    [ -z "$(ls /dev/snd 2>/dev/null)" ] && {
      note "No sound hardware found in /dev/snd.
  Fallback: Disabling option --alsa."
      Alsa="no"
    }
  }
}

{ #### part: create xorg.conf and Xorg wrapper for --xdummy (options --xdummy, --xpra)
  case $Xserver in
    --xpra|--xdummy)
      # create xorg.conf for Xdummy
      { echo '# This xorg configuration file is forked and changed from xpra to start a dummy X11 server.
# For original and details, please see: https://xpra.org/Xdummy.html
Section "ServerFlags"
  Option "DontVTSwitch" "true"
  Option "AllowMouseOpenFail" "true"
  Option "PciForceNone" "true"
  Option "AutoEnableDevices" "false"
  Option "AutoAddDevices" "false"
EndSection
Section "Device"
  Identifier "dummy_videocard"
  Driver "dummy"
  DacSpeed 600
  Option "ConstantDPI" "true"
  VideoRam '$(($Maxxaxis * $Maxyaxis * 2 * 32 / 8 / 1024))'
EndSection
Section "Monitor"
  Identifier "dummy_monitor"
  HorizSync   1.0 - 2000.0
  VertRefresh 1.0 - 200.0
  Modeline '$Modeline'
  '
  command -v cvt >/dev/null && {
    echo "# add some virtual display sizes to allow flexible xpra client window resizing from 25% up to fullscreen"
    for Ycount in 25 30 35 40 45 50 55 60 65 60 75 80 85 90 95 100; do
      for Xcount in 25 30 35 40 45 50 55 60 65 60 75 80 85 90 95 100; do
        cvt $(awk -v a=$Maxxaxis -v b=$Xcount 'BEGIN {print (a * b / 100)}') $(awk -v a=$Maxyaxis -v b=$Ycount 'BEGIN {print (a * b / 100)}') | tail -n1
      done
    done
  } || echo "Modeline 1024x768_60.00   63.50  1024 1072 1176 1328  768 771 775 798 -hsync +vsync"

  echo '
EndSection
Section "Screen"
  Identifier "dummy_screen"
  Device "dummy_videocard"
  Monitor "dummy_monitor"
  DefaultDepth 24
  SubSection "Display"
    Viewport 0 0
    Depth 32
    Modes '$(echo $Modeline | cut -d " " -f1)'
    Virtual '$Xaxis' '$Yaxis'
  EndSubSection
EndSection
Section "ServerLayout"
  Identifier   "dummy_layout"
  Screen       "dummy_screen"
EndSection
'
} >> $Xdummyconf
    ;;
  esac

  # create starter script for Xdummy
  echo '#!/bin/sh
#@PydevCodeAnalysisIgnore
# fork of https://xpra.org/trac/browser/xpra/trunk/src/scripts/xpra_Xdummy
find_ld_linux() {
	arch=$(uname -m)

	if [ $arch = "x86_64" ]; then
		LD_LINUX="/lib64/ld-linux-x86-64.so.2"
	elif [ $arch = "i386" ]; then
		LD_LINUX="/lib/ld-linux.so.2"
	elif [ $arch = "i486" ]; then
		LD_LINUX="/lib/ld-linux.so.2"
	elif [ $arch = "i586" ]; then
		LD_LINUX="/lib/ld-linux.so.2"
	elif [ $arch = "i686" ]; then
		LD_LINUX="/lib/ld-linux.so.2"
	elif [ $arch = "armel" ]; then
		LD_LINUX="/lib/ld-linux.so.3"
	elif [ $arch = "armhfp" ]; then
		LD_LINUX="/lib/ld-linux.so.3"
	elif [ $arch = "armhf" ]; then
		LD_LINUX="/lib/ld-linux-armhf.so.3"
	elif [ $arch = "ppc64" ]; then
		LD_LINUX="/lib64/ld64.so.1"
	elif [ $arch = "s390x" ]; then
		LD_LINUX="/lib64/ld64.so.1"
	else
		#suitable for: powerpc/ppc, mips/mipsel, s390 and others:
		LD_LINUX="/lib/ld.so.1"
	fi

	if [ ! -x "$LD_LINUX" ]; then
		# Musl C / Alpine Linux
		ldmusl=$(ls /lib | grep ^ld-musl)
		if [ -n "$ldmusl" ]; then
			LD_LINUX="/lib/$ldmusl"
		else
			LD_LINUX=""
			echo "could not determine ld path for $arch, please file an xpra bug"
		fi
	fi
}

if [ -x "/usr/libexec/Xorg" ]; then
	#Fedora 22+ workaround where /usr/bin/Xorg is not suid
	#because it is a script, command -v calls /usr/libexec/Xorg.wrap
	#command -v is setuid, and command -v eventually calls this one:
	XORG_BIN="/usr/libexec/Xorg"
elif [ -x "/usr/libexec/Xorg.bin" ]; then
	#Fedora 21 workaround where /usr/bin/Xorg is not suid
	#because it is a script, command -v calls /usr/libexec/Xorg.wrap
	#command -v is setuid, and command -v eventually calls this one:
	XORG_BIN="/usr/libexec/Xorg.bin"
elif [ -x "/usr/lib/xorg-server/Xorg" ]; then
	#Arch Linux:
	exec "/usr/lib/xorg-server/Xorg" "$@"
elif [ -x "/usr/lib/xorg/Xorg" ]; then
	#Ubuntu 16.10:
	exec "/usr/lib/xorg/Xorg" "$@"
else
	XORG_BIN=$(command -v Xorg)
fi
if [ ! -x "$XORG_BIN" ]; then
	echo "failed to locate Xorg binary to run"
	exit 1
fi
if [ -u "$XORG_BIN" ]; then
	# setuid is set, we need to do magic
	find_ld_linux
	if [ -n "$LD_LINUX" ]; then
		if [ -n "$BASH" ]; then
			#running in bash, can show a more helpful command name:
			exec -a "Xorg-nosuid" "$LD_LINUX" "$XORG_BIN" "$@"
		else
			exec "$LD_LINUX" "$XORG_BIN" "$@"
		fi
	else
		#fallback to making a copy of the binary:
		DOTXPRA_DIR="$HOME/.xpra"
		if [ ! -d "$DOTXPRA_DIR" ]; then
	 		mkdir "$DOTXPRA_DIR"
	 		chmod 700 "$DOTXPRA_DIR"
	 	fi
		NOSUID_XORG="$DOTXPRA_DIR/Xorg-nosuid"
	 	cp -f "$XORG_BIN" "$NOSUID_XORG"
	 	exec "$NOSUID_XORG" "$@"
	 fi
else
	# setuid is not set on xorg_bin
	exec "$XORG_BIN" "$@"
fi
' >> $Xorgwrapper
}

{ #### part: create command to start X server and/or Wayland compositor
  Xserveroptions="-dpms -s off"
  case $Xserver in
    --nxagent)
      { [ "$Sharehostipc" = "yes" ] || [ "$X11dockermode" = "exe" ] ; } && Xserveroptions="$Xserveroptions -shmem -shpix" || Xserveroptions="$Xserveroptions -noshmem -noshpix"
#      # fixes issues with e.g. enlightenment, causes issues with e.g. xfce4-terminal. Development in nx-libs is in progress.
#      Xserveroptions="$Xserveroptions \\
#  +extension Composite"
    ;;
    *)
      # general X server options
      Xserveroptions="$Xserveroptions -retro"
      # Most X servers have extension "Composite", recent Xwayland has "COMPOSITE".
      Xserveroptions="$Xserveroptions \\
  +extension Composite +extension COMPOSITE \\
  +extension RANDR +extension RENDER +extension GLX \\
  +extension XVideo +extension DOUBLE-BUFFER"
      Xserveroptions="$Xserveroptions \\
  -extension X-Resource +extension SECURITY +extension DAMAGE"
      Xserveroptions="$Xserveroptions \\
  -extension XINERAMA -xinerama"
      { [ "$Sharehostipc" = "yes" ] || [ "$X11dockermode" = "exe" ] ; } && { # --hostipc needed for shared memory.
        Xserveroptions="$Xserveroptions +extension MIT-SHM"
      } || {
        Xserveroptions="$Xserveroptions -extension MIT-SHM"
        Xprashm="XPRA_XSHM=0"
      }
    ;;
  esac

  # allow/disallow X over TCP
  case $Xserver in
    --vcxsrv|--xwin) Xserveroptions="$Xserveroptions \\
  -listen tcp" ;;
    *) Xserveroptions="$Xserveroptions \\
  -nolisten tcp" ;;
  esac

  # extension XTEST
  [ -z "$Xtest" ] && {
    case $Xserver in
      --xpra|--xpra-xwayland) Xtest="yes" ;;
      --xdummy|--xdummy-xwayland|--xvfb)
        Xtest="yes"
        note "Enabled X extension XTEST to allow custom access to new X server
  with Xpra. You can disable XTEST with option --no-xtest."
      ;;
      *) Xtest="no" ;;
    esac
  }
  case "$Xtest" in
    yes) Xserveroptions="$Xserveroptions \\
  +extension XTEST"
      [ -n "$Windowmanager" ] && warning "Did not disable X extension XTEST
  for X server $Xserver.
  If your host window manager $Windowmanager can start applications
  on its own (for example with a context menu), container applications
  can abuse this to run and remotely control host applications.
  If you provide content of X server $Xserver over network to others,
  they may take control over your computer!"
      ;;
    no)  Xserveroptions="$Xserveroptions \\
  -extension XTEST -tst"
      case $Xserver in
        --xpra|--xpra-xwayland) warning "You have disabled extension XTEST with --no-xtest.
  Xpra will not be able to manage keyboard and mouse." ;;
      esac
    ;;
  esac

  # check DPI
  case $Xserver in
    --xpra|--xpra-xwayland)
      { [ -n "$Dpi" ] || [ "$Scaling" ] ; } && verlt "$Xpraversion" "xpra v2.1-r16547" && ! verlt "$Xpraversion" "xpra v2.1" && {
        note "Option --dpi is buggy in $Xpraversion
  due to xpra bug #1605. Need at least xpra v2.1-r16547 or one of 2.0 series.
  This affects option --scale, too, leading to wrong font sizes.
  Fallback: disabling dpi settings."
        Dpi="-1"
      } ;;
  esac
  case $Xserver in
    --weston|--kwin|--nothing|--hostdisplay) ;;
    *)
      [ -z "$Dpi" ] && {
        xdpyinfo >/dev/null 2>&1 && {
          Dpi=$(xdpyinfo | grep dots | cut -dx -f2 | cut -d' ' -f1)
        } || {
          [ -n "$Hostdisplay" ] && [ -z "$(command -v xdpyinfo)" ] && note "Could not determine dpi settings. If you encounter too big or
  too small fonts with $Xserver, please install xdpyinfo or use option --dpi."
        }
        case $Xserver in
          --xpra|--xpra-xwayland)
            [ "$Scaling" ] && {
              [ "$Desktopmode" = "no" ] || ! verlt "$Xpraversion" "xpra v2.2" && {  # xpra desktop mode has same dpi baviour as non-desktop since v2.2. Before that, dpi in xpra desktop mode must not be adjusted
                Dpi=$(awk -v a="$Scaling" -v b="$Dpi" 'BEGIN {print (b * a * a)}')
                Dpi=${Dpi%.*}
              }
            }
          ;;
        esac
      }
    ;;
  esac
  [ "$Dpi" = "-1" ] && Dpi=""
  [ -n "$Dpi" ] && Xserveroptions="$Xserveroptions -dpi $Dpi"

  # xpra server and client command
  case $Xserver in
    --xpra|--xpra-xwayland)
      # check for version with cookie bug
      ! verlt "$Xpraversion" "xpra v2.3" && verlt "$Xprarelease" "r19606" && {
        command -v xhost >/dev/null || {
          warning "Your xpra version has a cookie authentication issue.
  also, 'xhost' is not available on your host.
  Fallback: Disabling cookie authentication on new X server."
          Xauthentication="no"
        }
      }

      # disable proxy for high versions
      verlt "$Xpraversion" "xpra v2.1" || Xpraoptions="$Xpraoptions \\
  --start-via-proxy=no"
      # disable --dpi for buggy versions
      [ -n "$Dpi" ] && verlt "$Xpraversion" "xpra v2.1-r16547" && ! verlt "$Xpraversion" "xpra v2.1" &&  Dpi=""
      verlt "$Xpraversion" "xpra v1.0" || Xpraoptions="$Xpraoptions \\
  --webcam=no"
      # --keymap
      [ "$Xkblayout" ] && Xpraoptions="$Xpraoptions \\
  --keyboard-layout='$Xkblayout' --keyboard-raw=yes"
  
      # specify unix socket location
      Xpraoptions="$Xpraoptions \\
  --socket-dir=$Cachefolder"

      # xpra server command
      [ "$Desktopmode" = "yes" ] && Xpraservercommand="xpra start-desktop" || Xpraservercommand="xpra start"
      Xpraservercommand="$Xpraservercommand $Newdisplay --use-display $Xpraoptions \\
  --no-daemon --fake-xinerama=no --mdns=no \\
  --notifications=no --file-transfer=off --printing=no \\
  --start-new-commands=no --dbus-proxy=no --no-pulseaudio \\
  --html=off --session-name=\"$Hostexebasename$Imagename $Imagecommandbasename\""
      verlt  "$Xprarelease" "r13378" || Xpraservercommand="$Xpraservercommand --systemd-run=no"
      verbose -d "Xpra server command:
  $Xpraservercommand"

      # xpra client command ### --window-close=shutdown
      Xpraclientcommand="xpra attach $Newdisplay $Xpraoptions \\
  -z0 --quality 100 \\
  --no-speaker --no-pulseaudio"
      [ "$Desktopmode" = "yes" ] && Xpraclientcommand="$Xpraclientcommand \\
  --title='$Imagename on $Newdisplay (shift+F11 toggles fullscreen)'" || Xpraclientcommand="$Xpraclientcommand \\
  --title='@title@ on ${Imagename:-"host"}'"
      [ "$Fullscreen" = "yes" ]  && Xpraclientcommand="$Xpraclientcommand \\
  --desktop-fullscreen=yes"
      [ "$Scaling" ] && Xpraclientcommand="$Xpraclientcommand \\
  --desktop-scaling=$Scaling"
      [ -n "$Dpi" ] && Xpraclientcommand="$Xpraclientcommand \\
  --dpi $Dpi"
      case $Shareclipboard in
        yes) Xpraclientcommand="$Xpraclientcommand --clipboard"    ;;
        no)  Xpraclientcommand="$Xpraclientcommand --no-clipboard" ;;
      esac
      verbose -d "Xpra client command:
  $Xpraclientcommand"

      [ -e "/run/user/$Hostuseruid" ] || {
        # can miss with option --hostuser, xpra needs it for socket
        verbose -d "Creating /run/user/$Hostuseruid"
        mkdir -p /run/user/$Hostuseruid
        chown $Hostuser /run/user/$Hostuseruid
        chmod 700 /run/user/$Hostuseruid
      }
    ;;
  esac

  # Prepare weston.ini: config file for Weston
  case $Xserver in
    --weston|--weston-xwayland|--xpra-xwayland|--xdummy-xwayland)
      echo "
[core]
shell=desktop-shell.so
idle-time=0
[shell]
panel-location=none
panel-position=none
locking=false
background-color=0xff002244
animation=fade
startup-animation=fade
[keyboard]
" >> "$Westonini"
      [ -n "$Xkblayout" ] && echo "keymap_layout=$Xkblayout" >> "$Westonini"
      [ -z "$Xkblayout" ] && [ "$Tty" = "yes" ] && echo "$(echo -n "keymap_layout=" && grep XKBLAYOUT <"/etc/default/keyboard" | cut -d= -f2 | cut -d'"' -f2)" >> "$Westonini"
      [ -n "$Hostwaylandsocket" ] && [ "$Xserver" != "--xpra-xwayland" ] && [ "$Hostsystem" != "ubuntu" ] && [ "$Fullscreen" = "no" ] && {
        Westonoutput="WL"
      } || {
        [ -n "$Hostdisplay" ] && Westonoutput="X"
      }
      [ -z "$Westonoutput" ] && [ -n "$Hostwaylandsocket" ] && Westonoutput="WL"

      [ "$Tty" = "yes" ] && {
        [ -n "$Screensize" ] || [ "$Scaling" ] || [ -n "$Rotation" ] && {
          # short start&stop of Weston to grep name of monitor
          $Mksu "weston --no-config --backend=drm-backend.so >> $Compositorlogfile 2>&1 & echo \$! >>$Compositorpidfile"
          Compositorpid=$(cat $Compositorpidfile)
          waitforlogentry weston $Compositorlogfile "connector" || error "Weston startup failed. Can not run $Xserver.
  Last lines of weston log:
$(tail "$Compositorlogfile")"
          Westonoutput="$(grep Output <$Compositorlogfile | grep connector | head -n1 | cut -d ' ' -f3 | rev | cut -c2- | rev)"
          verbose -d "Screen output for weston: $Westonoutput"
          kill $Compositorpid
          mkfile "$Compositorlogfile"
          mkfile "$Compositorpidfile"
          Compositorpid=""
        }
      }
    ;;
  esac

  # cookie authentication
  case $Xauthentication in
    yes)
      case $Xserver in
        --vcxsrv)  
          Line="${Xservercookie#$Winsubmount}"
          Xserveroptions="$Xserveroptions \\
  -auth '$(cut -c2 <<< "$Line"):$(cut -c3- <<< "$Line")'" 
        ;;
        *) Xserveroptions="$Xserveroptions \\
  -auth $Xservercookie" ;;
      esac
    ;;
    no) [ "$Xserver" = "--hostdisplay" ] || warning "Option --no-auth: SECURITY RISK!
  Allowing access to X server for everyone."
      Xserveroptions="$Xserveroptions \\
  -ac" ;;
  esac


  # create command to run X server
  case $Xserver in
    --xorg)
      Xserveroptions="$Xserveroptions \\
  +extension XFree86-DRI +extension XFree86-DGA +extension XFree86-VidModeExtension"
      Xserveroptions="$Xserveroptions \\
  -verbose"                  # make X verbose
      [ "$Tty" = "yes" ] && Xserveroptions="$Xserveroptions -keeptty"
      Xcommand="$(command -v Xorg) $Newdisplay vt$Newxvt \\
  $Xserveroptions"
    ;;

    --xpra) # To use xpra, Xdummy will run first. xpra server uses it later. Use Xvfb if available.
      command -v Xvfb >/dev/null && {
        Xcommand="$(command -v Xvfb) $Newdisplay -screen 0 ${Maxxaxis}x${Maxyaxis}x24 \\
  $Xserveroptions"
      } || {
        Xcommand="$Xorgwrapper $Newdisplay vt$Newxvt \\
  -config $Xdummyconf \\
  $Xserveroptions"
        note "Xvfb not found. Will try to use dummy video driver Xdummy.
  If you encounter xpra startup errors, please install 'Xvfb'."
      }
    ;;

    --xdummy)
      Xcommand="$Xorgwrapper $Newdisplay \\
  -config $Xdummyconf \\
  $Xserveroptions"
      [ "$Winsubsystem" ] || Xcommand="$Xcommand vt$Newxvt"
    ;;

    --xvfb)
      Xcommand="$(command -v Xvfb) $Newdisplay -screen 0 ${Screensize}x24 \\
  $Xserveroptions"   ### FIXME: hardcoded setting of depth 24. Could be better?
    ;;

    --xephyr)
      case $Fullscreen in
        yes) Xephyroptions="$Xephyroptions -fullscreen" ;;
        no)  for ((Count=0 ; Count<$Outputcount ; Count++)) ; do Xephyroptions="$Xephyroptions -screen $Screensize" ; done ;;
      esac
      #[ "$Xephyrglamor" = "yes" ] && Xephyroptions="$Xephyroptions -glamor"      # deprecated option '--glamor'
      Xcommand="$(command -v Xephyr) $Newdisplay $Xephyroptions \\
  $Xserveroptions"

      # Fallback: Xnest
      command -v Xephyr >/dev/null || {
        Xcommand="$(command -v Xnest) $Newdisplay -geometry $Screensize -scrns $Outputcount \\
  -name '$Imagename on $Newdisplay' \\
  $Xserveroptions "
        note "Xephyr not found. Fallback: using Xnest.
  Xnest is less stable and has less features than Xephyr.
  For example, it misses RandR and Composite extensions and fullscreen mode.
  It is recommended to install 'Xephyr'."
      }
    ;;

    --xwayland)
      Xcommand="$(command -v Xwayland) $Newdisplay \\
  $Xserveroptions"
      Newwaylandsocket="$Hostwaylandsocket"
    ;;

    --xpra-xwayland|--xdummy-xwayland)
      Xcommand="$(command -v Xwayland) $Newdisplay \\
  $Xserveroptions"
      [ "$Desktopmode" = "no" ] && [ "$Xserver" = "--xpra-xwayland" ] && Xcommand="$Xcommand \\
  -rootless"

      # Weston is needed for Xwayland if no Wayland is running already, and also
      # if option scale has a value smaller than 1 to provide a virtual display larger than monitor
      [ "$Hostwaylandsocket" ] && Needweston="no" || Needweston="yes"
      [ "1" = "$(awk -v a="${Scaling:-1}" 'BEGIN {print (a < 1)}')" ] && Needweston="yes"
      [ "$Needweston" = "yes" ] && {
        Newwaylandsocket="wayland-$Newdisplaynumber"
        [ "$Hostdisplay" ] && Westonoutput="X"
        echo "[output]" >> $Westonini
        case $Westonoutput in
          X|WL) echo "name=${Westonoutput}1" >> $Westonini ;;
          *)    echo "name=${Westonoutput}"  >> $Westonini ;;
        esac
        echo "mode=$Screensize" >> $Westonini
        [ -n "$Customwestonini" ] && Westonini="$Customwestonini"
        Compositorcommand="weston --socket=$Newwaylandsocket"
        case $Westonoutput in
          WL) Compositorcommand="$Compositorcommand --backend=wayland-backend.so" ;;
          X)  Compositorcommand="$Compositorcommand --backend=x11-backend.so" ;;
          *)
            case "$Tty" in
              yes) Compositorcommand="$Compositorcommand --backend=drm-backend.so" ;;
              no)  Compositorcommand="$Compositorcommand --backend=x11-backend.so" ;;
            esac
          ;;
        esac
        [ "$Xserver" = "--xpra-xwayland" ] && Compositorcommand="$Compositorcommand --fullscreen"
        [ -n "$Customwestonini" ] && Westonini="$Customwestonini"
        Compositorcommand="$Compositorcommand \\
  --config='$Westonini'"
      } || {
        Newwaylandsocket="$Hostwaylandsocket"
        Compositorcommand=""
      }
    ;;

    --weston|--weston-xwayland)
      [ "$Xserver" = "--weston-xwayland" ] && Xcommand="$(command -v Xwayland) $Newdisplay \\
  $Xserveroptions"
      [ "$Xserver" = "--weston" ]          && Sharewayland="yes"
      Newwaylandsocket="wayland-$Newdisplaynumber"
      Compositorcommand="weston --socket=$Newwaylandsocket"
      [ -n "$Westonoutput" ] && for ((Count=1 ; Count<=$Outputcount ; Count++)) ; do
        [ "$Westonoutput" = "WL" ] || [ "$Westonoutput" = "X" ] || {
          Count=""
          [ -z "$Screensize" ] && Screensize="preferred"
        }
        echo "[output]
name=$Westonoutput$Count
mode=$Screensize
" >> $Westonini
        [ "$Scaling" ]        && echo "scale=$Scaling"      >> $Westonini
        [ -n "$Rotation" ]    && echo "transform=$Rotation" >> $Westonini
        [ "$Count" ] || break
      done
      [ "$Fullscreen" = "yes" ] && Compositorcommand="$Compositorcommand --fullscreen"
      [ "$Outputcount" = "1" ]  || Compositorcommand="$Compositorcommand --output-count=$Outputcount"
      case $Westonoutput in
        WL) Compositorcommand="$Compositorcommand --backend=wayland-backend.so" ;;
        X)  Compositorcommand="$Compositorcommand --backend=x11-backend.so" ;;
        *)
          case "$Tty" in
            yes) Compositorcommand="$Compositorcommand --backend=drm-backend.so" ;;
            no)  Compositorcommand="$Compositorcommand --backend=x11-backend.so" ;;
          esac
        ;;
      esac
      [ -n "$Customwestonini" ] && Westonini="$Customwestonini"
      Compositorcommand="$Compositorcommand \\
  --config='$Westonini'"
    ;;

    --kwin-xwayland)
      Xcommand="$(command -v Xwayland) $Newdisplay \\
  $Xserveroptions"
      Newwaylandsocket="wayland-$Newdisplaynumber"
      Compositorcommand="kwin_wayland --xwayland --socket=$Newwaylandsocket --width=$Xaxis --height=$Yaxis --output-count=$Outputcount"
      [ "$Xkblayout" ] && Compositorcommand="KWIN_XKB_DEFAULT_KEYMAP=$Xkblayout $Compositorcommand"
      Compositorcommand="env QT_XKB_CONFIG_ROOT=/usr/share/X11/xkb $Compositorcommand"
      case $Tty in
        yes) Compositorcommand="$Compositorcommand --drm" ;;
        no)  Compositorcommand="$Compositorcommand --windowed" ;;
      esac
    ;;

    --kwin)
      Newwaylandsocket="wayland-$Newdisplaynumber"
      Sharewayland="yes"
      Compositorcommand="kwin_wayland --xwayland --socket=$Newwaylandsocket --width=$Xaxis --height=$Yaxis --output-count='$Outputcount'"
      #[ "$Xkblayout" ] && Compositorcommand="KWIN_XKB_DEFAULT_KEYMAP=$Xkblayout $Compositorcommand"
      Compositorcommand="env QT_XKB_CONFIG_ROOT=/usr/share/X11/xkb $Compositorcommand"
      case $Tty in
        yes) Compositorcommand="$Compositorcommand --drm" ;;
        no)  Compositorcommand="$Compositorcommand --windowed" ;;
      esac
    ;;

    --nxagent)
      Nxagentoptions="$Nxagentoptions \\
  -options $Cachefolder/nxagentoptions \\
  -norootlessexit -verbose -ac"
      case $Desktopmode in
        "yes") Nxagentoptions="$Nxagentoptions \\
  -D -name '$Imagename on $Newdisplay (shift+F11 toggles fullscreen)'" ;; # desktop mode,  similar to xephyr
        "no")  Nxagentoptions="$Nxagentoptions -R" ;; # rootless mode, similar to xpra
      esac
      export NXAGENT_KEYSTROKEFILE="$Cachefolder/nx_keys"
      Xcommand="$(command -v nxagent) $Newdisplay $Xserveroptions $Nxagentoptions \\
  -keystrokefile $NXAGENT_KEYSTROKEFILE"
#      Xcommand="$(echo $Xcommand | sed 's/+extension Composite.*//')"
      # create file for additional nxagent options
      Nxagentoptions="nx/nx"
      [ "$Shareclipboard" = "yes" ] && Nxagentoptions="$Nxagentoptions,clipboard=both" || Nxagentoptions="$Nxagentoptions,clipboard=none"
      [ "$Fullscreen" = "yes" ] && Nxagentoptions="$Nxagentoptions,fullscreen=1" || {
        [ -n "$Screensize" ] && Nxagentoptions="$Nxagentoptions,geometry=$Screensize"
      }
      # set keyboard layout
      case $Xkblayout in
        "") # --keymap not set? set layout from host.
          command -v setxkbmap >/dev/null && {
            Nxagentoptions=$Nxagentoptions,keyboard=$(setxkbmap -query | grep rules | rev | cut -d" " -f1 | rev)/$(setxkbmap -query | grep layout | rev | cut -d" " -f1 | rev)
          } || note "Could not check your keyboard layout due to missing setxkbmap
  If you get mismatching keys, please install setxkbmap."
        ;;
        *) # --keymap
          Nxagentoptions=$Nxagentoptions,keyboard="evdev/$Xkblayout"
        ;;
      esac
      Nxagentoptions="$Nxagentoptions$Newdisplay"
      mkfile "$Cachefolder/nxagentoptions"
      echo $Nxagentoptions >> "$Cachefolder/nxagentoptions"
      # workaround as nxagent ignores XAUTHORITY and fails to start if option -auth is given. Option -ac above complies "xhost +" and is disabled in xinitrc
      [ "$Xauthentication" = "yes" ] && {
        $Mksu "cp '$Hostxauthority' '$Xservercookie'"
        $Mksu "$Xauth -f '$Xclientcookie' add   $Newdisplay . $(mcookie)"
        $Mksu "$Xauth -f '$Xclientcookie' nlist $Newdisplay | $Xauth -f '$Xservercookie' nmerge -"
      }
      # fake NXclient
      export NX_CLIENT="$Cachefolder/nx_client"
      mkfile "$NX_CLIENT"
      echo '#! /bin/bash
# helper script to terminate nxagent.
# nxagent runs program noted in NX_CLIENT if window close button is pressed.
# (real nxclient does not exist)
echo "NXclient: $*" >> '$Xinitlogfile'
parsed=$(getopt --options="" --longoptions="parent:,display:,dialog:,caption:,window:,message:" -- "$@")
eval set -- $parsed
while [ -n "${1:-}" ] ; do
  case "${1:-}" in
    --dialog) dialog=${2:-} && shift ;;
    --display|--caption|--message) shift ;;
    --window) shift ;;
    --parent) pid=${2:-} && shift ;;
    --) ;;
  esac
  shift
done
case $dialog in
  pulldown) ;;
  yesnosuspend)
    kill $pid
    echo timetosaygoodbye >> '$Timetosaygoodbye'
  ;;
esac
' >> "$NX_CLIENT"
      $Mksu "chmod +x '$NX_CLIENT'"

      mkfile "$NXAGENT_KEYSTROKEFILE"
      echo '<!DOCTYPE NXKeystroke>
    <keystrokes>
    <keystroke action="fullscreen" AltMeta="0" Control="0" Shift="1" key="F11" />
    <keystroke action="fullscreen" AltMeta="1" Control="1" Shift="1" key="f" />
</keystrokes>' >> "$NXAGENT_KEYSTROKEFILE"
    ;;

    --vcxsrv|--xwin)
      [ "$Xserver" = "--vcxsrv" ] && Xcommand="$(escapestring "$Vcxsrvpath")/vcxsrv.exe :$Newdisplaynumber"
      [ "$Xserver" = "--xwin" ]   && Xcommand="$(command -v Xwin) :$Newdisplaynumber"
      [ "$Xserver" = "--xwin" ]   && Customenvironment="DISPLAY=$Hostip:$Newdisplaynumber
$Customenvironment"
      
      Xcommand="$Xcommand \\
  $Xserveroptions \\
 "
      case $Sharegpu in
        yes) Xcommand="$Xcommand -wgl +iglx" 
             Customenvironment="LIBGL_ALWAYS_INDIRECT=1
$Customenvironment" ;;
        no)  Xcommand="$Xcommand -nowgl -iglx" ;;
      esac
      case $Fullscreen in
        yes)
          Xcommand="$Xcommand -fullscreen"
        ;;
        no)
          Xcommand="$Xcommand -lesspointer"
          case $Desktopmode in
            yes)
              for ((Count=0 ; Count<$Outputcount ; Count++)); do 
                Xcommand="$Xcommand -screen $Count $Screensize"
              done
            ;;
            no) Xcommand="$Xcommand -multiwindow" ;;
          esac
        ;;
      esac
      case $Shareclipboard in
        yes) Xcommand="$Xcommand -clipboard" ;;
        no)  Xcommand="$Xcommand -noclipboard" ;;
      esac
    ;;

    --hostwayland) Newwaylandsocket="$Hostwaylandsocket" ;;
    --hostdisplay|--nothing) ;;
  esac

  [ "$Sharewayland" = "yes" ] && [ -z "$Newwaylandsocket" ] && note "No wayland socket to share" && Sharewayland="no"


  [ "$Xcommand" ] && verbose -d "X server command:
  $Xcommand"
  [ "$Compositorcommand" ] && verbose -d "Compositor command:
  $Compositorcommand"
}

{ #### part: create $Newxenv: Environment variables
  case $Xserver in
    --xpra|--xephyr|--xpra-xwayland|--weston-xwayland|--hostdisplay|--xorg|--xdummy|--xvfb|--xdummy-xwayland|--xwayland|--kwin-xwayland|--nxagent|--vcxsrv|--xwin)
      Newxenv="DISPLAY=$Newdisplay"
      [ "$Xauthentication" = "yes" ] && Newxenv="$Newxenv XAUTHORITY=$Xclientcookie"
      Newxenv="$Newxenv XSOCKET=$Newxsocket"
      Newxenv="$Newxenv $Xprashm"
    ;;
    --weston|--kwin|--hostwayland|--nothing)
      Newxenv="DISPLAY= XAUTHORITY="
      Newdisplay=""
      Newxsocket=""
      Xclientcookie=""
      Xservercookie=""
    ;;
  esac
  [ "$Sharewayland" = "yes" ] && {
    [ -n "$Newwaylandsocket" ]                                    &&  Newxenv="$Newxenv WAYLAND_DISPLAY=$Newwaylandsocket"
    [ -z "$Newwaylandsocket" ] && [ -n "$Hostwaylandsocket" ]     &&  Newxenv="$Newxenv WAYLAND_DISPLAY=$Hostwaylandsocket"
    [ -z "$Newwaylandsocket" ] && [ -z "$Hostwaylandsocket" ]     &&  { note "No wayland environment to share,
  neither from host nor from $Xserver (--sharewayland)"
      Sharewayland="no"
    }  ||  Newxenv="$Newxenv XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR"
  }
  [ "$Setwaylandenv" = "yes" ] && for Line in $Waylandtoolkitenv ; do Newxenv="$Newxenv $Line" ; done
  Newxenv="$Newxenv X11DOCKER_CACHE=$Cachefolder"

  # custom environment
  IFS=$'\n'
  for Line in $Customenvironment; do Newxenv="$Newxenv $Line" ; done
  IFS=$' \t\n'

  verbose "Environment variables:
  $Newxenv"
}

{ #### part: create shareclipboard script (option --clipboard)
  # use xclip or xsel to share text clipboard content between X servers.
  # xpra and nxagent have their own clipboard management.
  # only xpra supports image clips.
  [ "$Shareclipboard" = "yes" ] && case $Xserver in

    --nothing|--weston|--hostwayland|--kwin)
      warning "Option --clipboard is not supported for $Xserver.
  Fallback: Disabling option --clipboard."
      Shareclipboard="no"
    ;;
    --nxagent|--xpra|--xpra-xwayland|--vcxsrv|--xwin) ;; # have their own clipboard management, look at part "create command to start X server",

    --xephyr|--xorg|--xdummy|--xdummy-xwayland|--xvfb|--xwayland|--weston-xwayland)

      # check for either xclip or xsel
      command -v xclip >/dev/null && {
        Clipsend="xclip -selection clipboard -in"
        Clipreceive="xclip -selection clipboard -out"
      } || command -v xsel >/dev/null && {
        Clipsend="xsel --clipboard --input"
        Clipreceive="xsel --clipboard --output"
      } || {
        warning "Need either xclip or xsel for clipboard
  sharing with X server $Xserver.
  Fallback: Disabling option --clipboard."
        Shareclipboard="no"
      }

      echo "#! /bin/bash
# share clipboard between X servers $Hostdisplay and $Newdisplay

while [ ! -s "$Timetosaygoodbye" ] ; do
  # read content of clipboard of first X server
  D1CLIP=\"\$(env DISPLAY=$Hostdisplay XAUTHORITY=$Hostxauthority $Clipreceive)\"

  # check if clipboard of first X server has changed; if yes, send new content to second X server
  [ \"\$CLIP\" != \"\$D1CLIP\" ] && {
    CLIP=\"\$D1CLIP\"
    env DISPLAY=$Hostdisplay XAUTHORITY=$Hostxauthority $Clipreceive | env DISPLAY=$Newdisplay XAUTHORITY=$Xclientcookie $Clipsend
  }
  [ -z \"\$CLIP\" ] && CLIP=' '      # avoid empty string error

  # read content of clipboard of second X server
  D2CLIP=\"\$(env DISPLAY=$Newdisplay XAUTHORITY=$Xclientcookie $Clipreceive)\"

  # check if clipboard of second X server has changed; if yes, send new content to first X server
  [ \"\$CLIP\" != \"\$D2CLIP\" ] && {
    CLIP=\"\$D2CLIP\"
    env DISPLAY=$Newdisplay XAUTHORITY=$Xclientcookie $Clipreceive | env DISPLAY=$Hostdisplay XAUTHORITY=$Hostxauthority $Clipsend
  }
  [ -z \"\$CLIP\" ] && CLIP=' '      # avoid empty string error

  sleep 0.5                        # sleep a bit to avoid high cpu usage
done
" >> $Shareclipboardscript
    ;;
  esac
}

{ #### part: check password prompt frontend (pkexec, su, sudo, ...)
  # check if x11docker can run docker without prompting for password
  [ "$Passwordfrontend" = "none" ] && Passwordneeded="no"
  [ -z "$Passwordfrontend" ] && sudo -n env >/dev/null 2>&1 && Passwordfrontend="sudo" && Passwordneeded="no"
  [ -z "$Passwordfrontend" ] && $Dockerexe info >/dev/null 2>&1 && Passwordfrontend="none" && Passwordneeded="no"
  [ "$X11dockermode" = "exe" ] && Passwordneeded="no"

  # check sudo. Check is not reliable, compare https://unix.stackexchange.com/questions/383918/su-or-sudo-how-to-know-which-one-will-work
  ### FIXME: just guessing that members of group sudo or wheel are allowed to run commands docker and env as root
  [ -z "$Passwordfrontend" ] && { sudo -ln $Dockerexe >/dev/null 2>&1  ||  id | grep -q '(sudo)'  ||  id | grep -q '(wheel)' ; } && command -v sudo >/dev/null && {
    [ -z "$Hostdisplay$Newdisplay" ] && Passwordfrontend="sudo"
    sudo -ln env >/dev/null 2>&1  ||  id | grep -q '(sudo)'  ||  id | grep -q '(wheel)'  && {
      [ -z "$Passwordfrontend" ] && command -v gksudo  >/dev/null && Passwordfrontend="gksudo"
      [ -z "$Passwordfrontend" ] && command -v lxsudo  >/dev/null && Passwordfrontend="lxsudo"
      [ -z "$Passwordfrontend" ] && command -v kdesudo >/dev/null && Passwordfrontend="kdesudo"
    }
    [ -z "$Passwordfrontend" ] && Passwordfrontend="sudo"
  }

  # check su
  [ -n "$Hostdisplay$Newdisplay" ] && {
    [ -z "$Passwordfrontend" ] && command -v gksu  >/dev/null && Passwordfrontend="gksu"
    [ -z "$Passwordfrontend" ] && command -v lxsu  >/dev/null && Passwordfrontend="lxsu"
    [ -z "$Passwordfrontend" ] && command -v kdesu >/dev/null && Passwordfrontend="kdesu"
    [ -z "$Passwordfrontend" ] && command -v beesu >/dev/null && Passwordfrontend="beesu"
  }
  [ -z "$Passwordfrontend" ] && Passwordfrontend="su" # default if everything else fails

  # Passwordcommand: prefix to start dockerrc. Sudo: prefix to start docker in dockerrc
  case $Passwordfrontend in
    pkexec|"") Passwordcommand="bash -c"                                                 ; Passwordterminal="bash -c" ;;
    su)        Passwordcommand="su -c"                                                   ;;
    sudo)      Passwordcommand="bash -c"                                                 ; Sudo="sudo -E " ;;
    gksu)      Passwordcommand="gksu    --message 'x11docker $Imagename' --disable-grab" ; Passwordterminal="bash -c" ;;
    gksudo)    Passwordcommand="gksudo  --message 'x11docker $Imagename' --disable-grab" ; Passwordterminal="bash -c" ;;
    lxsu)      Passwordcommand="lxsu"                                                    ; Passwordterminal="bash -c" ;;
    lxsudo)    Passwordcommand="lxsudo"                                                  ; Passwordterminal="bash -c" ;;
    kdesu)     Passwordcommand="kdesu -c"                                                ; Passwordterminal="bash -c" ;;
    kdesudo)   Passwordcommand="kdesudo --comment 'x11docker $Imagename'"                ; Passwordterminal="bash -c" ;;
    beesu)     Passwordcommand="beesu -c"                                                ; Passwordterminal="bash -c" ;;
    none)      Passwordcommand="bash -c"                                                 ; Passwordterminal="bash -c" ;;
    *) warning "Unknown password prompt '$Passwordfrontend' (option --pw).
  Possible: su sudo gksu gksudo lxsu lxsudo kdesu kdesudo beesu pkexec none"
               Passwordcommand="$Passwordfrontend"                                       ; Passwordterminal="bash -c" ;;
  esac
  [ "$Passwordneeded" = "yes" ] && {
    command -v $(echo $Passwordcommand|cut -d' ' -f1) >/dev/null || warning "Password prompt frontend $(echo $Passwordcommand|cut -d' ' -f1) not found.
  Fallback: using no password prompt (--pw=none)." 
               Passwordcommand="bash -c" ; Passwordfrontend="none" ; Passwordneeded="no" ; Passwordterminal="bash -c"
  }
}

{ #### part: check terminal for password prompt of su or sudo and for 'docker pull'
  # $Passwordterminal:  To prompt for su or sudo password
  # $Pullterminal:      To show output of "docker pull"

  # Not working: pangoterm lilyterm fbterm
  # Makes problems if X and Wayland are independently available at same time: xfce4-terminal
  # Works, but does not appear: 'guake -te'

  Terminallist="xterm lxterm lxterminal stterm sakura termit pterm terminator terminology Eterm konsole qterminal gnome-terminal mate-terminal mrxvt rxvt xvt kterm mlterm xfce4-terminal mintty NOLUCK"
  [ -z "$Hostdisplay$Newdisplay" ] && {
    case $Xserver in
      --weston|--hostwayland)  Terminallist="konsole qterminal gnome-terminal NOLUCK" ;;
      --kwin)                  Terminallist="konsole NOLUCK" ;;
      --nothing)               Terminallist="bash NOLUCK" ;;
      *)                       Terminallist="konsole NOLUCK" ;;
    esac
  }

  for Pullterminal in $Terminallist ; do command -v $Pullterminal >/dev/null && break ; done
  [ "$Pullterminal" = "NOLUCK" ] && warning "Can not find a terminal emulator that works for
  option $Xserver. Please install one of:
  ${Terminallist%"NOLUCK"}"
  
  [ -z "$Hostdisplay" ] && [ -n "$Newwaylandsocket" ] && {
    case $Pullterminal in
      qterminal) Pullterminal="env QT_QPA_PLATFORM=wayland $Pullterminal" ;;
      konsole) Pullterminal="env QT_QPA_PLATFORM=wayland dbus-launch $Pullterminal --nofork" ;;
    esac
  }
  case $Pullterminal in
    xfce4-terminal) Pullterminal="$Pullterminal --disable-server -x" ;;
    gnome-terminal|mate-terminal) Pullterminal="dbus-launch $Pullterminal -x" ;;
    terminator)     Pullterminal="dbus-launch $Pullterminal --no-dbus -x" ;;
    konsole)        Pullterminal="dbus-launch $Pullterminal --nofork -e" ;;
    bash)           Pullterminal="bash -c" ;;
    *)              Pullterminal="$Pullterminal -e" ;;
  esac
  [ -z "$Passwordterminal" ] && Passwordterminal="$Pullterminal"
  Anyterminal="$Pullterminal"

  [ -z "$Hostdisplay$Newdisplay" ] && {
    case $Xserver in
      --weston|--kwin|--hostwayland) ;;
      *) Passwordterminal="bash -c" ; Pullterminal="" ;;
    esac
  }
}

{ #### part: set up pipes and fifo
  # file descriptors in use:
  # &0  stdin                 --stdin with catstdin
  # &1  stdout
  # &2  stderr
  # &3  stderr                for warnings and notes, with --silent redirected to /dev/null
  # &4  stderr                for --stderr
  # &5  (not in use)
  # &6  $Messagefifo          for messages to watchmessagefifo()
  # &7  (not in use)
  # &8  $Timetosaygoodbyefifo for saygoodbye() and waitfortheend()
  # &9  $Watchpidfifo         for watchpidlist()

  # redirect stdin to named pipe. Named pipe is shared with container and used as stdin of image command in container.CMD.sh
  [ "$Forwardstdin" = "yes" ] && {
    Cmdstdinfile="$Sharefolder/$Cmdstdinfile"
    case $Winsubsystem in
      "") $Mksu "mkfifo $Cmdstdinfile" ;;
      *)  mkfile $Cmdstdinfile ;;
    esac
    exec 7<>$Cmdstdinfile 
    cat <&0 >&7 & storepid $! catstdin
#    cat <&0 >>$Cmdstdinfile & storepid $! catstdin
  }
  
  case $Winsubsystem in
    MSYS2|CYGWIN|WSL)
      Watchpidfifo="$Cachefolder/$Watchpidfifo"                 && mkfile $Watchpidfifo
      Messagefifo="$Sharefolder/$Messagefifo"                   && mkfile $Messagefifo && chmod 666 $Messagefifo
      Timetosaygoodbyefifo="$Sharefolder/$Timetosaygoodbyefifo" && mkfile $Timetosaygoodbyefifo && chmod 666 $Timetosaygoodbyefifo
    ;;
    "")
      Watchpidfifo="$Cachefolder/$Watchpidfifo"                 && $Mksu "mkfifo $Watchpidfifo"
      Messagefifo="$Sharefolder/$Messagefifo"                   && $Mksu "mkfifo $Messagefifo && chmod 666 $Messagefifo"
      Timetosaygoodbyefifo="$Sharefolder/$Timetosaygoodbyefifo" && $Mksu "mkfifo $Timetosaygoodbyefifo"
    ;;
  esac
  
  # used by waitfortheend()
  exec 8<>$Timetosaygoodbyefifo
  
  # start watching important pids, e.g. xinit, container.
  exec 9<>$Watchpidfifo
  watchpidlist & storepid $! watchpidlist
  
  # start watching for messages out of container or dockerrc
  exec 6<>$Messagefifo
  watchmessagefifo & storepid $! watchmessagefifo
}

{ #### part: check container user and shared home folder
  ## check container user
  [ -z "$Benutzer" ] && Benutzer=$Hostuser                 # default: containeruser = hostuser. can be changed with --user
  [ -n "$Benutzer" ] && echo $Benutzer | grep -q ':' && {  # option --user can specify a group/gid after :
    Benutzergid="$(echo $Benutzer | cut -d: -f2)"
    Benutzer="$(echo $Benutzer | cut -d: -f1)"
  }
  [ -n "$(getent passwd $Benutzer)" ] && {                 # user exists on host
    Benutzer=$(getent passwd $Benutzer | cut -d: -f1)      # can be name or uid -> now name
    Benutzeruid=$(getent passwd $Benutzer | cut -d: -f3)
    [ -z "$Benutzergid" ] && Benutzergid=$(getent passwd $Benutzer | cut -d: -f4)
    Benutzerhome=$(getent passwd $Benutzer | cut -d: -f6)
  } || {                                                   # user does not exist on host
    [[ $Benutzer =~ ^[0-9]+$ ]] || error "Unknown user or invalid user number '$Benutzer' for option --user."  # virtual users can only be specified as uid
    Benutzeruid=$Benutzer
    Benutzer="unknown$Benutzer"
    [ -z "$Benutzergid" ] && Benutzergid=100
    Benutzerhome="/fakehome/$Benutzer"
    [ -z "$Benutzerhosthomefolder" ] && [ "$Benutzerhosthome" = "yes" ] && {
      warning "Will not create a persistent home folder on host
  for a non-existing user. (Instead, you can specify --homedir to a location
  where user '$Benutzer' has write access.)
  Fallback: Disabling option --home, not creating a persistent home folder."
      Benutzerhosthome="no"
    }
  }
  Benutzergruppe="$(getent group $Benutzergid | cut -d: -f1 || echo group_$Benutzer)"

  [ "$Benutzer" = "$Hostuser" ] && Mksubenutzer=$Mksu || {
    Mksubenutzer="su $Benutzer -c"
    [ "$X11dockermode" = "exe" ] && {
      [ "$Startuser" != "root" ] && error "Must run as root to change user for option --exe"
      id $Benutzer >/dev/null 2>&1 || error "Option --exe supports real users only.
  Unknpwn user '$Benutzer' set with --user is not possible on host."
    }
  }

  ## option '--home':    share folder ~/.local/share/x11docker/imagename with created container as its home directory
  ## option '--homedir': share custom host folder as home
  
  # base home folder
  [ "$Homebasefolder" ] && {
    Homebasefolder="$Winsubmount$(convertpath "$Homebasefolder" | cut -d "'" -f2)"
    [ -e "$Homebasefolder" ] || {
      warning "Option --homebasedir: Specified path does not exist:
  $Homebasefolder
  Fallback: Using default home base directory."
      Homebasefolder=""
    }
  }
  [ "$Homebasefolder" ] || case $Winsubsystem in
    "") Homebasefolder="$Benutzerhome/.local/share/x11docker" ;;
    *)  Homebasefolder="$Winsubmount$(convertpath "$(cmd.exe /C "echo %userprofile%" | rmcr)" | cut -d"'" -f2)/x11docker/home" ;;
  esac
  
  case $Benutzerhosthome in
    yes)
      # if no home folder on host is specified (--homedir), create a standard one in ~/.local/share/x11docker
      [ -z "$Benutzerhosthomefolder" ] && Benutzerhosthomefolder="$Homebasefolder/$Imagenametr$Hostexebasename"
      [ -d "$Benutzerhosthomefolder" ] || {
        [ "$Startuser" = "root" ] && su $Benutzer -c "mkdir -p '$Benutzerhosthomefolder'"
        [ "$Benutzer" = "$Hostuser" ] && $Mksu "mkdir -p '$Benutzerhosthomefolder'" && {
          # create symbolic link to ~/x11docker
          echo "$Benutzerhosthomefolder" | grep -q .local/share/x11docker && [ ! -e "$Benutzerhome/x11docker" ] && $Mksu "ln -s '$Homebasefolder' '$Benutzerhome/x11docker'"
          :
        } || {
          # errors can occur if specifying a user with --user different from current user
          error "Can not create persistent home folder for
  user '$Benutzer' on host (option --home or --homedir).
  Four possibilities to solve issue:
  1.) Create folder with write access for user '$Benutzer'
  $Benutzerhosthomefolder
  2.) Run x11docker one time as user '$Benutzer'.
  3.) Run x11docker one time as user 'root'.
  4.) Use option --homedir=DIR with DIR pointing to a writeable folder."
        }
      }
      writeaccess $Benutzeruid "$Benutzerhosthomefolder" || warning "User '$Benutzer' seems to have no write access to
  $Benutzerhosthomefolder."
      verbose "Sharing directory $Benutzerhosthomefolder
  with container as its home directory $Benutzerhome"
    ;;
    no) Benutzerhome="/fakehome/$Benutzer" ;;
  esac

  # create entry for /etc/passwd
  Benutzerpasswdentry="$Benutzer:x:$Benutzeruid:$Benutzergid:$Benutzer,,,:$Benutzerhome:/bin/sh"
}

{ #### part: create init service files (options --systemd, --runit, --openrc) and check tini binary (--tini).

  # enable dbus
  case $Initsystem in
    systemd|sysvinit|openrc|runit) Dbusdaemon="yes" ;;
  esac

  # Check docker-init / tini-static

  case $Initsystem in
    none) ;;
    tini)
      Tinibinary="$(command -v docker-init)"
      [ -z "$Tinibinary" ]                                      && Tinibinary="/snap/docker/current/bin/docker-init"
      [ -e "$Tinibinary" ]                                      || Tinibinary="/snap/docker/current/usr/bin/docker-init"
      [ -e "/usr/local/share/x11docker/tini-static" ]           && Tinibinary="/usr/local/share/x11docker/tini-static"
      [ -e "$Hostuserhome/.local/share/x11docker/tini-static" ] && Tinibinary="$Hostuserhome/.local/share/x11docker/tini-static"
      Tinibinary="$(realpath "$Tinibinary" 2>/dev/null)"
      [ -e "$Tinibinary" ] || Tinibinary=""
      [ "$Tinibinary" ] && {
        [ -x "$Tinibinary" ] || {
          chmod +x "$Tinibinary" || {
            warning "Your tini binary is not executeable. Please run
    chmod +x $Tinibinary"
            Initsystem="none"
          }
        }
      } || {
        Initsystem="none"
        note "Did not find container init system 'tini'.
  This is a bug in your distributions docker package.
  Normally, docker provides init system tini as '/usr/bin/docker-init'.

  x11docker uses tini for clean process handling and fast container shutdown.
  To provide tini yourself, please download tini-static:
    https://github.com/krallin/tini/releases/download/v0.18.0/tini-static
  Store it in one of:
    $Hostuserhome/.local/share/x11docker/
    /usr/local/share/x11docker/"
      }
      verbose "Found tini binary: ${Tinibinary:-(none)}"
    ;;

    systemd)
      warning "Option --systemd degrades container isolation.
  It allows some docker container capabilities (nearly like --cap-default).
  It shares access to host cgroups in /sys/fs/cgroup."

      Systemdtarget=$Cachefolder/x11docker.target             && mkfile $Systemdtarget
      Systemdstartcmd=$Cachefolder/x11docker-startcmd.service && mkfile $Systemdstartcmd
      Systemdwatch=$Cachefolder/x11docker-watch.service       && mkfile $Systemdwatch
      Systemdjournal=$Cachefolder/x11docker-journal.service   && mkfile $Systemdjournal
      Journallogfile=$Sharefolder/journalctl                  && mkfile $Journallogfile
      Systemdenvironment=$Cachefolder/systemd.env.conf        && mkfile $Systemdenvironment

      echo "[Unit]
Description=x11docker target
Wants=multi-user.target
After=multi-user.target
[Install]
Also=x11docker-startcmd.service
Also=x11docker-watch.service
Also=x11docker-journal.service
" >> $Systemdtarget

      echo "[Unit]
Description=x11docker start CMD service
Wants=multi-user.target
After=multi-user.target
Wants=x11docker-watch.service
Wants=x11docker-journal.service
Wants=dbus.service
[Service]
Type=simple
#User=$Benutzer # disabled because it does not invoke logind
#ExecStart=/bin/sh $Cshare/container.CMD.sh
ExecStart=/bin/su - -s /bin/sh $Benutzer $Cshare/container.CMD.sh
[Install]
WantedBy=x11docker.target
WantedBy=multi-user.target
" >> $Systemdstartcmd

      echo "[Unit]
Description=x11docker watch service
[Service]
Type=simple
ExecStart=/bin/sh -c 'while sleep 1; do systemctl is-active x11docker-startcmd >/dev/null || { echo timetosaygoodbye >>$Cshare/timetosaygoodbye ; systemctl halt ; } ; [ -s $Cshare/timetosaygoodbye ] && systemctl halt ; done'
[Install]
WantedBy=x11docker.target
" >> $Systemdwatch

      echo "[Unit]
Description=x11docker journal log service
[Service]
Type=simple
ExecStart=/bin/sh -c '/bin/journalctl --follow --no-tail --merge >> $Cshare/journalctl 2>&1'
[Install]
WantedBy=x11docker.target
" >> $Systemdjournal

      echo "[Manager]
DefaultEnvironment=DISPLAY=$Newdisplay XAUTHORITY=$Cshare/Xclientcookie $(IFS=$'\n' ; for Line in $Customenvironment ; do echo -n "$Line " ; done)
" >> $Systemdenvironment
    ;;

    runit)
      warning "Option --runit slightly degrades container isolation.
  Beside some user switching capabilities x11docker would disable otherwise
  it adds capability SYS_BOOT."
    ;;

    openrc)
      warning "Option --openrc slightly degrades container isolation.
  Beside some user switching capabilities x11docker would disable otherwise
  it adds capability SYS_BOOT."
    ;;

    sysvinit)
      warning "Option --sysvinit slightly degrades container isolation.
  Beside some user switching capabilities x11docker would disable otherwise
  it adds capability SYS_BOOT."
    ;;
  esac
}

{ #### part: create command to run docker
  case $X11dockermode in
    exe) Dockercommand="# dontrundocker"  ;;
    run) Dockercommand="$Dockerexe run -d --tty"
      [ "$Preservecachefiles" = "no" ] && Dockercommand="$Dockercommand --rm"

      [ -z "$Containername" ] && Containername="x11docker_X${Newdisplaynumber}_${Mycookie}_$Imagenametr"
      Dockercommand="$Dockercommand --name=$Containername"
      verbose "Container name: $Containername"

      [ "$Benutzeruid" = "0" ]     && Sudouser="yes"
      [ "$Sudouser" = "yes" ]      && Adminusercaps="yes"
      [ "$Dbusdaemon" = "yes" ]    && {
        case $Sharewayland in
          yes) Switchcontaineruser="yes" ;;
          no)  Switchcontainerusercaps="yes" ;;
        esac
      }
      [ "$Sharecgroup" = "yes" ] && Switchcontaineruser="yes" # needed for elogind

      case $Initsystem in
        none|tini)
          case $Switchcontaineruser in
            no) Dockercommand="$Dockercommand \\
  --user=$Benutzeruid:$Benutzergid --env USER=$Benutzer" ;;
            yes) Dockercommand="$Dockercommand \\
  --user=root --env USER=root" ;;
          esac
        ;;
        systemd|runit|openrc|sysvinit)
          Dockercommand="$Dockercommand \\
  --user=root" ;;
      esac

      # Disable user namespacing if host home folder is in use. Files need same UID/GID.
      [ "$Benutzerhosthome" = "yes" ] && Dockercommand="$Dockercommand \\
  --userns=host"

      [ "$Capdropall" = "yes" ] && Dockercommand="$Dockercommand \\
  --cap-drop ALL"

      # option --sys-admin (deprecated)
      [ "$Capsysadmin" = "yes" ] && Dockercommand="$Dockercommand \\
  --cap-add SYS_ADMIN"

      case $Initsystem in
        none) ;;
        tini) Dockercommand="$Dockercommand \\
  --volume $Winsubpath$Tinibinary:$Cshare/tini:ro" ;;
        systemd)
          Switchcontaineruser="yes"
          Sharecgroup="yes"
          Dockercommand="$Dockercommand \\
  --stop-signal SIGRTMIN+3 \\
  --cap-add FSETID      --cap-add FOWNER  --cap-add SETPCAP \\
  --cap-add SYS_BOOT \\
  -v $Systemdtarget:/etc/systemd/system/x11docker.target:ro \\
  -v $Systemdstartcmd:/etc/systemd/system/x11docker-startcmd.service:ro \\
  -v $Systemdwatch:/etc/systemd/system/x11docker-watch.service:ro \\
  -v $Systemdjournal:/etc/systemd/system/x11docker-journal.service \\
  -v $Systemdenvironment:/etc/systemd/system.conf.d/x11docker.conf"
        ;;

        runit)
          Switchcontaineruser="yes"
          Dockercommand="$Dockercommand \\
  --stop-signal HUP     --env VIRTUALIZATION=docker \\
  --cap-add SYS_BOOT    --cap-add KILL"
        ;;

        openrc)
          Switchcontaineruser="yes"
          Dockercommand="$Dockercommand \\
  --cap-add SYS_BOOT    --cap-add KILL"
        ;;

        sysvinit)
          Switchcontaineruser="yes"
          Dockercommand="$Dockercommand \\
  --stop-signal INT \\
  --cap-add SYS_BOOT    --cap-add KILL"
        ;;
      esac

      [ "$Switchcontaineruser" = "yes" ] && Switchcontainerusercaps="yes"
      case "$Capdropall" in
        "yes")
          [ "$Adminusercaps" = "yes" ] && {
            Switchcontainerusercaps="yes"
            Nonewprivileges="no"
            Dockercommand="$Dockercommand \\
  --cap-add CHOWN       --cap-add KILL\\
  --cap-add FSETID      --cap-add FOWNER  --cap-add SETPCAP"
          }
          [ "$Switchcontainerusercaps" = "yes" ] && {
            Dockercommand="$Dockercommand \\
  --cap-add SETUID      --cap-add SETGID  --cap-add DAC_OVERRIDE\\
  --cap-add AUDIT_WRITE"
          }
          # option --dbusdaemon: dbus needs CHOWN for XDG_RUNTIME_DIR
          [ "$Dbusdaemon" = "yes" ] && [ "$Adminusercaps" = "no" ] && Dockercommand="$Dockercommand \\
  --cap-add CHOWN"
        ;;
        no) Nonewprivileges="no" ;;
      esac

      [ "$Nonewprivileges" = "yes" ] && Dockercommand="$Dockercommand \\
  --security-opt no-new-privileges"

      # SELinux restrictions for containers must be disabled to allow access to X socket. Flags z or Z do not help.
      Dockercommand="$Dockercommand \\
  --security-opt label=type:container_runtime_t"

      # option --sharecgroup
      [ "$Sharecgroup" = "yes" ] && Dockercommand="$Dockercommand \\
  -v /sys/fs/cgroup:/sys/fs/cgroup:ro"
  
      # Add video group for GPU access, needed by some systems
      # Add audio group for ALSA
      # Does only have real effect if /dev/dri or /dev/snd is shared
      # Use GID instead of group name as they can differ from container GIDs
      # entries in /etc/group are not regarded without user switching in container
      [ "$Switchcontaineruser" = "no" ] && {
        [ "$Hostgidaudio" ] && Dockercommand="$Dockercommand \\
  --group-add $Hostgidaudio"
        [ "$Hostgidvideo" ] && Dockercommand="$Dockercommand \\
  --group-add $Hostgidvideo"
        for Line in $Groupadd; do          ### FIXME: should compare GIDs from host and container
          Dockercommand="$Dockercommand \\
  --group-add $Line"
        done
      }

      # Needed especially for --systemd and --dbus-daemon
      Dockercommand="$Dockercommand \\
  --tmpfs /run --tmpfs /run/lock"
  
      # entrypoint is checked in dockerrc
      Dockercommand="$Dockercommand \\
  --entrypoint=env"

      # At least OpenRC and systemd regard this hint
      Dockercommand="$Dockercommand \\
  --env container=docker"

      # shared host folders
      Dockercommand="$Dockercommand \\
  -v $(convertpath "$Sharefolder" | cut -d: -f1):$Cshare:rw"
  
      # --home, --homedir
      [ "$Benutzerhosthome" = "yes" ] && [ -n "$Benutzerhosthomefolder" ] && Dockercommand="$Dockercommand \\
  -v $(convertpath "$Benutzerhosthomefolder" | cut -d: -f1):'$Benutzerhome':rw"
  
      # --sharedir
      for ((Count=1 ; Count<=$Sharevolumescount ; Count++)) ; do
        case "${Sharevolumes[$Count]}" in
          "$Benutzerhome")  Dockercommand="$Dockercommand \\
  -v $(convertpath "$Benutzerhome" | cut -d: -f1):'$Benutzerhome/$(basename $Benutzerhome)':rw" ;;
          *) Dockercommand="$Dockercommand \\
  -v $(convertpath "${Sharevolumes[$Count]}"):rw" ;;
        esac
      done

      case $Xserver in
        --nothing) ;;
        --weston|--hostwayland|--kwin)
          Dockercommand="$Dockercommand \\
  -e WAYLAND_DISPLAY=$Newwaylandsocket -e XDG_RUNTIME_DIR=/tmp/XDG_RUNTIME_DIR"
        ;;
        *)
          # not really needed here as vars are set in container.CMD.sh
          # but useful for custom access with docker exec
          Dockercommand="$Dockercommand \\
  -e DISPLAY=$Newdisplay -e XAUTHORITY=$Cshare/Xclientcookie"
          # X socket will be softlinked to /tmp/.X11-unix in container.CMD.sh
          [ "$Newxsocket" ] && Dockercommand="$Dockercommand \\
  -v $(convertpath "$Newxsocket" | cut -d: -f1):/X$Newdisplaynumber:rw"
        ;;
      esac
      # Wayland socket will be softlinked to XDG_RUNTIME_DIR in container.CMD.sh
      [ "$Sharewayland" = "yes" ] && Dockercommand="$Dockercommand \\
  -v $XDG_RUNTIME_DIR/$Newwaylandsocket:/$Newwaylandsocket:rw"
      ## option --gpu : share graphics adapter device files
      [ "$Sharegpu" = "yes" ] && {
        while read -r Line ; do
          Dockercommand="$Dockercommand \\
  --device=$Line:$Line:rw \\
  -v $Line:$Line:rw"
        done < <(find /dev/dri /dev/nvidia* /dev/vga_arbiter -maxdepth 0 2>/dev/null ||:)
        [ "$Nvidiadriver" ] && {
          Dockercommand="$Dockercommand \\
  -v $Nvidiadriver:$Cshare/NVIDIA-$Nvidiaversion.run:ro"
          [ "$Capdropall" = "yes" ] && [ "$Adminusercaps" = "no" ] && Dockercommand="$Dockercommand \\
  --cap-add SETUID      --cap-add SETGID  --cap-add DAC_OVERRIDE\\
  --cap-add CHOWN       --cap-add FOWNER"
        }
      }

      ## options --hostipc and --hostnet
      [ "$Sharehostipc" = "yes" ]      && Dockercommand="$Dockercommand \\
  --ipc=host"
      [ "$Sharehostnet" = "yes" ]      && Dockercommand="$Dockercommand \\
  --net=host"
      ## option --no-internet
      [ "$Internetaccess" = "no" ]     && Dockercommand="$Dockercommand \\
  --net=none"
      ## option --alsa
      [ "$Alsa" = "yes" ]              && Dockercommand="$Dockercommand \\
  --device=/dev/snd:/dev/snd:rw -v /dev/snd:/dev/snd:rw"
      ## option --pulseaudio
      [ "$Pulseaudiomode" = "socket" ] && Dockercommand="$Dockercommand \\
  -v $Cachefolder/pulseclient.conf:/etc/pulse/client.conf:ro"
      ## option --workdir or /tmp
      Dockercommand="$Dockercommand \\
  --workdir $Workdir"
  
      # option --env: add custom environment. Only needed here for possible 'docker exec'. Otherwise set in container.CMD.sh
      IFS=$'\n'
      for Line in $Customenvironment ; do
        Dockercommand="$Dockercommand \\
  --env $Line"
      done
      IFS=$' \t\n'

      # add custom docker arguments, imagename and imagecommand
      [ "$Customdockeroptions" ] && Dockercommand="$Dockercommand \\
  $Customdockeroptions"
      Dockercommand="$Dockercommand \\
  --"
      case $Switchcontaineruser in
        no)       Dockercommand="$Dockercommand $Imagename /bin/sh - $Cshare/container.CMD.sh" ;;   # dockerrc runs container.rootsetup.sh with 'docker exec'
        yes)      
          case $Initsystem in
            tini) Dockercommand="$Dockercommand $Imagename $Cshare/tini -- /bin/sh - $Cshare/container.rootsetup.sh" ;;  # container.rootsetup.sh runs container.CMD.sh
            *)    Dockercommand="$Dockercommand $Imagename /bin/sh - $Cshare/container.rootsetup.sh" ;;  # container.rootsetup.sh runs container.CMD.sh
          esac
        ;;
      esac

      verbose -d "docker command:
  $Dockercommand"
    ;;
  esac
}

{ #### part: create dockerrc: This script runs as root (or member of group docker) on host
  # create container.CMD.sh -> runs as unprivileged user in container
  # check and set up cgroup on host for systemd or elogind
  # run docker

  echo "#! /bin/bash"

  declare -f mkfile
  declare -f rocknroll
  declare -f waitforfilecreation
  declare -f escapestring rmcr
  echo "Hostuser=$Hostuser"
  echo "Hostusergid=$Hostusergid"
  echo "Timetosaygoodbye=$Timetosaygoodbye"
  echo "$Messagefifofuncs"
  echo "Messagefile=$Messagefifo"
  echo ""
  echo "verbose -d 'Running dockerrc'"
  [ "$Debugmode" = "yes" ] && {
    #echo "PS4='$DebugPS4'"
    echo "PS4='+ dockerrc: \$(date +%S+%3N) '"
    #echo "set -x"
    declare -f traperror | sed 's/Command/dockerrc: Command/'
    echo "set -Eu"
    echo "trap 'traperror \$? \$LINENO \$BASH_LINENO \"\$BASH_COMMAND\" \$(printf \"::%s\" \${FUNCNAME[@]})'  ERR"
  }

  echo "Imagename=\"$Imagename\""
  echo "Imagecommand=\"$Imagecommand\""
  echo ""
  
  [ "$Winsubsystem" ] && echo 'export PATH="'$Winsubmount'/c/Program Files/docker:'$Winsubmount'/c/Program Files/Docker/Docker/resources/bin:$PATH"'

  echo "# check whether docker daemon is running and refresh images.list for x11docker-gui"
  echo "mkfile $Cachebasefolder/x11docker-gui/images.list"
  echo "$Dockerexe images --format '{{.Repository}}:{{.Tag}}' >>$Cachefolder/images.list 2>>$Containerlogfile  || {
    rmcr '$Containerlogfile'
    error \"Calling docker daemon failed.
  Is docker daemon running at all?
  Try to start docker daemon with:   systemctl start docker
  Last lines of log:
\$(tail $Containerlogfile)\"
}"
  echo "rmcr $Cachefolder/images.list"
  echo "while read -r Line ; do"
  echo '  grep -q "<none>" <<<$Line || echo $Line >> '$Cachebasefolder/x11docker-gui/images.list
  echo "done < <(sort < $Cachefolder/images.list)"
  echo ""

  echo "# check if image is available locally"
  echo "$Dockerexe inspect --type=image $Imagename >/dev/null 2>&1 || {"
  [ -n "$Hostxenv" ]                      && echo "  export $Hostxenv"
  [ -n "$Newxenv" ] && [ "$Tty" = "yes" ] && echo "  export $Newxenv"
  [ "$Xserver" = "--xorg" ]               && echo "  export $Newxenv"
  [ "$Pullterminal" = "$Passwordterminal" ] && [ "$Passwordneeded" = "yes" ] && Pullterminal=""
  echo "  $Pullterminal /bin/bash $Pullrc"
  echo "  waitforfilecreation $Cachefolder/pullready infinity"
  echo "  $Dockerexe inspect --type=image $Imagename 2>&1 | rmcr >>$Containerlogfile || error \"Image '$Imagename' not found locally and not pulled from docker hub.

  Last lines of log:
\$(tail $Containerlogfile)\""
  echo "}"
  echo "# check CMD"
  echo "[ -z \"\$Imagecommand\" ] && {"
  echo "  # extract image command from image if not given on cli"
  echo "  Imagecommand=\"\$($Dockerexe inspect --format='{{.Config.Cmd}}' $Imagename | rmcr)\""
  echo "  Imagecommand=\"\${Imagecommand#[}\""
  echo "  Imagecommand=\"\${Imagecommand%]}\""
  echo "  Imagecommand=\"\${Imagecommand#/bin/sh -c }\""
  echo "}"

  [ "$Tinibinary" ] && echo "Tini=\"$Cshare/tini --\"" || echo "Tini="
  echo "Exec=exec"
  case $Noentrypoint in
    yes) echo "Entrypoint=" ;;
    no)
      echo "# check ENTRYPOINT"
      echo "Entrypoint=\$($Dockerexe inspect --format='{{.Config.Entrypoint}}' $Imagename | rmcr)"
      echo "Entrypoint=\${Entrypoint#[}"
      echo "Entrypoint=\${Entrypoint#/bin/sh -c }"
      echo "Entrypoint=\${Entrypoint%]}"
      case $Initsystem in
        systemd|sysvinit|runit|openrc)
          echo "echo \"\$Entrypoint\" | grep -qE '/init|/systemd' && {"
          echo "  note \"There seems to be an init system in ENTRYPOINT of image:
    \$Entrypoint
  Will disable it as x11docker already runs an init with option --$Initsystem.
  To allow this ENTRYPOINT, run x11docker with option --no-init.\""
          echo "  Entrypoint="
          echo "}"
        ;;
        tini)
          echo "echo \"\$Entrypoint\" | grep -qE '/tini|/init|/systemd' && {"
          echo "  note \"There seems to be an init system in ENTRYPOINT of image:
    \$Entrypoint
  x11docker will run this instead of tini from host.
  You can disable this ENTRYPOINT with option --no-entrypoint.\""
          echo "  Tini="
          echo "}"
        ;;
        none)
          echo "echo \"\$Entrypoint\" | grep -qE '/tini|/init|/systemd' && {"
          echo "  note \"There seems to be an init system in ENTRYPOINT of image:
  \$Entrypoint \""
          echo "} || {"
          [ "$Desktopmode" = "yes" ] && {
            echo "  Exec=  # disable exec to have sh as a fake init for desktop environments. Allows logout."
            echo "  note 'Using sh as a fake init system / PID 1 in container
  due to missing /usr/bin/docker-init on host.
  Without at least a fake init desktop logouts would fail.
  Please consider to provide tini for x11docker containers.'"
          } || echo "  :"
          echo "}"
        ;;
      esac
    ;;
  esac
  echo ""

  echo "[ -z \"\$Imagecommand\$Entrypoint\" ] && warning 'No image command specified and no CMD or ENTRYPOINT found in image.'"
  echo ""

  #### create container.CMD.sh ####
  echo   "# create container.CMD.sh (shared with container and given as image command to docker run)"
  echo   "{ echo '#! /bin/sh'"
  #[ "$Debugmode" = "yes" ] && echo "echo 'set -x'"
  echo   "  echo '# created startscript for docker run: container.CMD.sh'"
  echo   "  echo '# runs as unprivileged user in container'"

  echo   "  echo '$Messagefifofuncs'"
  echo   "  echo 'Messagefile=$Cshare/message.fifo'"
  echo   "  echo ''"

  echo   "  echo '# wait for container setup script do be ready'"
  echo   "  echo 'Zeit=\$(date +%s)'"
  echo   "  echo 'for Count in $(seq -s' ' 50); do'"
  echo   "  echo '  [ -e /x11docker.setupready ] && break'"
  echo   "  echo '  verbose \"Waiting since \$((\$(date +%s) - \$Zeit))s for container setup to be ready\"'"
  echo   "  echo '  sleep \$(awk \"BEGIN { print \$Count*0.2 }\")'"
  echo   "  echo 'done'"
  echo   "  echo ''"

  echo   "  echo 'verbose -d \"Running unprivileged user commands in container\"'"
  echo   "  echo ''"

  echo   '  echo Imagecommand="\"$Imagecommand\""'
  echo   '  echo Entrypoint="\"$Entrypoint\""'
  echo   "  echo ''"
  echo   "  echo 'verbose \"Container system:'"
  echo   "  echo '\$(cat /etc/os-release)\"'"
  echo   "  echo ''"

  echo   "} >> $Imagecommandscript"

  [ "$Switchcontaineruser" = "yes" ] && {
    echo "echo '# Environment variables found in image:' >> $Imagecommandscript"
    echo "IFS=$'\n'"
    echo "while read -r Line; do"
    echo "  echo export \$(escapestring \"\$Line\")      >> $Imagecommandscript"
    echo "done < <($Dockerexe run --rm --entrypoint env $Imagename env 2>>$Containerlogfile| rmcr)"
    echo "rmcr '$Containerlogfile'"
    echo "IFS=$' \t\n'"
    echo ""
  }

  echo   "{"
  echo   "  echo ''"
  echo   "  echo '# x11docker variable settings'"
  echo   "  echo export USER=\"$Benutzer\""
  [ "$Benutzerhosthome" = "no" ] && {
    echo "  echo mkdir -p -v $Benutzerhome"
    for ((Count=1 ; Count<=$Sharevolumescount ; Count++)) ; do
      echo "  echo '# create soft links of shared folders to fake home'"
      echo "  echo 'ln -s ${Sharevolumes[$Count]} $Benutzerhome'"
    done
  }
  echo   "  echo 'export HOME=\"$Benutzerhome\"'"

  [ -n "$Newdisplay" ] && {
    echo "  echo 'export DISPLAY=$Newdisplay'"
    # already done in setup script as needed at least by x11docker/deepin, but repeated here as some init systems clean up /tmp
    echo "  echo '[ -e /tmp/.X11-unix/X$Newdisplaynumber ] || ln -s /X$Newdisplaynumber /tmp/.X11-unix'"
  }
  [ "$Xauthentication" = "yes" ] && echo "  echo 'export XAUTHORITY=$Cshare/Xclientcookie'"
  [ "$Xserver" = "--nothing" ]   && echo "  echo 'unset DISPLAY WAYLAND_DISPLAY XAUTHORITY'"
  [ "$Dbusdaemon" = "yes" ] && Dbuslaunch="yes"
  [ "$Dbuslaunch" = "yes" ] && {
    echo "  echo ''"
    echo "  echo 'Dbus=\"\$(dbus-launch --help >/dev/null 2>&1 && echo dbus-launch)\"'"
    echo "  echo '[ -z \"\$Dbus\" ] && Dbus=\"\$(dbus-run-session --help >/dev/null 2>&1 && echo dbus-run-session)\"'"
    echo "  echo '[ -z \"\$Dbus\" ] && warning \"Did not find dbus-launch or dbus-run-session. (option --dbus).\"'"
  } || echo "  echo 'Dbus=\"\"'"
  echo   "  echo 'verbose -d \"Running dbus user session with: \${Dbus:-(none)}\"'"
  echo   "  echo ''"
  echo   '  echo "[ -e \"\$XDG_RUNTIME_DIR\" ] || {"'
  echo   "  echo '  export XDG_RUNTIME_DIR=/tmp/XDG_RUNTIME_DIR'"
  echo   "  echo '  mkdir -v -m 700 -p \$XDG_RUNTIME_DIR'"
  echo   "  echo '  export XDG_RUNTIME_DIR'"
  echo   "  echo '}'"
  echo   "  echo ''"

  [ "$Sharewayland" = "yes" ] && {
    echo "  echo '# Wayland environment'"
    echo "  echo 'export WAYLAND_DISPLAY=$Newwaylandsocket'"
    echo "  echo 'ln -s /$Newwaylandsocket \$XDG_RUNTIME_DIR/$Newwaylandsocket'"
    echo "  echo 'ls -la \$XDG_RUNTIME_DIR/$Newwaylandsocket'"
    echo "  echo ''"
  }
  [ "$Setwaylandenv" = "yes" ] && {
    for Line in $Waylandtoolkitenv ; do echo "  echo 'export $Line'" ; done
  } || case $Xserver in
    --weston|--kwin|--hostwayland)      echo "  echo 'export XDG_SESSION_TYPE=wayland'" ;;
    --nothing) ;;
    *)                                  echo "  echo 'export XDG_SESSION_TYPE=x11'" ;;
  esac
  echo   "  echo ''"

  [ "$Switchcontaineruser" = "yes" ] && echo "  echo 'export TINI_SUBREAPER=1'"
  echo   "  echo ''"
  echo   "  echo '# xpra environment settings'"
  echo   "  echo 'export UBUNTU_MENUPROXY= QT_X11_NO_NATIVE_MENUBAR=1 MWNOCAPTURE=true MWNO_RIT=true MWWM=allwm'"
  [ -n "$Xprashm" ] && echo "  echo 'export $Xprashm'"

  echo   "  echo ''"
  echo   "  echo 'bash --version >/dev/null 2>&1 && export SHELL=/bin/bash || export SHELL=/bin/sh'"
  echo   "  echo 'export TERM=xterm'"

  echo   "  echo '[ -e /x11docker.LANG ] && export LANG=\"\$(cat /x11docker.LANG)\"'"

  echo   "  echo '[ -e \"$Hostlocaltime\" ] || export TZ=$Hostutctime'"
  echo   "  echo '[ \"\$(date -Ihours)\" != \"$(date -Ihours)\" ] && export TZ=$Hostutctime'"

  echo   "  echo '[ \"\$DEBIAN_FRONTEND\" = noninteractive ] && unset DEBIAN_FRONTEND'"
  echo   "  echo '[ \"\$DEBIAN_FRONTEND\" = newt ]           && unset DEBIAN_FRONTEND'"

  echo   "  echo '# custom environment (--env)'"
  IFS=$'\n'
  for Line in $Customenvironment ; do
    echo "  echo export $(escapestring $Line)"
  done
  IFS=$' \t\n'
  echo   "  echo ''"

  echo   "  echo 'env >> $Cshare/environment'"
  echo   "  echo 'sed -i \"/\(PWD=\|_=\)/d\" $Cshare/environment'"
  echo   "  echo 'verbose \"Container environment:'"
  echo   "  echo '\$(env | sort)\"'"
  echo   "  echo 'verbose \"Copy of environment stored in $Cshare/environment\"'"
  echo   "  echo ''"

  echo   "  echo 'cd \"\$HOME\"'"                                                    # HOME as default working directory
  echo   "  Workdir=\$($Dockerexe inspect --format='{{.Config.WorkingDir}}' $Imagename 2>>'$Containerlogfile'| rmcr)" # WORKDIR in image
  echo   '  [ "$Workdir" ] && echo "[ -d \"$Workdir\" ] && cd \"$Workdir\"   # WORKDIR in image"'
  [ "$Workdir" = "/tmp" ] || echo "  echo 'cd $Workdir'"                             # x11docker option --workdir
  echo   "  echo ''"

  echo   "  echo verbose -d \"Running image command: \$Tini \\\$Dbus \$Entrypoint \$Imagecommand\""
  echo   "  echo \"\$Exec \$Tini \\\$Dbus \$Entrypoint \$Imagecommand $( [ "$Forwardstdin" = "yes" ] && echo "<$Cshare/stdin") >>$Cshare/stdout 2>>$Cshare/stderr\""

  echo   "  echo '# Ready for docker run'"
  echo   "} >> $Imagecommandscript"
  #### End of container.CMD.sh ####

  echo ""
  echo "nl -ba >> $Logfile < $Imagecommandscript"
  echo ""


  # check and create cgroup mountpoint for systemd or elogind
  [ "$Sharecgroup" = "yes" ] && [ "$Dbusdaemon" = "yes" ] && {
    [ "$Initsystem" = "systemd" ] && Wantcgroup=systemd || Wantcgroup=elogind
    findmnt /sys/fs/cgroup/$Wantcgroup >/dev/null || {
      echo "[ '$Wantcgroup' = 'systemd' ] || $Dockerexe run --rm --entrypoint env $Imagename which elogind >/dev/null && {"
      echo '  [ "$(id -u)"  = "0" ] && note "Creating cgroup mountpoint for '$Wantcgroup'."'
      echo '  [ "$(id -u)" != "0" ] && {'
      echo "    note 'Want to create and mount a cgroup for $Wantcgroup.
  As x11docker currently does not run as root, this will probably fail.
  Please either run x11docker as root, or run with option --pw=su or --pw=sudo.
    
  Alternatively, create cgroup mountpoint yourself with:
    mkdir -p /sys/fs/cgroup/$Wantcgroup
    mount -t cgroup cgroup /sys/fs/cgroup/$Wantcgroup -o none,name=$Wantcgroup
    
  If you get a read-only error message, remove write protection with:
    mount -o remount,rw cgroup /sys/fs/cgroup
    
  You can restore write protection after cgroup creation with:
    mount -o remount,ro cgroup /sys/fs/cgroup'"
      [ "$Wantcgroup" = "elogind" ] && echo "note 'If you do not want or need elogind in container,
  just ignore message above.'"
      echo "  }"
      findmnt /sys/fs/cgroup -O ro >/dev/null && {
        echo "  mount -o remount,rw cgroup /sys/fs/cgroup >>$Containerlogfile 2>&1"
        echo "  Remounted=yes"
      }
      echo "  mkdir -p /sys/fs/cgroup/elogind >>$Containerlogfile 2>&1"
      echo "  mount -t cgroup cgroup /sys/fs/cgroup/elogind -o none,name=elogind  >>$Containerlogfile 2>&1"
      echo '  [ "${Remounted:-}" = "yes" ] && mount -o remount,ro cgroup /sys/fs/cgroup  >>'$Containerlogfile' 2>&1'
      echo "}"
      echo ""
    }
  }

  #### run docker image ####
  [ "$Winsubsystem" = "MSYS2" ] && echo "export MSYS2_ARG_CONV_EXCL='*'"
  echo "read Containerid < <($Dockercommand 2>>$Containerlogfile | rmcr)"
  ##########################

  echo ""
  echo "verbose -d \"Container ID: \$Containerid\""
  echo "[ \"\$Containerid\" ] || {
    rmcr '$Containerlogfile'
    error \"Startup of docker failed. Did not receive a container ID.
    
  Last lines of container log:
\$(tail $Containerlogfile)\"
}"
  echo "echo \$Containerid >> $Containeridfile"
  [ "$Showcontainerid" = "yes" ] && echo "stdout \"\$(cat $Containeridfile)\""
  echo "$Dockerexe logs -f \$Containerid 2>&1 | rmcr >> $Containerlogfile &"
  echo ""
  echo "# wait for container to be ready"
  echo "for ((Count=1 ; Count<=20 ; Count++)); do"
  echo "  $Dockerexe exec $Containername sh -c : 2>&1 | rmcr >>$Containerlogfile && { verbose -d 'Container is up and running.' ; break ; } || verbose -d \"Container not ready on \$Count. attempt, trying again.\""
  echo "  sleep 0.2"
  echo "done"
  echo "Failure=\"\$(cat $Containerlogfile | rmcr | grep -v grep | grep -E 'Error response from daemon|OCI runtime exec' ||:)\""
  echo "[ \"\$Failure\" ] && {"
  echo "  echo \"\$Failure\" >>$Containerlogfile"
  echo "  error \"Got error message from docker daemon:
\$Failure\""
  echo "}"
  echo ""

  echo "$Dockerexe inspect --format '{{ .NetworkSettings.IPAddress }}' $Containername 2>>$Containerlogfile | rmcr >> $Containeripfile"
  echo "verbose -d \"Container IP: \$(cat $Containeripfile)\""
  echo ""
  echo "$Dockerexe inspect --format '{{.State.Pid}}' $Containername 2>>$Containerlogfile | rmcr >> $Containerpid1pidfile"
  echo "verbose -d \"Host PID of container PID 1: \$(cat $Containerpid1pidfile)\""
  [ "$Showcontainerpid1pid" = "yes" ] && echo "stdout \"\$(cat $Containerpid1pidfile)\""
  echo ""
  echo "# get PID of container"
  echo "Containerpid=\$(ps ax | grep \$Containerid | grep -v grep | grep -v ' logs' | awk '{print \$1}')"
  echo "verbose -d \"Container PID: \$Containerpid\""
  echo "echo \$Containerpid >> $Containerpidfile"
  echo ""
  echo "rmcr '$Containerlogfile'"
  echo ""
  # container.CMD.sh will wait until setup script is ready
  [ "$Switchcontaineruser" = "no" ] && echo "$Dockerexe exec --tty -u root $Containername /bin/sh $Cshare/container.rootsetup.sh 2>&1 | rmcr >>$Containerlogfile"
  echo "exit 0"
} >> $Dockerrc

{ #### part: create container root setup script: This script runs as root in container
  echo "#! /bin/sh"
  echo "# set up docker container as root before ongoing in unprivileged container.CMD.sh"
  echo "# commands in this script are executed as root in container"
  echo ""

  #[ "$Debugmode" = "yes" ] && echo "set -x"
  
  echo "$Messagefifofuncs"
  echo "Messagefile=$Cshare/message.fifo"
  echo ""

  echo "verbose -d 'Running setup as root in container'"

  # check type of libc
  echo "ldd --version 2>&1 | grep -q 'musl libc' && Containerlibc='musl'"
  echo "ldd --version 2>&1 | grep -q -E 'GLIBC|GNU libc'  && Containerlibc='glibc'"

  echo 'verbose -d "Container libc: $Containerlibc"'
  echo ""

  # prepare X environment
  echo "# create some system dirs with needed permissions"
  echo "mkdir -v -p /var/lib/dbus /var/run/dbus"
  echo "mkdir -v -p -m 1777 /tmp/.ICE-unix /tmp/.X11-unix /tmp/.font-unix"
  echo "chmod -c 1777 /tmp/.ICE-unix /tmp/.X11-unix /tmp/.font-unix"
  echo "export DISPLAY=$Newdisplay XAUTHORITY=$Cshare/Xclientcookie"
  [ "$Xserver" != "--vcxsrv" ] && {
    echo "ln -s /X$Newdisplaynumber $Newxsocket" # done again in container.CMD.sh. At least x11docker/deepin needs it here already.
    echo "ls -l /X$Newdisplaynumber"
    echo "ls -l $Newxsocket"
  }
  echo ""

  [ "$Hostlocaltime" ] && {
    echo '[ ! -d /usr/share/zoneinfo ] && [ "$Containerlibc" = "'$Hostlibc'" ] && {'
    echo "  mkdir -p $(dirname $Hostlocaltime)"
    echo "  cp '$Cshare/timezone'  '$Hostlocaltime'"
    echo "}"
    echo "[ -e '$Hostlocaltime' ] && ln -f -s '$Hostlocaltime' /etc/localtime"
    echo ""
  }

  echo "Containersystem=\$(. /etc/os-release; echo \$ID)"
  echo "verbose \"Container system ID: \$Containersystem\""
  echo ""

  # custom environment variables
  IFS=$'\n'
  for Line in $Customenvironment ; do
    [ "$Line" ] && echo "export $Line"
  done
  IFS=$' \t\n'
  echo ""

  # create container user
  echo "# create user entry in /etc/passwd (and delete possibly existing same uid)"
  echo "getent passwd | grep -v \$(getent passwd $Benutzeruid || echo USERNOTFOUND) > /tmp/passwd"
  echo "# disable possible /etc/shadow passwords for other users"
  echo "sed -i s%:x:%:-:% /tmp/passwd"
  echo "echo $Benutzerpasswdentry >> /tmp/passwd"
  echo "rm /etc/passwd"
  echo "mv /tmp/passwd /etc/passwd || warning 'Unable to change /etc/passwd. That may be a seurity risk.'"
  echo ""
  echo "# create password entry for container user in /etc/shadow"
  echo "rm -v /etc/shadow || warning 'Cannot change /etc/shadow. That may be a security risk.'"
  echo "echo \"$Benutzer:$Benutzerpasswort:17293:0:99999:7:::\" > /etc/shadow"
  case $Sudouser in
    no)  echo "echo 'root:*:17219:0:99999:7:::' >> /etc/shadow" ;;
    yes) echo "echo 'root:$Benutzerpasswort:17219:0:99999:7:::' >> /etc/shadow  # with option --sudouser, set root password 'x11docker'"
         echo "sed -i s%root:-:%root:x:% /etc/passwd                            # allow password in /etc/shadow"
    ;;
  esac
  echo ""
  echo "# add user to groups video, audio, systemd-journal"
  echo "# replace container GIDs of video and audio with host GIDs"
  echo "Gidvideo=$Hostgidvideo"
  echo "Gidaudio=$Hostgidaudio"
  echo "[ \"\$Gidvideo\" ] || Gidvideo=\$(getent group video | cut -d: -f3)"
  echo "[ \"\$Gidaudio\" ] || Gidaudio=\$(getent group audio | cut -d: -f3)"
  echo "getent group | sed \"s/^video.*/video:x:\$Gidvideo:\$(getent group video | cut -d: -f4 ),$Benutzer/ ;"
  echo "                     s/^audio.*/audio:x:\$Gidaudio:\$(getent group audio | cut -d: -f4 ),$Benutzer/ ;"
  for Line in $Groupadd ; do
    echo "                     s/^$Line.*/\0,$Benutzer/ ;"
  done
  echo "                     s/^systemd-journal.*/\0,$Benutzer/ \" | sed 's/:,/:/' > /tmp/group"
  echo "cp /tmp/group /etc/group"
  echo ""
  echo "# create user group entry (and delete possibly existing same gid)"
  echo "getent group | grep -v \$(getent group $Benutzergid || echo USERNOTFOUND) > /tmp/group"
  echo "echo $Benutzergruppe:x:$Benutzergid: >> /tmp/group"
  echo "mv /tmp/group /etc/group"
  echo ""
  [ "$Benutzerhosthome" = "no" ] && echo "mkdir -v -m 777 /fakehome"
  echo ""

  # sudo configuration
  echo "# create /etc/sudoers, delete /etc/sudoers.d. Overwrite possible sudo setups in image."
  echo "[ -e /etc/sudoers.d ] && rm -v -R /etc/sudoers.d"
  echo "[ -e /etc/sudoers ]   && rm -v /etc/sudoers"
  echo "echo '# /etc/sudoers created by x11docker' > /etc/sudoers"
  echo "echo 'root ALL=(ALL) ALL'                 >> /etc/sudoers"
  [ "$Sudouser" = "yes" ] && echo "echo '$Benutzer ALL=(ALL) ALL' >> /etc/sudoers"
  echo ""

  # disable possible custom PAM setups that could allow root in container
  [ "$Sudouser" = "no" ] && {
    echo "# restrict PAM configuration of su and sudo"
    echo "echo 'auth sufficient pam_rootok.so' > /etc/pam.d/su  # allow root to switch user without a password"
    echo "[ -e /etc/pam.d/sudo ] && rm -v /etc/pam.d/sudo"
    echo ""
  }

  # --gpu with closed source nvidia driver
  [ "$Nvidiadriver" ] && {
    echo "Installationwillsucceed=maybe"
    echo '[ "$Containerlibc" = "musl" ] && {'
    echo "  Installationwillsucceed=no"
    echo "  note 'Found musl libc in image. Closed source NVIDIA driver
is incompatible. Use free nouveau driver on host and ask NVIDIA corporation
to publish driver source code to allow you using your hardware.
Fallback: Skipping installation of nvidia driver'"
    echo "}"
    echo "case \$Containersystem in"
    echo "  opensuse)"
    echo "    Installationwillsucceed=no"
    echo "    note \"Nvidia driver installation fails in \$Containersystem.
  You can try to install nvidia driver $Nvidiaversion in image.
  Otherwise, use free nouveau driver on host.\""
    echo "  ;;"
    echo "esac"
    echo "[ \"\$Installationwillsucceed\" = \"maybe\" ] && [ -z \"\$(find . -name *${Nvidiaversion}* -print 2>/dev/null)\" ] && {"
    echo "  mkdir -m 1777 /tmp2 && export TMPDIR=/tmp2"
    echo "  # Install nvidia driver"
    echo "  { command -v modprobe && command -v xz ; } || {"
    echo "    # Try to install modprobe"
    echo "    note 'Did not find modprobe/kmod or xz in image.
  modprobe and xz are needed by nvidia installer.
  Install them in image to speed up container startup.
  Will try to install them. That slows down container startup.'"
    echo "    apt-get update && apt-get install -y     kmod xz-utils  # debian"
    echo "    dnf install -y kmod xz || yum install -y kmod xz        # fedora, centos"
    echo "    xbps-install -Sy                         kmod xz        # void"
    echo "    pacman -Sy --noconfirm                   kmod xz        # arch"
    echo "    emerge --ask n                           kmod xz        # gentoo"
    echo "    zypper --non-interactive install         kmod xz        # opensuse"       #ok, but nvidia-installer extraction fails
    echo "  }"
    echo "  note 'Installing proprietary closed source NVIDIA driver
  version $Nvidiaversion. That slows down container startup.'"
    echo "  sh $Cshare/NVIDIA-$Nvidiaversion.run  --accept-license --no-runlevel-check  --no-questions --ui=none --no-kernel-module --no-kernel-module-source --no-backup --tmpdir /tmp2"
    echo "  rm -R /tmp2 && unset TMPDIR"
    echo "} || note 'Skipping installation of $Cshare/NVIDIA-$Nvidiaversion.run'"
    echo ""
  }

  case $Initsystem in
    tini|none) ;;
    systemd)
      echo "# enable x11docker CMD service"
      echo "systemctl enable x11docker-startcmd.service"

      echo "# to be sure, allow/unmask most important services"
      echo "systemctl unmask systemd-logind dbus"
      echo "# disable cgproxy.service, can cause failing startup."
      echo "systemctl mask cgproxy"
      echo "# disable useless plymouth"
      echo "systemctl mask plymouth-start plymouth-read-write plymouth-quit plymouth-quit-wait"
      echo "# disable useless NetworkManager"
      echo "systemctl mask NetworkManager"
      echo "# disable deepin update service"
      echo "systemctl mask lastore-daemon lastore-update-metadata-info"
    ;;
    runit)
      echo "# create and enable x11docker service containing image command"
      echo "mkdir -p /etc/sv/x11docker"
      echo "printf '#! /bin/sh
waitforservice() {
  Service=\$1
  [ \"\$(sv check \$Service | cut -d: -f1)\" = \"ok\" ] && {
    echo \"x11docker: waiting for service \$Service ...\"
    for Count in $(seq -s' ' 20); do
      [ \"\$(sv status \$Service | cut -d: -f1)\" = \"down\" ] && sleep 0.2 || break
    done
  }
}
# make stderr visible
exec 2>&1
# wait for all other services
for Service in \$(ls /etc/runit/runsvdir/default/) ; do waitforservice \$Service ;done
echo \"Current status of runit services:\"
for Service in \$(ls /etc/runit/runsvdir/default/) ; do sv status      \$Service ;done
su - --shell=/bin/sh $Benutzer $Cshare/container.CMD.sh
runit-init 0
' > /etc/sv/x11docker/run"
      echo "chmod +x /etc/sv/x11docker/run"
      echo "ln -s /etc/sv/x11docker /etc/runit/runsvdir/default"
      echo "verbose 'DBus: enabling dbus service'"
      echo "ln -s /etc/sv/dbus  /etc/runit/runsvdir/default"
    ;;
    openrc)
      echo "# create and enable x11docker service containing image command"
      echo "printf \"#!/sbin/openrc-run
name=x11docker
depend() {
  after *
}
start() {
  ebegin 'Starting container.CMD.sh'
  su - -s /bin/sh $Benutzer $Cshare/container.CMD.sh
  openrc shutdown
  halt
  eend \$?
}
\" > /etc/init.d/x11docker.service"
      echo "chmod +x /etc/init.d/x11docker.service"
      echo "rc-update add x11docker.service default"
      echo "verbose 'DBus: enabling dbus service'"
      echo "rc-update add dbus default"
      echo "# tell openrc that it runs in docker"
      echo "sed -e 's/#rc_sys=\"\"/rc_sys=\"docker\"/g' -i /etc/rc.conf"
    ;;
    sysvinit)
      echo "# add x11docker start command to rc.local"
      echo "sed -i '/exit 0/d' /etc/rc.local"
      echo "echo 'su - -s /bin/sh $Benutzer $Cshare/container.CMD.sh || echo \"x11docker: Exit code of x11docker.CMD.sh: \$?\"
echo \"x11docker: rc.local sends shutdown -h now\"
shutdown -h now
exit 0' >> /etc/rc.local"
    ;;
  esac

  echo "# disable getty in inittab"
  echo "[ -e /etc/inittab ] && sed -i 's/.*getty/##getty disabled by x11docker## \0/' /etc/inittab"

  # start dbus daemon and dbus services
  case $Dbusdaemon in
    yes)
      warning "Will run DBus system services as root in container.
  If the image contains malicious applications started by DBus service files,
  they may abuse their root privileges and may try to break out of container."

      echo "verbose 'DBus: removing failing or useless services.'"
      echo "for Line in \$(find /usr/share/dbus-1/system-services /usr/share/dbus-1/services -type f); do"
      echo '  Name="$(cat $Line | grep Name= | cut -d= -f2)"'
      echo '  Command="$(cat $Line | grep Exec= | cut -d= -f2)"'
      echo '  verbose -d "Checking $Name: $Command"'
      echo "  case \$Name in"
      echo "    org.bluez)"
      echo "      rm -v \$Line"
      echo "    ;;"
      echo "    org.freedesktop.UPower|org.freedesktop.ConsoleKit|org.freedesktop.resolve1|org.freedesktop.network1|org.freedesktop.timedate1)"
      echo "      rm -v \$Line"
      echo "    ;;"
      echo "    org.freedesktop.systemd1) "
      [ "$Initsystem" = "systemd" ] || echo "      rm -v \$Line"
      #echo '      debugnote "$(cat $Line)"'
      echo "    ;;"
      echo "    org.freedesktop.login1)"
      echo '      # check for loginservice, store it to run it later'
      echo '      verbose -d "Found login service $Name: $Command"'
      echo '      Loginservice=$Name'
      echo '      Loginservicecommand=$Command'
      [ "$Sharecgroup" = "no" ] && {
        echo "      rm -v \$Line"
        echo '      echo $Command | grep -q elogind && {'
        echo '        note "Found login service elogind.'
        echo '  If you want to use it, enable option --sharecgroup."'
        echo '        Loginservice='
        echo '        Loginservicecommand='
        echo '      }'
        echo '      echo $Command | grep -q "systemd-logind" && {'
        echo '        Loginservice='
        echo '        Loginservicecommand='
        echo '      }'
      }
      [ "$Initsystem" = "systemd" ] || {
        echo '      echo $Command | grep -q "systemd-logind" && {'
        echo '        Loginservice='
        echo '        Loginservicecommand='
        echo '      }'
      }
      echo "    ;;"
      echo "    org.freedesktop.hostname1|org.freedesktop.locale1)"
      [ "$Initsystem" = "systemd" ] || {
        echo "      # Service somehow kills container after some time if container runs without systemd. wtf. Just deleting this:"
        echo "      rm -v \$Line"
      }
      echo "    ;;"
      echo "    org.opensuse.CupsPkHelper.Mechanism)"
      echo "      rm -v \$Line"
      echo "    ;;"
      echo "    com.deepin.lastore|com.deepin.dde.Welcome|com.deepin.daemon.Bluetooth|com.deepin.daemon.Grub2|com.deepin.daemon.Network|com.deepin.daemon.Timedate|com.deepin.daemon.Power|com.deepin.daemon.Audio|com.deepin.daemon.InputDevices)"
      echo "      # deepin services"
      echo "      rm -v \$Line"
      echo "    ;;"
      echo "  esac"
      echo "done"

      echo "echo 'x11docker: DBus: starting dbus system daemon'"
      echo "dbus-daemon --system --fork"
      echo "for Count in 1 2 3 4 5; do"
      echo "  [ -e /run/dbus/system_bus_socket ] && break"
      echo "  sleep 0.1"
      echo "done"
      echo "[ -e /run/dbus/system_bus_socket ] || warning 'DBus startup seems to have failed. /run/dbus/system_bus_socket not found.'"

      [ "$Nonewprivileges" = "yes" ] && {
        echo "# support for dbus daemon with no-new-privileges"
        echo "waitforservice() {"
        echo "  # wait for dbus service \$1 to appear in dbus service list"
        echo "  for Count in 1 2 3 4 5 6 7 8 9 10 ; do"
        echo "    dbus-send --system --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames | grep -q \$1 && break"
        echo "    verbose -d \"DBus: waiting for \$1 to be ready\""
        echo "    sleep 0.1"
        echo "  done"
        echo "}"
        echo '[ "$Loginservice" ] && {'
        echo '  verbose -d "Starting login service $Loginservicecommand"'
        echo '  command -v $Loginservicecommand && {'
        echo '    eval $Loginservicecommand &'
        echo '  } || {'
        echo '    echo $Loginservicecommand | grep -q elogind && elogind &'
        echo '  }'
        echo '  waitforservice $Loginservice'
        echo '}'
        echo "# start polkitd as first service"
        echo "[ -x /usr/lib/policykit-1/polkitd ] && {"
        echo "  verbose -d 'DBus: starting PolicyKit'"
        echo "  /usr/lib/policykit-1/polkitd &"
        echo "  waitforservice org.freedesktop.PolicyKit1"
        echo "}"
        echo "[ -x /usr/lib/accountsservice/accounts-daemon ] && {"
        echo "  verbose -d 'DBus: starting Accounts daemon'"
        echo "  /usr/lib/accountsservice/accounts-daemon &"
        echo "  waitforservice org.freedesktop.Accounts"
        echo "}"
        echo "# start all other dbus system services"
        echo "for Line in \$(find /usr/share/dbus-1/system-services -type f); do"
        echo "  Name=\"\$(cat \$Line | grep Name= | cut -d= -f2)\""
        echo "  Command=\"\$(cat \$Line | grep Exec= | cut -d= -f2)\""
        echo "  case \$Name in"
        echo "    org.freedesktop.PolicyKit1|org.freedesktop.Accounts) ;;"
        echo "    org.freedesktop.login1) ;;"
        echo '    *)'
        echo '      verbose -d "DBus: starting service $Name: $Command"'
        echo '      $Command &'
        echo '      [ "$Command" != "/bin/false" ] && waitforservice $Name'
        echo '    ;;'
        echo '  esac'
        echo 'done'
      }
      echo "verbose -d \"DBus: Running system services:
\$(dbus-send --system         \
  --dest=org.freedesktop.DBus \
  --type=method_call          \
  --print-reply               \
  /org/freedesktop/DBus       \
  org.freedesktop.DBus.ListNames)\""
    ;;
  esac

  # --lang: language locale
  [ "$Langwunsch" ] && {
    echo "verbose \"Searching for language locale matching $Langwunsch\""
    echo "Locales=\"\$(locale -a)\""
    echo "Langall=\"\$(cat /usr/share/i18n/SUPPORTED | grep -E 'UTF-8|utf8' | cut -d' ' -f1 | cut -d. -f1 | cut -d@ -f1 | sort | uniq)\""
    echo "Langland=\$(echo $Langwunsch | cut -d. -f1)"
    echo "echo \$Langland | grep -q '_' || {"
    echo "  Langland=\"\$(echo \$Langland | tr '[:upper:]' '[:lower:]')_\$(echo \$Langland | tr '[:lower:]' '[:upper:]')\""
    echo "  echo \"\$Langall\" | grep -q \$Langland || {"
    echo "    echo \"\$Langall\" | grep -i -q $Langwunsch && {"
    echo "      Langland=\$(echo \"\$Langall\" | grep -i -m1 $Langwunsch)"
    echo "    }"
    echo "  }"
    echo "}"
    echo "Langland=\$(echo \$Langland | cut -d_ -f1 | tr '[:upper:]' '[:lower:]')_\$(echo \$Langland | cut -d_ -f2 | tr '[:lower:]' '[:upper:]')"
    echo "echo \"\$Locales\" | grep -q \$Langland.UTF-8 && Langcontainer=\$Langland.UTF-8"
    echo "echo \"\$Locales\" | grep -q \$Langland.utf8  && Langcontainer=\$Langland.utf8"
    echo "echo $Langwunsch | grep -E 'C|C.UTF-8|C.utf8|POSIX' >/dev/null && Langcontainer=$Langwunsch"
    echo "[ -z \"\$Langcontainer\" ] && {"
    echo "  [ -e /usr/share/i18n/SUPPORTED ] || warning \"/usr/share/i18n/SUPPORTED not found.
  Please install locale package in image (belongs to glibc)\""
    echo "  Langcontainer=\$Langland.utf8"
    echo "  verbose \"Creating language locale \$Langcontainer\""
    echo "  command -v localedef >/dev/null || note 'Command localedef not found in image.
  Need it for language locale creation (--lang).'"
    echo "  localedef --verbose --force -i \$Langland -f UTF-8 \$Langcontainer || verbose \"localedef exit code: \$?\""
    echo "  locale -a | grep -q \"\$Langcontainer\" || {"
    echo "    warning \"Locale creation of \$Langcontainer failed.\""
    echo "    Langcontainer=''"
    echo "  }"
    echo "} || {"
    echo "  verbose \"Found locale in image: \$Langcontainer\""
    echo "}"
    echo "[ \"\$Langcontainer\" ] && {"
    echo "  echo \"\$Langcontainer\" > /x11docker.LANG"
    echo "  echo \"LANG=\$Langcontainer\" > /etc/default/locale"
    echo "} || warning 'Desired locale for '--lang=$Langwunsch' not found and not created.'"
    echo "verbose \"Output of locale -a:"
    echo "\$(locale -a)\""
    echo ""
  }

  # --pulseaudio check
  [ "$Pulseaudiomode" ] && {
    echo "command -v pulseaudio >/dev/null || warning \"Command pulseaudio not found in image (option --pulseaudio),\""
    echo ""
  }

  # --runasroot command added here
  [ "$Runasroot" ] && {
    echo "# custom setup root command added with option --runasroot"
    echo "$Runasroot"
  }

  # message to container.CMD.sh
  echo "echo 'x11docker: Container root setup is ready'"
  echo ":> /x11docker.setupready"

  [ "$Switchcontaineruser" = "yes" ] && {   # if "no", container.CMD.sh is executed in command line $Dockercommand
    case $Initsystem in
      none)
        echo "/bin/su - -s /bin/sh $Benutzer $Cshare/container.CMD.sh"
      ;;
      tini)
        echo "Exec=exec"
        [ "$Sharecgroup" = "yes" ] && echo '[ "$Loginservice" ] && Exec='
        echo "\$Exec /bin/su - -s /bin/sh $Benutzer $Cshare/container.CMD.sh"
      ;;
      runit|openrc|sysvinit)
        echo "{
  read Dummy <$Cshare/timetosaygoodbye.fifo
  echo timetosaygoodbye >$Cshare/timetosaygoodbye.fifo
  echo 'x11docker: timetosaygoodbye.watch sends: shutdown -h now'
  shutdown -h now
} &"
        echo "exec /sbin/init"
      ;;
      systemd)
        echo 'Systemd=/lib/systemd/systemd'
        echo '[ -e "$Systemd" ] || Systemd=/bin/systemd'
        echo '[ -e "$Systemd" ] || Systemd=/sbin/systemd'
        echo '[ -e "$Systemd" ] || {'
        echo '  command -v systemctl && {'
        echo '    warning "Executeable for systemd not found. Will try /sbin/init"'
        echo '    Systemd=/sbin/init'
        echo '  } || error "systemd not found in image (option --systemd)."'
        echo '}'
        echo 'exec $Systemd'
      ;;
    esac
  }
} >> $Containerrootsetupscript

{ #### part: create pullrc: interactive script to pull image from docker hub
  echo "#! /bin/bash"
  #[ "$Debugmode" = "yes" ] && echo "set -x"
  declare -f rmcr
  echo "touchpullready() {"
  echo "  trap - EXIT"
  echo "  $Mksu 'touch $Cachefolder/pullready'"
  echo "  exit"
  echo "}"
  echo "trap touchpullready EXIT"
  echo "echo ''"
  [ "$Winsubsystem" ] && echo "export PATH=\"$Winsubmount/c/Program Files/docker:$Winsubmount/c/Program Files/Docker/Docker/resources/bin:\$PATH\""
  echo "read -n1 -e -p \"Image '$Imagename' not found locally. "
  echo "Do you want to pull it from docker hub? [Y|n]\" Choice"
  echo "[[ \"\$Choice\" == [YyJj]* ]] || [ -z \"\$Choice\" ] && $Sudo $Dockerexe pull $Imagename 2>> $Containerlogfile"
  echo "rmcr $Containerlogfile"
  echo "sleep 2"
  echo "exit"
} >> $Pullrc

{ #### part: create xtermrc: prompt for password and run dockerrc
  echo "#! /bin/bash"
  #[ "$Debugmode" = "yes" ] && echo "set -x"
  echo "touchxtermready() {"
  echo "  $Mksu 'touch $Cachefolder/xtermready'"
  echo "  trap - EXIT"
  echo "  exit"
  echo "}"
  echo "trap touchxtermready EXIT"
  echo "export TERM=xterm SHELL=/bin/bash"
  [ "$Passwordneeded" = "yes" ] && case $Passwordfrontend in
    su|sudo)
      echo "echo 'x11docker $Imagename $Imagecommand:'"
      echo "echo 'Please type in your password to run docker on display $Newdisplay'"
      echo "echo -n 'Password ($Passwordfrontend): '"
    ;;
  esac
  case $Passwordfrontend in
    gksudo|lxsudo)  echo "$Passwordcommand bash $Dockerrc" ;;
    pkexec)         echo "pkexec env DISPLAY=\$DISPLAY XAUTHORITY=\$XAUTHORITY bash $Dockerrc" ;;
    gksu)           echo "$Passwordcommand \"bash $Dockerrc \" 2>/dev/null" ;;
    *)              echo "$Passwordcommand \"${Sudo}bash $Dockerrc \"" ;;
  esac
  echo "exit"
} >> $Xtermrc

{ #### part: create xinitrc: set up X environment, create cookies
  echo "#! /bin/sh"
  #[ "$Debugmode" = "yes" ] && echo "set -x"

  # declaring functions echoes them into xinitrc
  echo "Timetosaygoodbye=$Timetosaygoodbye"
  echo "Bgpidfile=$Bgpidfile"
  echo "Winsubsystem=$Winsubsystem"
  declare -f storepid
  declare -f rocknroll waitfortheend
  declare -f rmcr no_xhost

  echo "$Messagefifofuncs"
  echo "Messagefile=$Messagefifo"
  echo ""

  echo "export PATH='$PATH'"

  echo "verbose -d 'Running xinitrc'"

  [ "$Noxhost" = "yes" ] && [ -n "$Hostdisplay" ] && {
    echo "export $Hostxenv"
    echo 'verbose -d "Option --no-xhost: disabling any access to host display $DISPLAY granted by xhost"'
    echo 'no_xhost || warning "Option --no-xhost failed. Output of xhost:'
    echo '$(xhost 2>&1 | rmcr)"'
  }

  echo "export $Newxenv"

  case $Xserver in
    --weston|--kwin|--hostwayland) echo "unset DISPLAY XAUTHORITY" ;;
    --nothing) echo "unset DISPLAY XAUTHORITY WAYLAND_DISPLAY" ;;
    *) # here something for real X servers
      echo "# background color"
      echo "xsetroot -solid '#7F7F7F'"
      [ "$Xserver" = "--nxagent" ] && echo "sleep 2 && xsetroot -solid '#7F7F7F' &"


      [ "$Xauthentication" = "yes" ] && {
        echo "# create new XAUTHORITY cookies"
        echo "cd $Sharefolder"
        [ "$Xserver" = "--nxagent" ] && {
          echo "cp $Xclientcookie $Xclientcookie.bak   # nxagent workaround cookie was created before starting xinit"
          echo "export XAUTHORITY=$Xclientcookie.bak"
        }
        [ "$Trusted" = "yes" ] && Trusted="trusted" || Trusted="untrusted"
        echo     ":> $Xclientcookie"
        [ "$Xserver" = "--hostdisplay" ] && {
          [ -s "$Hostxauthority" ] && echo "export XAUTHORITY=$Hostxauthority"
          echo   "xhost | rmcr | grep -q 'SI:localuser:$Hostuser' || { xhost +SI:localuser:$Hostuser | rmcr ; Xhostentry='yes' ; }"
        }
        case "$Ssh" in
          no)
            case $Xserver in
              --vcxsrv) ;;
              *)
                echo "verbose 'Requesting $Trusted cookie from X server'"
                echo "echo 'Requesting $Trusted cookie from X server'"
                echo "$Xauth -v -i -f Xclientcookie generate $Newdisplay . $Trusted timeout 3600 | rmcr"
              ;;
            esac
          ;;
          yes)
            echo "verbose 'Can not use cookies created over SSH. Will bake one myself.'"
          ;;
        esac
        echo     "export XAUTHORITY=$Xclientcookie"
        echo     "[ -s '$Xclientcookie' ] || { "
        echo     "  [ '$Trusted' = 'untrusted' ] && note 'Could not create untrusted cookie. "
        echo     "  Maybe your X server misses extension SECURITY.'"
        [ "$Xserver" = "--hostdisplay" ] && {
          [ "$Sharehostipc" = "no" ] && {
            echo "  warning 'Memory access failures and rendering glitches may occur "
            echo "  due to unrestricted cookie."
            echo "  Avoid them with isolation breaking option --hostipc,"
            echo "  or use another X server option like --xpra or --nxagent.'"
          }
          echo   "  warning 'SECURITY RISK! Keylogging and remote host control "
          echo   "  may be possible! Better avoid using option --hostdisplay,"
          echo   "  rather use --xpra or --nxagent.'"
          echo   "  cp $Hostxauthority $Xclientcookie"
        }
        echo     "}"
        echo     "ls -l $Xclientcookie"
        echo     "[ -s '$Xclientcookie' ] || { "
        echo     "  # still no cookie? try to create one without extension security"
        echo     "  verbose -d 'Failed to retrieve trusted cookie from X server. Will bake one myself.'"
        echo     "  echo 'Failed to retrieve trusted cookie from X server. Will bake one myself.'"
        echo     "  $Xauth -v -i -f Xclientcookie add :$Newdisplaynumber . $(mcookie) | rmcr"
        echo     "  ls -l $Xclientcookie"
        echo     "}"
        echo     "# create prepared cookie with localhost identification disabled by ffff, needed if X socket is shared. ffff means 'familiy wild'"
        echo     "Cookie=\$($Xauth -i -f Xclientcookie nlist | rmcr | sed -e 's/^..../ffff/')"
        echo     "echo \"\$Cookie\" | $Xauth -v -i -f Xclientcookie nmerge - | rmcr"
        echo     "cp $Xclientcookie $Xservercookie"
        echo     "[ -s '$Xclientcookie' ] || warning 'Cookie creation failed!'"
        echo     "verbose -d \"Created cookie: \$($Xauth -f Xclientcookie list 2>&1 | rmcr)\""
        echo     "chmod 644 $Xclientcookie"
        [ "$Xserver" = "--hostdisplay" ] && echo "[ '\$Xhostentry' = 'yes' ] && env XAUTHORITY=$Hostxauthority xhost -SI:localuser:$Hostuser | rmcr"
        [ "$Xserver" = "--nxagent" ]     && echo "rm $Xclientcookie.bak"
      }

      echo "export XAUTHORITY=$Xclientcookie"
      echo "[ '$Xauthentication' = 'no' ] || [ ! -s '$Xclientcookie' ] && unset XAUTHORITY && warning '$Xserver: X server $Newdisplay runs without cookie authentication.'"

      case "$Xserver" in
        --hostdisplay|--nxagent) ;;
        --vcxsrv) ;; # xhost does not work over tcp
        *)
          case $Xauthentication in
            yes)
              echo "verbose 'Disabling any possible access to new X server possibly granted by xhost'"
              echo "no_xhost"
            ;;
          esac

          [ -n "$Xhost" ] && {
            echo "verbose 'Custom xhost setting on $Newdisplay (option --xhost): $Xhost'"
            echo "xhost $Xhost | rmcr"
          }

          [ "$Initsystem" = "systemd" ] || [ "$Dbusdaemon" = "yes" ] && {
            echo "note 'Allowing xhost access for $Benutzer on display $Newdisplay"
            echo "  to avoid service issues with X access. (option --systemd or --dbus-system):"
            echo "    xhost +SI:localuser:$Benutzer'"
            echo "xhost +SI:localuser:$Benutzer | rmcr"
          }
          # Keyboard layout
          command -v setxkbmap >/dev/null && {
            case "$Xkblayout" in
              "") [ -n "$Hostdisplay" ] && setxkbmap -display $Hostdisplay -print >> $Xkbkeymapfile ;;
              *)  setxkbmap "$Xkblayout" -print >> $Xkbkeymapfile ;;
            esac
          } || {
            note "setxkbmap not found. Need setxkbmap and xkbcomp to set keyboard layout."
          }
          [ -s "$Xkbkeymapfile" ] && {
            echo "#"
            echo "# set keyboard layout on $Newdisplay to same as on host"
            echo "echo 'x11docker: keyboard layout:'"
            echo "cat $Xkbkeymapfile"
            echo "xkbcomp $Xkbkeymapfile $Newdisplay | rmcr"
          }
        ;;
      esac

      [ "$Shareclipboard" = "yes" ] && [ -n "$Hostdisplay" ] && {
        case $Xserver in
          --xpra|--xpra-xwayland|--nxagent|--vcxsrv) ;;     # have their own clipboard management
          --hostdisplay) ;;                                 # already same clipboard
          *)                                                # synchronizing between different X servers
            echo "# option '-c, --clipboard': Run clipboard script "
            echo "# (text copy only) (xpra has its own clipboard managment including images)"
            echo "bash $Shareclipboardscript & storepid \$! shareclipboard"
          ;;
        esac
      }
    ;;
  esac

  [ "$Setwaylandenv" = "yes" ] && for Line in $Waylandtoolkitenv ; do echo "export $Line" ;  done
  [ "$Sharewayland"  = "yes" ] &&       [ -n "$Newwaylandsocket" ] && echo "export WAYLAND_DISPLAY=$Newwaylandsocket"

  case $Xserver in
    --weston|--kwin|--hostwayland|--nothing) ;;
    *)
      echo "getscreensize() {"
      echo "  CurrentXaxis=\$(xrandr | grep primary | cut -d' ' -f4 | cut -dx -f1 )"
      echo "  CurrentYaxis=\$(xrandr | grep primary | cut -d' ' -f4 | cut -dx -f2 | cut -d+ -f1)"
      echo "}"
      echo "checkscreensize() {"
      echo "  getscreensize"
      echo "  [ \"\$Xaxis\" = \"\$CurrentXaxis\" ] || return 1"
      echo "  [ \"\$Yaxis\" = \"\$CurrentYaxis\" ] || return 1"
      echo "  return 0"
      echo "}"
      echo "getprimary() {"
      echo "  xrandr | grep -q primary || xrandr --output \$(xrandr | grep ' connected' | head -n1 | cut -d' ' -f1) --primary"
      echo "  echo \$(xrandr | grep primary | cut -d' ' -f1)"
      echo "}"
      [ "$Xserver" != "--vcxsrv" ] && echo "Output=\$(getprimary)"
    ;;
  esac

  case $Xserver in
    --xpra|--xpra-xwayland)
      # --xpra --desktop: New mode for window smaller than fullscreen
      echo "xrandr --newmode $Modeline"
      echo "xrandr --addmode \$Output $(echo $Modeline | cut -d " " -f1)"
      echo "xrandr --output  \$Output --mode $(echo $Modeline | cut -d " " -f1)"

      [ "$Desktopmode" = "yes" ] && ! command -v Xvfb >/dev/null && {
        echo "for Ycount in 25 30 40 45 50 55 60 65 70 75 80 85 90 95 100; do"
        echo "  for Xcount in 25 30 40 45 50 55 60 65 70 75 80 85 90 95 100; do"
        echo "    Modeline=\$(cvt \$(awk -v a=$Maxxaxis -v b=\$Xcount 'BEGIN {print (a * b / 100)}') \$(awk -v a=$Maxyaxis -v b=\$Ycount 'BEGIN {print (a * b / 100)}') | tail -n1 | cut -d' ' -f2- | tr -d '\"')"
        echo "    xrandr --newmode \$Modeline"
        echo "    xrandr --addmode \$Output \$(echo \$Modeline | cut -d' ' -f1)"
        echo "  done"
        echo "done 2>&1 | uniq"
      }

      ! verlt "$Xpraversion" "xpra v2.3" && verlt "$Xprarelease" "r19606" && {
        warning "Your xpra version has a cookie authentication issue.
  Installed version is: $Xpraversion
  Recommended: Downgrade to xpra v2.2.5, upgrade to at least r19606,
  or use another X server option.
  Fallback: Setting 'xhost +SI:localuser:$Benutzer'"
        echo "xhost +SI:localuser:$Benutzer | rmcr"
      }
    ;;
    --xorg) # --xorg: --scale, --size, --rotate
      echo "xrandr | grep connected | grep -v disconnected && {"
      [ -z "$Screensize" ] && {
        echo "  # determine screen size"
        echo "  getscreensize"
        echo "  Xaxis=\$CurrentXaxis"
        echo "  Yaxis=\$CurrentYaxis"
        [ "$Scaling" ] && echo "  Xaxis=\$(awk -v a=\$Xaxis -v b=$Scaling 'BEGIN {print (a / b)}')"
        echo "  Xaxis=\${Xaxis%.*}"
        [ "$Scaling" ] && echo "  Yaxis=\$(awk -v a=\$Yaxis -v b=$Scaling 'BEGIN {print (a / b)}')"
        echo "  Yaxis=\${Yaxis%.*}"
      } || {
        echo "  Xaxis=$Xaxis"
        echo "  Yaxis=$Yaxis"
      }
      echo "  Screensize=\${Xaxis}x\${Yaxis}"

      [ "$Screensize" ] && [ -z "$Scaling" ] && {
        echo "  [ -n \"\$(xrandr | grep \$Screensize)\" ] && { "
        echo "    note \"Will try to set native resolution \$Screensize."
        echo "  If that looks ugly, use --scale=1 to enforce a fake scaled resolution.\""
        echo "    xrandr --output \$Output --mode \$Screensize"
        echo "  } || note \"Resolution \$Screensize not found in xrandr.\""
      }

      [ "$Screensize" ] && [ -z "$Scaling" ] && {
        echo "  checkscreensize || {"
        echo "    note \"Panning \$Screensize. If virtual screen is greater than "
        echo "  maximal screen size, you can move virtual screen with mouse at screen edges."
        echo "  You can force the virtual screen to match your monitor with option --scale=1\""
        echo "    xrandr --output \$Output --panning \$Screensize+0+0/\$Screensize+0+0/100/100/100/100 --verbose"
        echo '  }'
        echo "  checkscreensize || {"
        echo "    note 'Panning failed, trying to scale instead.'"
        echo "    xrandr --output \$Output --scale-from \$Screensize --panning \$Screensize+0+0/\$Screensize+0+0"
        echo "    checkscreensize && note \"Successfully set screen size \$Screensize\""
        echo '  }'
        echo "  checkscreensize || {"
        echo "    getscreensize"
        echo "    note \"Setting desired resolution \$Screensize failed."
        echo "  Fallback: Will use detected \${CurrentXaxis}x\${CurrentYaxis} instead.\""
        echo '  }'
      }

      [ "$Scaling" ] && {
        [ "$Screensize" ] && [ "$Scaling" != "1" ] && echo "  note 'Cannot set panning and scaling at the same time.
  Desired screen size $Screensize will be scaled to your monitor size
  for arbitrary values you may provide with option --scale.'"
        echo "  # Scaling $Scaling"
        echo "  note \"Setting scaled resolution \$Screensize\" with scale factor $Scaling."
        # must use --scale-from and --panning because --scale causes mouse barriers/crtc-boundaries
        echo "  xrandr --output \$Output --scale-from \$Screensize --panning \$Screensize+0+0/\$Screensize+0+0 --verbose"
        echo "  checkscreensize || {"
        echo "    getscreensize"
        echo "    note \"Setting desired resolution \$Screensize failed."
        echo "  Detected resolution \${CurrentXaxis}x\${CurrentYaxis} instead.\""
        echo "  }"
      }

      [ -n "$Rotation" ] && {
        echo "  verbose 'Rotation $Rotation'"
        case $Rotation in
          0|normal)    Rotation="" ;;
          90)          Rotation="--rotate right";;
          180)         Rotation="--reflect xy" ;;
          270)         Rotation="--rotate left";;
          flipped)     Rotation="--reflect y";;
          flipped-90)  Rotation="--rotate right --reflect x";;
          flipped-180) Rotation="--reflect x";;
          flipped-270) Rotation="--rotate left --reflect x";;
        esac
        echo "  bash -c 'while read Line ; do xrandr --output \$Line $Rotation ; done < <(xrandr | grep \" connected\" | cut -d \" \" -f1)'"
      }
      echo "} || {"
      echo '  [ -z "$Xaxis" ] && Xaxis=1024 && Yaxis=768'
      echo "  Screensize=\${Xaxis}x\${Yaxis}"
      echo "  note \"Could not detect any connected monitor."
      echo "  Running on a server? Will try to set a framebuffer size"
      echo "  with \"xrandr --fb \$Screensize\" that may serve as a virtual display.\""
      echo "  xrandr --fb \$Screensize"
      echo "}"
    ;;
  esac
  [ -n "$Newdisplay" ] && [ "$Xserver" != "--vcxsrv" ] && echo "verbose \"Output of xrandr on $Newdisplay
\$(xrandr)\""

  [ "$Xfishtank" = "yes" ] && echo "xfishtank & storepid \$! xfishtank"
  [ -n "$Windowmanager" ] && {
    echo "verbose 'Starting host window manager $Windowmanager on new display $Newdisplay'"
    echo "$Windowmanager & storepid \$! windowmanager"
  }

  [ "$Runfromhost" ] && {
    echo "# custom host command added with option --runfromhost"
    echo "$Runfromhost"
  }

  echo "touch $Cachefolder/Xready"
  echo "waitfortheend"
} >> $Xinitrc

{ #### part: some verbose output
    verbose -d "Users and terminal:
  x11docker was started by:                       $Startuser
  As host user serves (running X, storing cache): $Hostuser
  Container user will be:                         $Benutzer
  Container user password:                        x11docker
  Getting permission to run docker with:          $Passwordcommand $Sudo
  Running X and other user commands with:         $Mksu
  Terminal for password frontend:                 $Passwordterminal
  Terminal to show docker pull progress:          $Pullterminal
  Running on console:                             $Tty
  Running over SSH:                               $Ssh
  Running on Windows subsystem:                   ${Winsubsystem:-no}"
    case $X11dockermode in
      run)
        verbose "Generated container.rootsetup.sh:
$(nl -ba <$Containerrootsetupscript)"
        verbose "Generated dockerrc:
$(nl -ba <$Dockerrc)"
        verbose "Generated xtermrc:
$(nl -ba <$Xtermrc)"
      ;;
    esac
    verbose "Generated xinitrc:
$(nl -ba <$Xinitrc)"
    [ -s "$Westonini" ] && verbose "Generated weston.ini:
$(nl -ba <$Westonini)"
}

{ #### part: option '--starter': create desktop starter
  if [ "$Createdesktopstarter" = "yes" ] ; then
    command -v xdg-desktop-icon >/dev/null || error "Command 'xdg-desktop-icon' not found.
  x11docker needs it to place the new icon on your desktop.
  Please install xdg-utils"

    note "Will create a new starter on your desktop.
  If you move the new file to:

    $Hostuserhome/.local/share/applications

  it will appear in your applications menu."

    Name="$Imagenametr $(echo $Imagecommand | tr -cd '[:alpha:][:digit:][:blank:]-_.')"
    [ "$Hostexebasename" ] && Name="$(echo $Hostexebasename on $(echo $Xserver | tr -d '-') | tr -cd '[:alpha:][:digit:][:blank:]-_.')"
    [ "$Hostexebasename" = "xonly" ] && Name="$(echo $Xserver | tr -d '-')"

    read -re -p "Please choose a name for your desktop starter:
" -i "$Name" Name
    [ -z "$Name" ] && exit ### FIXME: check for valid file name / invalid chars?

    #Parsedoptions=$(echo $Parsedoptions | sed 's/--starter/ /')
    Parsedoptions=${Parsedoptions//--starter/}
    mkfile "$Cachefolder/$Name.desktop"
    {
      echo "#!/usr/bin/xdg-open
[Desktop Entry]
# x11docker desktop file
Type=Application
Name=$Name
Exec=x11docker $Parsedoptions
Icon=x11docker
Comment=
Categories=System
Keywords=docker x11docker $(echo $Name | tr -c '[:alpha:][:digit:][:blank:]' ' ' )
"
      case $(command -v x11docker) in
        "")echo "TryExec=$0 $Parsedoptions" ;;
        *) echo "TryExec=x11docker $Parsedoptions" ;;
      esac
    } >> "$Cachefolder/$Name.desktop"

    $Mksu "xdg-desktop-icon install --novendor '$Cachefolder/$Name.desktop'"
    exit
  fi
}

{ #### part: wait for X server and run docker ####
# run following three parts together in a subshell.
# They are executed after xinit.
# For code flow logic, xinit should run here first and moved to background.
# For technical reasons, xinit must not run in a subshell.
# --xorg on tty only works if xinit runs in foreground to grab the tty.
# Otherwise, Xwrapper.config must be edited to 'allowed_users=anybody' even on console.

{ #### part: wait for and watch X server

  # wait for X server to be ready (sign is creation of $Cachefolder/Xready in xinitrc)
  Zeit=$(date +%s)
  Count=0
  Dauer=0
  debugnote "Waiting for X server $Xserver to be ready."
  while [ ! -e "$Cachefolder/Xready" ] ; do
    Count=$(( Count + 1 ))
    Dauer=$(( $(date +%s) - $Zeit ))
    sleep $(awk "BEGIN { print $Count * 0.1 }")
    [ $Dauer -gt 30 ] && error "X server $Xserver not ready after 30s."
    verbose "Waiting since ${Dauer}s for $Xserver to be ready."
    rocknroll || { verbose -d "Stopped waiting for $Xserver due to terminating signal." ; break ; }
    grep -q -E 'xinit: giving up|unable to connect to X server|Connection refused|server error|Only console users are allowed' <$Xinitlogfile && error "Error during startup of X server $Xserver.
  Last lines of xinit log:
$(tail $Xinitlogfile)

  $( [ -s "$Compositorlogfile" ] && echo "Last lines of compositor log:
$(tail $Compositorlogfile)")"
  done
  verbose -d "$Xserver is ready"

  # check and watch compositor
  [ "$Compositorcommand" ] && {
    Compositorpid=$(cat $Compositorpidfile)
    checkpid $Compositorpid && setonwatchpidlist $Compositorpid compositor || error "Startup of compositor failed.
  Last lines of compositor log:
$(tail $Compositorlogfile)"
    storepid $Compositorpid compositor
  }

  # check and watch X server
  case $Xserver in
    --nothing|--hostdisplay|--hostwayland|--weston|--kwin|--vcxsrv) ;;
    *)
      Xinitpid="$(pgrep -a xinit 2>/dev/null | grep "xinit $Xinitrc" | awk '{print $1}')"
      checkpid "$Xinitpid"   && setonwatchpidlist $Xinitpid xinit     && storepid $Xinitpid xinit
      echo $Xcommand | grep -q Xorgwrapper && Line="Xorg $Newdisplay" || Line="$(echo "$Xcommand" | head -n1)"
      Xserverpid=$(ps aux | grep "$(echo "${Line:-nothingtolookfor}" | cut -d' ' -f1-2)" | grep -v grep | grep -v xinit | awk '{print $2}')
      checkpid "$Xserverpid" && setonwatchpidlist $Xserverpid Xserver && storepid $Xserverpid Xserver
    ;;
  esac

  # option '--showenv': show display environment variables on stdout
  [ "$Showdisplayenvironment" = "yes" ] && echo $Newxenv
  # create easy to find file with latest created X environment for custom access
  mkfile "$Cachebasefolder/Xenv.latest"
  for Line in $Newxenv ; do echo $Line >> "$Cachebasefolder/Xenv.latest" ; done
}

{ #### part: options --xpra / --xpra-xwayland: start and watch xpra server and xpra client
  case $Xserver in
    --xpra|--xpra-xwayland)
      notify-send 'Stay tuned, xpra will start soon.' 2>/dev/null
      note        'Stay tuned, xpra will start soon.'
      # loop to keep xpra running.
      # xpra server can crash with some applications like atom editor, --mmap=no fixes that.
      # xpra client can be disconnected after a tty switch, will be restarted in that case.
      Xpracrashcount="0"
      while rocknroll ; do
        # xpra server
        checkpid $Xpraserverpid || {
          [ -n "$Xpraserverpid" ] && {
            Xpracrashcount=$((Xpracrashcount + 1))
            [ "$Xpracrashcount" -eq 1 ] && {
              warning "xpra server has crashed.
  x11docker will add xpra option --mmap=no to hopefully fix that issue.
  xpra will need more CPU power now, but will run more stable.
  Last lines of xpra server log:
$(tail $Xpraserverlogfile)"
              Xpraservercommand="$Xpraservercommand --mmap=no"
              Xpraclientcommand="$Xpraclientcommand --mmap=no"
            }
            [ "$Xpracrashcount" -gt 1 ] && error "Xpra server has crashed again.
  x11docker stops now. Try out other X server options
  like --nxagent, --xephyr or --hostdisplay."
            notify-send "x11docker: xpra server crashed. Restarting xpra now."
            mkfile $Xpraserverlogfile   # clear logfile to remove "xpra is ready" message
          }
          verbose -d "Starting Xpra server"
          $Mksu "env $Newxenv XPRA_OPENGL_DOUBLE_BUFFERED=1 $Xpraservercommand" >> $Xpraserverlogfile 2>&1 &
          Xpraserverpid=$! && storepid $Xpraserverpid xpraserver
          waitforlogentry "xpra server" $Xpraserverlogfile 'xpra is ready' && verbose "Xpra server is ready" || error "Xpra server startup failed.
  Last lines of Xpra server log:
$(tail $Xpraserverlogfile)"
        }

        # xpra client
        checkpid $Xpraclientpid && kill $Xpraclientpid
        verbose -d "Starting Xpra client"
        [ -n "$Xpraclientpid" ] && note "Restarting Xpra client."
        $Mksu "env $Hostxenv XPRA_PADDING_COLORS='0,0.2,1' $Xpraclientcommand" >> $Xpraclientlogfile 2>&1 &
        Xpraclientpid=$! && storepid $Xpraclientpid xpraclient
        checkpid $Xpraclientpid && mywatch "ps -p $Xpraserverpid -o pid ; ps -p $Xpraclientpid -o pid #xpra"
        tail $Xpraserverlogfile | grep -q "client ping timeout" || saygoodbye xpraclient
      done & storepid $! xpraloop
    ;;
  esac
}

{ #### part: start docker
  case $X11dockermode in
    run)
      # prefer asking for password on host X
      [ -n "$Hostdisplay" ]     && export $Hostxenv || export $Newxenv
      [ "$Fullscreen" = "yes" ] && export $Newxenv ### FIXME could cause trouble with Wayland if terminal is not Wayland capable
      [ "$Xserver" = "--xorg" ] && export $Newxenv

      # start docker in xtermrc
      case $Passwordfrontend in
        su|sudo)
          [ "$Passwordterminal" = "bash -c" ] && Passwordterminal=""
          #[ -z "$Passwordterminal" ] && exec </dev/tty
          case $Passwordneeded in
            no) /bin/bash $Xtermrc ;;
            yes) $Passwordterminal /bin/bash $Xtermrc ;;
          esac
        ;;
        *) $Passwordterminal "/bin/bash $Xtermrc" ;;
      esac
      waitforfilecreation $Cachefolder/xtermready infinity

      Containerpid=$(cat $Containerpidfile)
      Containerid=$(cat $Containeridfile)
      Containerip=$(cat $Containeripfile)
      
      # watch container
      [ "$Containerpid" ] && checkpid $Containerpid && {
        storepid $Containerpid container
        setonwatchpidlist $(cat $Containerpid1pidfile) containerpid1
      }
      [ "$Winsubsystem" ] && [ "$Containerid" ] && setonwatchpidlist "CONTAINER$Containerid"
      
      {
        sleep 2
        verbose -d "Process tree of container (maybe not complete yet):
$(pstree -cp $(cat $Containerpid1pidfile) 2>&1 ||:)"
      } &
    ;;

    exe) # --exe: run host application without docker. includes --xonly
      # create start script
      { echo "#! /bin/bash"
        #[ "$Debugmode" = "yes" ] && echo "set -Eux"
        echo "storepid() {"
        echo "  echo \${1:-} \${2:-} >> $Bgpidfile"
        echo "}"
        echo "export $Newxenv"
        [ "$Benutzerhosthome" = "yes" ] && {
          echo "export HOME='$Benutzerhosthomefolder'"
          echo "cd '$Benutzerhosthomefolder'"
        }
        [ "$Workdir" = "/tmp" ] || echo "cd '$Workdir'"
        echo "# close additional file descriptors"
        echo "for i in 3 4 6 7 8 9; do"
        echo "  { >&\$i ;} 2>/dev/null && exec >&\$i-"
        echo "done"
        echo "$Hostexe $( [ "$Forwardstdin" = "yes" ] && echo "<$Cmdstdinfile") >>$Cmdstdoutlogfile 2>>$Cmdstderrlogfile &"
        echo "storepid \$! hostexe"
      } >> $Imagecommandscript
      nl -ba <$Imagecommandscript >> $Containerlogfile

      # run start script
      $Mksubenutzer "bash $Imagecommandscript"

      # check if startup was successfull
      sleep 1 # wait for possible startup failure
      Hostexepid=$(grep hostexe <$Bgpidfile | cut -d' ' -f1)
      checkpid $Hostexepid || warning "Application '$Hostexe' terminated fast
  or failed at all, or the process forked itself and cannot be supervised.
  Last lines of log:
$(tail $Logfile)"

      [ "$Showcontainerid" = "yes" ] && echo ""
      [ "$Showcontainerpid1pid" = "yes" ] && echo $Hostexepid
      echo $Hostexepid >>$Containerpid1pidfile
      
      storepid $Hostexepid hostexe
      setonwatchpidlist $Hostexepid hostexe
      
      sleep 1 && debugnote "Process tree of $Hostexe:
$(pstree -p $Hostexepid 2>&1 ||:)"

    ;;
  esac
  
{ #### part: --pulseaudio: load unix socket module (authenticated with cookie) or TCP module (authenticated with container IP)
  case $Pulseaudiomode in
    socket) $Mksu "pactl load-module module-native-protocol-unix socket=$Sharefolder/pulseaudio.socket 2>&1" >>$Pulseaudiologfile ;;
    tcp) 
      case $Winsubsystem in
        "") $Mksu "pactl load-module module-native-protocol-tcp  port=$Pulseaudioport auth-ip-acl=${Containerip:-"127.0.0.1"} 2>&1" >>$Pulseaudiologfile ;;
        *)  env XDG_RUNTIME_DIR="" HOME="" cmd.exe /C "C:/cygwin64/bin/pactl.exe load-module module-native-protocol-tcp  port=$Pulseaudioport auth-ip-acl=${Containerip:-$Hostip} 2>&1" 2>&1 >>$Pulseaudiologfile ;;
      esac
    ;;
  esac
}

}

debugnote "Process tree of x11docker:
$(pstree -p $$ 2>&1 ||:)"
} & storepid $! containershell                ####

{ #### part: start Compositor
  case $Xserver in
    --weston|--weston-xwayland|--xpra-xwayland|--xdummy-xwayland) Compositorkeyword="weston-desktop-shell" ;;
    --kwin|--kwin-xwayland)                                       Compositorkeyword="X-Server" ;;
  esac

  [ "$Compositorcommand" ] && {
    $Mksu "exec dbus-launch    $Compositorcommand  >> $Compositorlogfile  2>&1 & echo \$! >>$Compositorpidfile"
    waitforlogentry compositor $Compositorlogfile    "$Compositorkeyword" || error "Startup of Wayland compositor failed.
  Can not run $Xserver.
  Last lines of compositor log:
$(tail $Compositorlogfile)"

    case $Xserver in
      --xpra-xwayland|--xdummy-xwayland)  # hide weston window
        $Mksu "xdotool windowunmap 0x$(printf '%x\n' $(grep 'window id' $Compositorlogfile | rev | cut -d' ' -f1 | rev))" ;;
    esac
  }
}

{ #### part: start X server
  case $Xserver in
    --xpra|--xephyr|--xdummy|--xvfb|--xwayland|--nxagent|--weston-xwayland|--kwin-xwayland|--xpra-xwayland|--xdummy-xwayland|--xwin)
      $Mksu "exec env WAYLAND_DISPLAY=$Newwaylandsocket      xinit $Xinitrc -- $Xcommand 2>&1 | rmcr >> $Xinitlogfile" ;;
    --xorg)
      case $Xlegacywrapper in
        yes) $Mksu   "exec                                   xinit $Xinitrc -- $Xcommand             >> $Xinitlogfile  2>&1 " ;;
        no)  bash -c "exec                                   xinit $Xinitrc -- $Xcommand             >> $Xinitlogfile  2>&1 " ;;
      esac
    ;;
    --hostdisplay|--hostwayland|--weston|--kwin|--nothing)
      $Mksu "exec                                             bash $Xinitrc                          >> $Xinitlogfile  2>&1 " ;;
    --vcxsrv)
      [ "$Winsubsystem" = "WSL" ] && Tasklistold="$(tasklist.exe | rmcr | grep vcxsrv.exe | awk '{print $2}')"
      $Mksu "exec env MSYS2_ARG_CONV_EXCL='*'                                  $Xcommand             >> $Xinitlogfile  2>&1 & echo \$! >$Cachefolder/Xserverpid"
      Xserverpid=$(cat "$Cachefolder/Xserverpid")
      [ "$Xserverpid" ] && {
        storepid $Xserverpid Xserver
        setonwatchpidlist $Xserverpid Xserver
      } || error "Failed to receive PID of X server."
      # Wait for VcXsrv to accept connections
      for Count in $(seq -s' ' 25); do
        sleep 0.2
        verbose "$Count. access check for $Xserver"
        grep -q -E 'Authorization|Absolute' <<< "$(xwininfo.exe -display $Newdisplay -root 2>&1)" && break
      done
      # bug in WSL: WSL does not terminate Windows process on TERM for processes started in bash. Workaround to get Windows pid.
      [ "$Winsubsystem" = "WSL" ] && {
        Tasklistnew="$(tasklist.exe | rmcr | grep vcxsrv.exe | awk '{print $2}')"
        Winpidlist="$Winpidlist $(echo "$Tasklistold
$Tasklistnew" | sort | uniq -u)"
        verbose -d "Stored Windows pids: $Winpidlist"
      }
      $Mksu "exec                                             bash $Xinitrc                          >> $Xinitlogfile  2>&1 " ;;
  esac

  [ $? != 0 ] && rocknroll && warning "X server $Xserver returned an error code.
  Last lines of xinit logfile:
$(tail $Xinitlogfile)

  $( [ -s "$Compositorlogfile" ] && echo "Last lines of compositor log:
$(tail $Compositorlogfile)")"

  saygoodbye xinit
}
######### ToDo notes for development
todo() {
# MSYS2/Cygwin/WSL:
#       needs development:
#          --pulseaudio should run authenticated
#       not implemented, but maybe possible:
#          --wayland:    create nested setup for WSL in X?
#          --sharessh:   socket sharing impossible, but maybe similar setup?
#       impossible:
#          --alsa
#          --systemd, --sharecgroup, elogind
#       useless:
#          --showpid1 (shows pid in docker VM)

# BUG x11docker/cde fails
# jess/cathode fails with xcb error, needs bug report
# check xhost +localhost
# BUG --pulseaudio fails with --user due to wrong socket ownership (#54). Fallback to tcp?

# --hostdisplay: check xdpyinfo for MIT-SHM to avoid --hostipc
# further checks of pam.d
# error message window in wayland fails: xterm: no display. should use konsole

# x11docker-gui: menu entry management? persistant command storage?
# --update: regard possible location in /opt
# BUG arch: issues with x11docker/fluxbox, background missing, sometimes no context menu. where is the difference?
# --group-add: compare host and container GID? warn if group misses in container, or create it?

# --weston/x: allow tty switch/option --vt if running as root?
# --systemd: try to avoid xhost +SI:localuser:$Benutzer, needed by deepin, does not recognice XAUTHORITY
# --no-init no-new-privileges switchuser: exec fails, but why?
# check out capsh. replace su with capsh? (missing in alpine) But how to trigger login?
# check echo especially in sh scripts, replace with printf if needed (#25)
# avoid possible confusions --home --sharedir. --sharedir mounts can overlap --home folder. What about softlinks with existing target in --home? Maybe avoid /home/$USER at all
# --lang: find out locale package names for several distris for documentation
# further check of xpra server crashes with jess/atom and chromium. --mmap=no avoids the bug: xpra bug report?

# check multimonitor behaviour
# --keymap does not work on tty with --kwin and --kwin-xwayland. No idea how to set it.
# bug report to docker about --volume waylandsocket in --volume
# --xpra-xwayland, xdummy-xwayland: use kwin-wayland as fallback for missing weston?
# --xorg: getty and autologin to avoid Xwrapper.config changes?
# --wayland --user/--hostuser: wayland socket access denied due to XDG_RUNTIME_DIR
# --nxagent 3.5.0: Mageia 6: seamless mode fails
# fedora: SElinux issue: '--security-opt label=type:container_runtime_t': need more restrictive setting
#         https://unix.stackexchange.com/questions/386767/selinux-and-docker-allow-access-to-x-unix-socket-in-tmp-x11-unix
# --xdummy --gpu on tty allows real resolutions only
# --xorg: check custom systemd start of X #7
# check X in container #7
# some tests with Xephyrglamor=no

### BUG collection: non x11docker bugs
# BUG segmentation faults in gnome3 based desktops: pantheon budgie gnome3
# BUG Xwayland does not always sit at 0.0 on multiple outputs.
#     bugreport: https://bugzilla.redhat.com/show_bug.cgi?id=1498665
# BUG --kwin*: wrong fullscreen and crashes in gnome-wayland, strange in weston, WAYLAND_DISPLAY="" does not help, probably bug in kwin
# BUG scale>1 Xwayland in Weston is too large (Xwayland bug), rendering issues on tty (switching scaled/unscaled Xwayland on keyboard/mouse events)
#     bugreport: https://bugzilla.redhat.com/show_bug.cgi?id=1498669
# BUG x11docker-gui in weston freezes weston in combo boxes. Weston bug ? QT3/4 bug?
# BUG debian bug report lightdm/sddm contra gdm, dm can crash on tty switch if multiple graphical sessions are running
  :
}
