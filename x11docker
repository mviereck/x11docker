#! /bin/bash

# x11docker
# Run GUI applications and desktop environments in docker on a separate X server or Wayland compositor.
#
# - Circumvents common X security leaks. 
# - Improves container security restricting container capabilities
# - Container user is same as host user to avoid root in container.
#
# Type 'x11docker --help' or scroll down to read usage information.
# More documentation at   https://github.com/mviereck/x11docker

Version="4.1.2-beta"

usage() {               # --help: show usage information
  echo "
x11docker: Run GUI applications and desktop environments in docker.

 Optional features:
   * Hardware acceleration for OpenGL
   * Pulseaudio and ALSA sound
   * Clipboard sharing
   * Persistent home folders
   * Wayland support
   * Language locale creation
   * Init system support (systemd, SysVinit, OpenRC, runit, tini)
 Focus on security:
   * Avoids X security leaks using additional X servers.
   * Container user is same as host user to avoid root in container.
   * Restricts container capabilities to bare minimum.
    
Usage:
To run a docker image with new X server (auto-choosing X server):
  x11docker [OPTIONS] IMAGE [COMMAND]
  x11docker [OPTIONS] -- "'"[DOCKER_RUN_OPTIONS]"'" IMAGE [COMMAND [ARG1 ARG2 ...]]
To run a host application on a new X server:
  x11docker [OPTIONS] --exe COMMAND
  x11docker [OPTIONS] --exe -- COMMAND [ARG1 ARG2 ...]
To run only a new empty X server:
  x11docker [OPTIONS]
To run more than one command, use 'sh -c' syntax. Example: 
  x11docker [OPTIONS] -- IMAGE sh -c \"cd /etc && xterm\"

Dependencies on host:
  Depending on chosen options, x11docker needs some packages to be installed. 
  It will check for them on startup and show messages if some are missing. 
  List of possibly needed packages:
   * most recommended to allow security and convenience:
       xpra Xephyr xauth xrandr
   * advanced GPU support:
       weston Xwayland xdotool
   * less important: 
       xclip pulseaudio kwin_wayland nxagent xdpyinfo Xvfb
   * least important:
       xserver-xorg-legacy xserver-xorg-video-dummy xfishtank
       xdg-desktop-icon xdg-icon-resource unzip wget
       
Dependencies in image:
  Doesn't have dependencies inside of docker images, except for
  options --gpu, --lang and --pulseaudio, see below at option descriptions.
   
Options:
     --help            display this message and exit.
 -e, --exe             execute host application on new X server (no docker).
     --xonly           only create empty X server.
     
Basic settings: (especially influencing auto choosing X server)
 -d, --desktop         Indicate desktop environment in image.
 -g, --gpu             Hardware accelerated OpenGL rendering. Shares files in
                       /dev/dri. Works best with open source drivers installed
                       on host and OpenGL/Mesa in image. Closed source drivers 
                       need to be the very same on host and in image.
                       Degrades container isolation. Container access to GPU.
 -W, --wayland         Set up a wayland environment. (Some QT5 apps also need
                       option --dbus, some GTK3 apps must run without --dbus.)
 -w, --wm COMMAND      Host window manager to use for single applications in
                       nested X server options like --xephyr.
                       To autodetect a host wm, use --wm=auto or short: -wm
                       To set default autodetected window manager:
                           update-alternatives --config x-window-manager

Shared folders:
 -m, --home            Share a host folder ~/x11docker/imagename as home folder
                       in container (to store persistent data).
     --homedir DIR     Specify custom host folder DIR for option --home.
     --sharedir DIR    Share host folder (or file) DIR with r/w access.
                       (can be specified multiple times for multiple folders).
                       
Clipboard, sound, language:
 -c, --clipboard       Share clipboard between X servers (works best with xpra.
                       Most other X servers need xclip to be installed).
 -p, --pulseaudio      Sound with pulseaudio. Degrades isolation.
                       Needs 'pulseaudio' on host and in image.
     --alsa            Sound with ALSA. Shares devices in /dev/snd. You can
                       define desired sound card with: --env ALSA_CARD=cardname
                       Degrades isolation. Container access to sound hardware.
     --lang LOCALE     Language setting: search for utf8 LOCALE in image and 
                       create it if missing. Needs package 'locale' im image.
                       LOCALE can be e.g. ru, en, de, zh_CN, cz, fr, fr_BE.
                       Same as host: --lang=\$LANG.
                       
Special options:
     --no-internet     Disable internet access for container.
     --no-entrypoint   Disable ENTRYPOINT in image to allow other commands, too
     --workdir DIR     Set working directory DIR
     --env VAR=value   Set custom environment variable VAR=value
                       Special use case for user shell: '--env SHELL=/bin/sh'
     --showenv         Echo new \$DISPLAY, \$XAUTHORITY and \$WAYLAND_DISPLAY.
                       For custom access to new X server. Get environment with:
                         read xenv < <(x11docker --showenv [...])
     --sudouser        Allow sudo and su for container user. Use with care,
                       severe reduction of default x11docker security!
                       Password:  x11docker
     --add COMMAND     Add host command to xinitrc (sh syntax. You may need & ).
     --pw FRONTEND     Choose frontend for password prompt. Possible FRONTEND:
                         su sudo gksu gksudo lxsu lxsudo kdesu kdesudo
                         pkexec beesu none

X server options: 
     --auto            Auto choose X server for docker applications (default).
                       (Regards options --desktop, --gpu, --wayland and --wm).
 -a, --xpra            Use xpra to show application windows on host display.
                       (Needs 'xpra' on host. Get it from www.xpra.org.
                       With option --desktop xpra runs in nested desktop mode.)
 -y, --xephyr          Use nested X server Xephyr to show container desktops 
                       in a window on host display. (Needs 'Xephyr' or 'Xnest').
                       With option --wm=auto usefull for single apps, too.
 -n, --nxagent         Like --xpra for single applications, but faster startup.
                       With --desktop like --xephyr, but resizeable.
                       (Needs 'nxagent', best since nxagent version 3.5.99).
 -A, --xpra-xwayland   Like --xpra, but supports option --gpu.
                       (Needs 'xpra', 'Xwayland', 'weston' and 'xdotool').
 -Y, --weston-xwayland Like --xephyr, but supports option --gpu.
                       Runs as nested server in X or on its own from console. 
                       (Needs 'weston' and 'Xwayland'.)
 -h, --hostdisplay     Share host display :0, quite bad container isolation!
                       Least overhead of all X server options.
 -x, --xorg            Run new core Xorg server. Runs ootb from console.
                       Switch tty with <CTRL><ALT><F1>....<F12>.
                       To run from within X, edit '/etc/X11/Xwrapper.conf' and
                       replace line:        allowed_users=console
                       with lines           allowed_users=anybody
                                            needs_root_rights=yes
                       Debian 9 and Ubuntu 16.04: Install xserver-xorg-legacy.
                       
Special X servers:
     --kwin-xwayland   Like --weston-xwayland, but using kwin_wayland
                       (Needs 'kwin_wayland' and 'Xwayland').
 -X, --xwayland        Use Xwayland, needs a running Wayland compositor.
                       (Needs 'Xwayland' to be installed.)
     --xdummy          Invisible X server. (Needs Xorg's dummy video driver)
     --xvfb            Invisible X server. (Needs 'Xvfb')
                       --xdummy and --xvfb can be used for custom access,
                       for example with VNC or ssh. 
                       Output of environment variables on stdout. (--showenv)
                       Along with option --gpu an invisible setup with Weston,
                       Xwayland and xdotool is used (instead of Xdummy or Xvfb)
     --nothing         Do not provide any X or Wayland server.
                       
Wayland without X: (see also above: --wayland)
 -T, --weston          Weston without X for pure Wayland applications.
                       Runs in X or from console. (Needs package weston.)
 -K, --kwin            KWin without X for pure Wayland applications.
                       Runs in X or from console. (Needs kwin_wayland.)
 -H, --hostwayland     Share host Wayland without X for pure Wayland apps.
                       (Needs already running Wayland compositor like Gnome 3.)
                       (Can be combined with --hostdisplay.)

X and Wayland appearance options:
 -f, --fullscreen      Run Xephyr, nxagent or Weston in fullscreen mode.
     --size XxY        Screen size of new X server (e.g. 800x600).
 -l, --scale N         Scale/zoom factor N for xpra, Xorg or Weston. 
                       Allowed for --xpra, --xorg --xpra-xwayland: 0.25...8.0.
                       Allowed for --weston and --weston-xwayland: 1...9.
                       (Mismatching font sizes can be adjusted with --dpi).
     --rotate N        Rotate display (--xorg, --weston and --weston-xwayland)
                       Allowed values: 0, 90, 180, 270, flipped, flipped-90,
                       flipped-180, flipped-270.  (flipped = mirrored)
     --dpi N           dpi value (dots per inch) to submit to clients.
                       Influences font size of some applications.
     --output-count N  Multiple outputs for Weston, KWin or Xephyr.
     --xfishtank       Show fish tank on new X server (needs 'xfishtank').

X authentication: 
     --xhost STR       Set \"xhost STR\" on new X server (see 'man xhost').
                       (Use with care. '--xhost +' allows access for everyone).
 -o, --no-xhost        Disable any access to host X server granted by xhost.
     --no-auth         Disable cookie authentication on new X server.
     --trusted         Use trusted cookies for --hostdisplay
     --untrusted       Create untrusted cookies. Restricts X access. 
                       Default for --hostdisplay to avoid keylogging and
                       MIT-SHM errors. If --gpu is set, --trusted is used.

X and Wayland configuration:
     --display N       Use display number N for new X server.
     --vt N            Use vt / tty N (affects --xorg, --xdummy, --xpra).
     --keymap LAYOUT   Set keyboard layout for new X server, e.g. de, us, ru.
                       For possible LAYOUT look at /usr/share/X11/xkb/symbols.
     --xtest           Enable XTEST. Default for --xvfb, --xdummy, --xpra.
     --no-xtest        Disable XTEST. Default for most options.
     --westonini FILE  Custom weston.ini for --weston and --weston-xwayland.
                       
User settings:
     --user N          Create container user N (N=name or N=uid). Default: 
                       same as host user. N can also be an unknown user id.
                       You can specify a group id with N being 'user:gid'.
     --hostuser USER   Run X (and container user) as user USER. Default is
                       result of \$(logname). (x11docker must run as root).
                         
Init system and dbus daemon:
     --tini            Default: init system tini (built-in of docker).
     --no-init         No init system in container. Image command is PID 1.
     --runit           Init system runit. Degrades container isolation.
                       Needs 'runit' installed in image. 'dbus' is recommended.
     --openrc          Init system OpenRC. Degrades container isolation a bit,
                       but needs less capabilities than --runit and --systemd.
                       Needs 'openrc' installed in image. 'dbus' recommended.
     --sysvinit        Init system SysVinit. Degrades container isolation a bit,
                       but needs less capabilities than  others.
                       Needs 'sysvinit' installed in image. 'dbus' recommended.
     --systemd         Init system systemd. Degrades container isolation.
                       For faster startup mask services that fail in container.
                       Needs 'systemd' installed in image.
                       Old systemd versions in image need --sys-admin, too.
     --sharecgroup     Share /sys/fs/cgroup. Default for --systemd.
                       Can be used with --openrc.
 -b, --dbus            Run dbus user session daemon for image command.
     --dbus-system     Run dbus system daemon in container (includes --dbus).
                       Default for --systemd, --sysvinit, --openrc and --runit. 

Container capabilities:
     --hostipc         Sets docker option --ipc=host, disables IPC namespacing.
                       Severe reduction of container isolation! Shares 
                       host interprocess communication and shared memory. 
                       Allows MIT-SHM extension of X servers.
     --hostnet         Set docker run option --net=host, disables network
                       namespacing. Severe reduction of container isolation!
                       Shares host network stack, allows dbus communication.
     --cap-default     Allow default docker container capabilities and 
                       disable container security hardening of x11docker.
     --sys-admin       Add capability SYS_ADMIN. Please avoid that.
       Custom capabilities can be added with --cap-add=CAP after  --
     
Miscellaneous:
     --starter         Create starter on desktop and exit. You can move the
                       created .desktop file to ~/.local/share/applications
                       to get a menu entry.
     --cachedir DIR    Custom cache folder. (Default: \$HOME/.cache/x11docker)
     --license         Show license of x11docker (MIT) and exit.
     --ps              Preserve container and cache files on exit.
     --cleanup         Clean up orphaned containers and cache files.
       
Verbose options:
 -v, --verbose         Be verbose. (Shows logfiles).
     --silent          Do not show terminal messages (except errors).
     --debug           Debug mode: Show some debug output,
     --stdout          Show stdout of container applications.
     --stderr          Show stderr of container applications.

Installation options (need root permissions):
     --install         Install x11docker and x11docker-gui from current folder.
     --update          Download and install latest release from github.
     --update-master   Download and install latest master version from github.
     --remove          Remove x11docker from your system.

x11docker version: $Version
Please report issues at https://github.com/mviereck/x11docker
"
}
license() {             # --license: show license (MIT)
echo 'MIT License

Copyright (c) 2015, 2016, 2017, 2018 Martin Viereck

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.'
}
alertbox() {            # X alert box with title $1 and message $2
  local Title Message
  Title=${1:-}
  Message=${2:-}
  
  Message="$(echo "$Message" | LANG=C sed "s/[\x80-\xFF]//g" | fold -w120 )" # remove UTF-8 special chars; line folding at 120 chars

  # try some tools to show alert message. If all tools fail, return 1
  command -v   xmessage     >/dev/null && [ -n "$DISPLAY" ] && {
    echo "$Title

$Message" | xmessage  -file - -default okay ||:
  } || { 
    command -v gxmessage    >/dev/null && [ -n "$DISPLAY" ] && {
      echo "$Title

$Message" | gxmessage -file - -default okay ||:
    }
  } || { 
    command -v zenity       >/dev/null && [ -n "$DISPLAY" ] && {
      zenity --error --no-markup --ellipsize --title="$Title" --text="$Message" 2>/dev/null ||:
    }
  } || {
    command -v yad          >/dev/null && [ -n "$DISPLAY" ] && {
      yad  --image "dialog-error" --title "$Title" --button=gtk-ok:0 --text "$(echo "$Message" | sed 's/\\/\\\\/g')" --fixed 2>/dev/null ||:
    }
  } || {
    command -v kaptain      >/dev/null && [ -n "$DISPLAY" ] && {
      echo 'start "'$Title'" -> message @close=" cancel" ;
            message "'$(echo "$Message" | sed 's/\\/\\\\\\/g' | sed 's/"/\\"/g' | sed -E ':a;N;$!ba;s/\r{0,1}\n/\\n/g' )'" -> @fill ;'  | kaptain ||: 
    }
  } || {
    command -v kdialog      >/dev/null && [ -n "$DISPLAY" ] && {
      kdialog --title "$Title" --error "$(echo "$Message" | sed 's/\\/\\\\/g' )" 2>/dev/null ||:
    }
  } || {
    command -v xterm        >/dev/null && [ -n "$DISPLAY" ] && {
      xterm -title "$Title" -e "echo '$(echo "$Message" | sed "s/'/\"/g")' ; read -n1" ||:
    }
  } || {
    [ -n "$Anyterminal" ] && [ -e "$Cachefolder" ] && {
      mkfile $Cachefolder/message
      echo "#! /bin/bash
echo '$Title
      
$Message
(Press any key to close window)'
read -n1
" >> $Cachefolder/message
      $Anyterminal /bin/bash $Cachefolder/message ||:
    }
  } || {
    notify-send "$Title: 

$Message" 2>/dev/null 
  } || return 1
  return 0
}
error() {               # show error messages on stderr and exit
  Message="$*
  
  Type 'x11docker --help' for usage information
  For debugging, run x11docker in terminal and/or enable option '--verbose'
  and look afterwards at logfile $Logfile3
  Please report issues at https://github.com/mviereck/x11docker"
  
  # output to terminal
echo -e "
\033[41mx11docker ERROR:\033[49m $Message
" >&2
  # output to X dialogbox
  [ -n "$Hostxenv" ] && export $Hostxenv
  [ -n "$Newxenv" ] && {
    [ "$Tty" = "yes" ] && export $Newxenv
    [ "$Xserver" = "--xorg" ] && export $Newxenv
  }
  alertbox "x11docker ERROR" "$Message"

  # output to logfile
  [ -e "$Logfile" ] && echo "x11docker ERROR: $Message
" >> "$Logfile"

  saygoodbye
  touch $Errorfile
  exit 1 # trap to finish()
}
warning() {             # show warning messages
  echo "$(tput setaf 3)x11docker WARNING:$(tput sgr0) $*" >&3
  echo "" >&3
  [ -e "$Logfile" ] && echo "x11docker WARNING: $*
" >> "$Logfile"
  return 0
}
note() {                # show notice messages
  echo "$(tput setaf 2)x11docker note:$(tput sgr0) $*" >&3
  echo "" >&3
  [ -e "$Logfile" ] && echo "x11docker note: $*
" >> "$Logfile"
  return 0
}
notestdout() {          # write something on stdout
  echo "$*" >&5
}
verbose() {             # show verbose messages
  # only logfile notes here, terminal output is done with tail in part:verbose
  [ -e "$Logfile" ] && echo "x11docker: $*
" >> "$Logfile"
  return 0
}
installer() {           # --install, --update, --update-master, --remove: Installer for x11docker
  # --install:
  #   - copies x11docker and x11docker-gui to /usr/bin
  #   - installs icon in /usr/share/icons
  #   - creates x11docker.desktop file in /usr/share/applications
  # --update:
  #   - download and install latest release from github
  # --update-master:
  #   - download and install latest master version from github
  # --remove
  #   - remove installed files
  local X11dockericonfile Key1 Key2 Oldversion Newversion
  export PATH="$PATH:/usr/local/bin"  # avoid bug on opensuse where root does not have this in $PATH. Will become obsolete as new default is /usr/bin
  
  # Prepairing
  case ${1:-} in
    --install)
      [ -f "./x11docker" ]             || { error "File x11docker not found in current folder.
  Try 'x11docker --update' instead." ; }
      command -v x11docker > /dev/null && { warning "x11docker seems to be installed already.
  Will overwrite existing installation.
  Consider to use option '--update' or '--update-master' instead." ; }
    ;;
    --update|--update-master)
      Oldversion="$($0 --version)"
      note "Current installed version: x11docker $Oldversion"
      
      [ -d /tmp/x11docker-install ] && rm -R /tmp/x11docker-install
      mkdir -p /tmp/x11docker-install && cd /tmp/x11docker-install || error "Could not create or cd to /tmp/x11docker-install" 
      command -v wget >/dev/null  || error "wget not found. Need 'wget' for download.
  Please install wget."
      command -v unzip >/dev/null || error "Can not unpack archive. Please install 'unzip'."
  
      case ${1:-} in
        --update-master)
          note "Downloading latest x11docker master version from github"
          wget https://github.com/mviereck/x11docker/archive/master.zip -O x11docker-update.zip || error "Could not download x11docker-master from github"
        ;;
        --update)
          note "Downloading latest x11docker release from github"
          wget https://www.github.com/$(wget "https://github.com/mviereck/x11docker/releases/latest" -O - | grep "\.zip" | cut -d'"' -f2) -O x11docker-update.zip || error "Could not download latest x11docker release from github"
        ;;
      esac
  
      note "Unpacking archive"
      unzip x11docker-update.zip || error "Could not unzip archive"
  
      echo ""
      cd /tmp/x11docker-install/$(ls -l | grep drwx | rev | cut -d' ' -f1 | rev) || error "could not cd to /tmp/x11docker-update/$(ls -l | grep drwx | rev | cut -d' ' -f1 | rev)"
    ;;
  esac

  # Doing
  case ${1:-} in
    --install|--update|--update-master)
      note "Installing x11docker and x11docker-gui in /usr/bin"
      [ -e /usr/local/bin/x11docker ]     && rm -v /usr/local/bin/x11docker
      [ -e /usr/local/bin/x11docker-gui ] && rm -v /usr/local/bin/x11docker-gui
      cp x11docker /usr/bin/            || error "Could not copy x11docker to /usr/bin"
      chmod 755 /usr/bin/x11docker      || error "Could not set executeable bit on x11docker"
      cp x11docker-gui /usr/bin/  && chmod 755 /usr/bin/x11docker-gui || warning "x11docker-gui not found"
      
      note "Installing icon for x11docker with xdg-icon-resource"
      xdg-icon-resource install --context apps --novendor --mode system --size 64 "$(pwd)/x11docker.png" x11docker || warning "Could not install icon for x11docker.
  Is 'xdg-icon-resource' installed on your system?"
      
      note "Creating application entry for x11docker"
      [ -e "/usr/bin/x11docker-gui" ] && {
        echo "[Desktop Entry]
  Version=1.0
  Type=Application
  Name=x11docker
  Comment=Run GUI applications in docker images
  Exec=x11docker-gui
  Icon=x11docker
  Categories=System
" > /usr/share/applications/x11docker.desktop
      } || note "Did not create desktop entry for x11docker-gui"
      command -v kaptain >/dev/null || note "Could not find 'kaptain' for x11docker-gui.
  Consider to install 'kaptain' (version 0.73 or higher). 
  It's useful for x11docker-gui only, though. x11docker itself doesn't need it. 
  If your distributions does not provide kaptain, look at kaptain repository:  
    https://github.com/mviereck/kaptain
  Fallback: x11docker-gui will try to use image x11docker/kaptain."

      note "Storing README.md, CHANGELOG.md and LICENSE.txt in /usr/share/doc/x11docker"
      mkdir -p /usr/share/doc/x11docker && {
        cp README.md    /usr/share/doc/x11docker/
        cp CHANGELOG.md /usr/share/doc/x11docker/
        cp LICENSE.txt  /usr/share/doc/x11docker/
      } || note "Error while creating /usr/share/doc/x11docker"
      
      Newversion="$(/usr/bin/x11docker --version)"
      note "Installation ready: x11docker version $Newversion"
    ;;
    --remove)
      note "removing x11docker from your system"
      [ -x /usr/local/bin/x11docker ] && {    # from older installations. /usr/bin is default now as /usr/local/bin can miss in $PATH for root
        /usr/local/bin/x11docker --cleanup
        rm -v /usr/local/bin/x11docker
        rm -v /usr/local/bin/x11docker-gui
      }
      [ -x /usr/bin/x11docker ] && {
        /usr/bin/x11docker --cleanup
        rm -v /usr/bin/x11docker
        rm -v /usr/bin/x11docker-gui
      }
      [ -e "/usr/share/applications/x11docker.desktop" ] && rm -v /usr/share/applications/x11docker.desktop
      [ -e "/usr/share/doc/x11docker" ]                  && rm -R -v /usr/share/doc/x11docker
      [ -e "/usr/share/icons/x11docker.png" ]            && rm /usr/share/icons/x11docker.png
      xdg-icon-resource uninstall --size 64 x11docker ||:
      xdg-icon-resource uninstall --size 72 x11docker ||:  # deprecated icon size, may still be present.
      note "Will not remove files in your home folder.
  There may be files left in \$HOME/.local/share/x11docker
  The symbolic link \$HOME/x11docker may exist, too.
  The cache folder \$HOME/.cache/x11docker should be removed already." 
    ;;
  esac
  
  # Cleanup
  case ${1:-} in
    --update|--update-master)
      note "Removing downloaded temporary files ..."
      cd ~
      rm -R /tmp/x11docker-install
    ;;
  esac
  
  # Changelog excerpt
  case ${1:-} in
    --update)
      echo "$Oldversion" | grep -q beta && {
        warning "You are switching from master branch to stable releases.
  To get latest master beta version, use option --update-master instead"
        Key1="\[${Newversion}\]"
        Key2="https:\/\/github.com\/mviereck\/x11docker\/releases"
      } || {
        Key1="\[${Newversion}\]"
        Key2="\[${Oldversion}\]"
        [ "$Newversion" = "$Oldversion" ] && {
          Key2="https:\/\/github.com\/mviereck\/x11docker\/releases" 
          note "Version $Newversion was already installed before this update.
  If you want the latest beta version from master branch, use --update-master."
        }
      }
    ;;
    --update-master)
      echo "$Oldversion" | grep -q beta && {
        Key1="\[Unreleased\]"
        Key2="https:\/\/github.com\/mviereck\/x11docker\/releases"
      } || {
        Key1="\[Unreleased\]"
        Key2="\[${Oldversion}\]"
      }
    ;;
  esac
  case ${1:-} in
    --update|--update-master)
      note "Excerpt of x11docker changelog:
$(sed -n '/'$Key1'/,/'$Key2'/p' /usr/share/doc/x11docker/CHANGELOG.md | head -n-1)"
    ;;
  esac

  note "Ready."
}
checkorphaned() {       # --cleanup : check for non-removed containers and left cache files
  local Orphanedcontainers Orphanedfolders Line
  note "x11docker will check for orphaned containers from earlier sessions.
  This can happen if docker was not closed successfully. 
  x11docker will look for those containers and will clean up x11docker cache.
  Caution: any currently running x11docker sessions will be terminated, too."
  Orphanedcontainers=""
  Orphanedfolders=""
  cd $Cacherootfolder || error "Could not cd to cache folder '$Cacherootfolder'."
  [ $? ] && [ -n "$(echo "$Cacherootfolder" | grep .cache/x11docker)" ] && Orphanedfolders=$(echo $(find "$Cacherootfolder" -mindepth 1 -maxdepth 1 -type d | sed s%$Cacherootfolder/%%))
  Orphanedcontainers="$(docker ps -a --filter name=x11docker_X --format "{{.Names}}")"
  Orphanedcontainers="$(env IFS='' echo $Orphanedcontainers)"
  if [ -z "$Orphanedcontainers" ] && [ -z "$Orphanedfolders" ] ; then 
    note "No orphaned containers or cache files found. good luck!"
  else
    note "Found orphaned containers: 
  $Orphanedcontainers"
    note "Found orphaned folders in $Cacherootfolder:
  $Orphanedfolders" 
    for Line in $Orphanedfolders ; do
      [ -d "$Cacherootfolder/$Line/share" ] && [ ! -e "$Cacherootfolder/$Line/share/timetosaygoodbye" ] && {
        note "Found possibly active container $Line.
  Will summon it to terminate itself."
        touch "$Cacherootfolder/$Line/share/timetosaygoodbye"  # terminating possibly running x11docker sessions
        sleep 3
      }
    done
    [ -n "$Orphanedcontainers" ] && {
      note "Removing containers with: docker rm -f $Orphanedcontainers
$(bash -c "docker rm -f $Orphanedcontainers" 2>&1)"
    }
    [ -n "$Orphanedfolders" ] && {
      note "Removing cache files with: rm -R -f $Orphanedfolders
$(rm -R -f $Orphanedfolders 2>&1)"
    }
  fi
  note "Ready."
}
storepid () {           # store pids and names of background processes in file $Bgpidfile
  # store Pid and process name of background processes in file
  # $1 should be Pid, $2 should be name of process
  # for use on exit / with trap to clean up with background processes
  # this subroutine has a twin in xinitrc
  echo ${1:-} ${2:-} >> $Bgpidfile
  verbose "stored background pid ${1:-} of ${2:-}"
}
saygoodbye() {          # create file signaling watching processes to terminate
  verbose "Creating $Timetosaygoodbye"
  [ -e "$Sharefolder" ] && $Mksu "touch $Timetosaygoodbye"
}
finish() {              # trap EXIT routine to clean up background processes and cache
  local Pid Name Zeit
  trap - EXIT
  verbose "terminating x11docker ..."
  sleep 1 # a bit time for background processes like mywatch() to look for $Timetosaygoodbye (most look once a 1 second)
  [ -s "$Bgpidfile" ] && {
    # check for possible remaining background processes stored in $Bgpidfile
    while read -r Line ; do 
      Pid=$(echo $Line | awk '{print $1}')
      Name=$(echo $Line | awk '{print $2}')
      ps -p $Pid --no-headers >/dev/null && {
        verbose "terminating background pid $Pid of $Name"
        case $Name in
          windowmanager) 
            Windowmanager="$(basename "$Windowmanager" | cut -d' ' -f1)"
            ps -p $Pid | grep $Windowmanager >/dev/null           && pkill $Pid
          ;;
          xpraserver|xpraclient)
            ps -p $Pid | grep 'xpra' >/dev/null                   && pkill $Pid
          ;;
          compositor)
            ps -p $Pid | grep -E 'weston|kwin_wayland' >/dev/null && kill $Pid
          ;;
          x11docker-run|mywatch|xpraloop)
            ps -p $Pid | grep x11docker >/dev/null                && pkill $Pid
          ;;
          hostexe|shareclipboard)
            ps -p $Pid | grep 'bash' >/dev/null                   && pkill $Pid
          ;;
          xfishtank)
            ps -p $Pid | grep 'xfishtank' >/dev/null              && pkill $Pid
          ;;
          container) 
            [ -n "$Sudo" ] && Sudo="sudo -n" # no password prompt here, rather fail
            $Sudo docker stop $Containername >/dev/null 2>&1 || {
              ! $Sudo docker images >/dev/null 2>&1 || { [ -n "$($Sudo docker ps --filter name=$Containername --quiet 2>&1)" ] || ps -p $Pid >/dev/null ; } && {
                note "Found remaining container process. Most probably the X session was
  interrupted. Can not stop container because x11docker does not run as root.
  Will wait up to 10 seconds for docker to finish."
                Zeit=$(date +%s)
                while ps -p $Pid >/dev/null ; do
                  note "waiting for container to terminate ..."
                  sleep 1
                  [ 10 -lt $(($(date +%s) - $Zeit)) ] && break ||:
                done
                if ps -p $Pid >/dev/null ; then
                  note "docker container didn't terminate as it should. 
  Will not clean cache to avoid file permission issues. 
  You can remove the new container with command:
docker rm -f $Containername
  Afterwards, remove cache files with:
rm -R $Cachefolder
  or let x11docker do the cleanup work for you: 
x11docker --cleanup"
                  Preservecachefiles="yes"
                else
                  note "docker container terminated successfully"
                fi
              }
            }
          ;;
          *) # should never happen (tm)
            note "Found remaining background process.
  Will send signal KILL to $Line
  $(ps -p $Pid --no-headers)"
            pkill -KILL $Pid
            sleep 1
            ps -p $Pid --no-headers && warning "error killing $Pid $Name"
          ;;
        esac
        ps -p $Pid --no-headers >/dev/null && sleep 1
        ps -p $Pid --no-headers >/dev/null && warning "error terminating $Pid $Name"
      }
    done < <(tac $Bgpidfile)
  }
  saygoodbye
  sleep 0.5 # a bit time for all processes to finish log output
  [ -n "$Logfile2$Logfile3" ] && $Mksu "cp '$Logfile2' '$Logfile3'"
  rm "$Logfile"

  [ "$Preservecontainer" = "yes" ] && Preservecachefiles="yes"
  [ "$Preservecachefiles" = "no" ] && echo "$Cachefolder" | grep -q .cache && echo "$Cachefolder" | grep -q x11docker && [ "x11docker" != "$(basename "$Cachefolder")" ] && rm -f -R "$Cachefolder"
  if [ -e "$Errorfile" ]; then rm "$Errorfile" ; exit 1; else exit 0; fi
}
traperror() {           # trap ERR: --debug: Output for 'set -o errtrace'
  warning "Command at Line ${2:-} returned with error code ${1:-}:
  ${4:-}
  ${3:-} - ${5:-}" 
}
verlte() {              # version number check $1 less than or equal $2
  [  "${1:-}" = "$(echo -e "${1:-}\n${2:-}" | sort -V | head -n1)" ] && return 0 || return 1
}
verlt() {               # version number check $1 less than $2 
  [ "${1:-}" = "${2:-}" ] && return 1 || { verlte "${1:-}" "${2:-}" && return 0 || return 1 ; }
}
mywatch() {             # repeat $1 untils its output changes
  local Watchoutput
  # --interval must be integer for centos and fedora depite contrary documentation in manpage
  verbose "Watching: sh -c '${1:-}'
  Current output:
$(sh -c "${1:-}" ||:)"
  env TERM=linux watch --interval 1 --chgexit --no-title -- "${1:-}" >/dev/null 2>&1
  #Watchoutput="$(sh -c "${1:-}" 2>&1)"
  #while sleep 1 ; do
  #  [ "$Watchoutput" = "$(sh -c "${1:-}" 2>&1)" ] || break
  #done
  verbose "Stopped watching: sh -c '${1:-}'
  Current output:
$(sh -c "${1:-}" ||:)"
}
isnum() {               # check if $1 is a number
  [ "1" = "$(awk -v a="${1:-}" 'BEGIN {print (a == a + 0)}')" ]
}
escapestring() {        # escape special chars of $1
  # escape all characters except those described in [^a-zA-Z0-9,._+@=/-]
  echo "${1:-}" | LC_ALL=C sed -e 's/[^a-zA-Z0-9,._+@=/-]/\\&/g; 1{$s/^$/""/}; 1!s/^/"/; $!s/$/"/'
}
writeaccess() {         # check if useruid $1 has write access to folder $2
  local dirVals gMember IFS
  if IFS=$'\t' read -a dirVals < <(stat -Lc "%U	%G	%A" "${2:-}") && (
    ( [ "$(id -u $dirVals)" == "${1:-}" ] && [ "${dirVals[2]:2:1}" == "w" ] ) ||
    ( [ "${dirVals[2]:8:1}" == "w" ] ) ||
    ( [ "${dirVals[2]:5:1}" == "w" ] && (
        gMember=($(groups ${1:-} 2>/dev/null)) &&
        [[ "${gMember[*]:2}" =~ ^(.* |)${dirVals[1]}( .*|)$ ]]
    ) ) )
  then
    return 0
  else
    [ "w" = "$(getfacl -pn "${2:-}" | grep user:${1:-}: | rev | cut -c2)" ] && return 0 || return 1   # FIXME: could check write access for gid, if uid access fails.
  fi 
}
waitforfilecreation() { # similar to inotify-wait: wait up to 15s for file $1 to be created
  # $1 file to wait for
  # $2 time to wait. default: 15s. possible: infinity
  local Zeit Warten
  Zeit=$(date +%s)
  verbose "Waiting for file creation of ${1:-}"
  case ${2:-} in
    "")           Warten=15 ;;
    infinity|inf) Warten=32000 ;; # nearly infinity in fast-moving today ...
    *)            Warten=${2:-} ;;
  esac
  while [ ! "$(find  "${1:-}" 2>/dev/null)" ] ; do
    sleep 0.2
    [ $Warten -lt $(($(date +%s) - $Zeit)) ] && {
      warning "Failed to wait for file creation of
  ${1:-}"
      return 1
    }
    verbose "waiting since $(($(date +%s) - $Zeit))s for ${1:-} to be created, will wait up to $Warten seconds."
    [ -e "$Timetosaygoodbye" ] && {
      verbose "stopped waiting for ${1:-} due to terminating signal."
      return 1
    }
  done
  verbose "Found new created file $(ls ${1:-})"
  sleep 0.1
  return 0
}
waitforfilecontent() {  # wait for file $1 to be not empty
  local Zeit Warten
  # $1 file to look at
  Zeit=$(date +%s)
  Warten=15
  verbose "Waiting for file content in ${1:-}"
  while [ ! -s "${1:-}" ] ; do
    sleep 0.2
    [ $Warten -lt $(expr $(date +%s) - $Zeit) ]  && return 1
    verbose "waiting since $(expr $(date +%s) - $Zeit)s for ${1:-} to have content, will wait up to $Warten seconds."
    [ -e "$Timetosaygoodbye" ] && {
      verbose "stopped waiting for file content of ${1:-} due to terminating signal."
      return 1
    }  done
  verbose "Found file content in ${1:-}"
  return 0
}
waitforlogentry() {     # wait for entry $3 in logfile $2 of application $1
  # $1 is the application we are waiting for to be ready
  # $2 points to logfile
  # $3 keyword to wait for 
  local Zeit Warten
  Zeit=$(date +%s)
  Warten=24
  while ! cat "${2:-}" | grep -q "${3:-}" ; do
#    verbose "waiting since $(expr $(date +%s) - $Zeit)s for ${1:-} to be ready..."
    verbose "waiting since $(expr $(date +%s) - $Zeit)s for ${1:-} to be ready..."
    sleep 0.2
    [ $Warten -lt $(expr $(date +%s) - $Zeit) ] && return 1
    [ -e "$Timetosaygoodbye" ] && {
      verbose "stopped waiting for logentry in ${2:-} of ${1:-} due to terminating signal."
      return 1
    }  done
  verbose "${1:-} is ready."
  return 0
}
no_xhost() {            # remove any access to X server granted by xhost
  local Line
  xhost
  xhost | tail -n +2  /dev/stdin | while read -r Line ; do  # read all but the first line (header)
    xhost -$Line                                         # disable every entry
  done
  xhost -                                                # enable access control
  [ "$(xhost | wc -l)" -gt "1" ] && { 
    warning "Remaining xhost permissions found on display $DISPLAY
$(xhost)"
    return 1
  }
  return 0
}
mkfile() {              # create file $1 owned by $Hostuser
  :> "${1:-}"
  chown $Hostuser    "${1:-}"
  chgrp $Hostusergid "${1:-}"
  [ -n "${2:-}" ] && chmod ${2:-} "${1:-}" ||:
}

{ #### part: declare variables
trap finish EXIT

export IFS=$' \n\t'                                 # set IFS to default
exec 3>&2                                           # second stderr channel
exec 4>&2                                           # stderr channel for --stderr
exec 5>&1                                           # second stdout channel
pstree -ps $$ | grep -q sshd && Ssh="yes" || Ssh="no"
tty | grep -q tty && Tty="yes" || Tty="no"          # check if running on X or on tty
[ "$Tty" = "no" ] && [ -z "$DISPLAY" ] && [ "$Ssh" = "yes" ] && Tty="yes"
export PATH="$PATH:/usr/games:/usr/local/bin"       # may miss for root, but can be needed for --exe and --xfishtank
export PATH="$PATH:/usr/sbin:/sbin"                 # may miss for unprivileged users, but can be needed for `ip`

# Logfiles
Mycookie=$(mcookie | cut -b1-6)
[ -z "$Mycookie" ] && Mycookie=$RANDOM
export Logfile=/tmp/x11docker.$Mycookie.log     # collection of all Logfiles. Stored in /tmp because cache is not ready yet
touch $Logfile && chmod 666 $Logfile
Logfile2=                                       # live copy of $Logfile in $Sharefolder
Logfile3=                                       # afterward copy of $Logfile in $Cacherootfolder
Errorfile=/tmp/x11docker.error.$Mycookie        # error indicating file created by error()

Bgpidfile=backgroundpids                        # file to store pids and names of background processes that shut be killed on exit
Timetosaygoodbye=timetosaygoodbye               # file giving term signal to all parties

# Users
Lognameuser=""                                  # $(logname) or $SUDO_USER or $PKEXEC_USER
Hostuser=""                                     # $Lognameuser or --hostuser. Unprivileged user for non-root commands
Hostuseruid=""
Hostusergid=""
Hostuserhome=""
Benutzer=""                                     # option --user: container user. Default: same as $Hostuser.
Benutzeruid=""
Benutzergid=""
Benutzerhome=""
Benutzergruppe=""
Benutzerpasswdentry=""
Benutzerpasswort="sac19FwGGTx/A"                # encrypted password "x11docker", suits /etc/shadow. Created with: perl -e 'print crypt("x11docker", "salt"),"\n"'
Mksu=""                                         # prefix to run unprivileged commands (auto or --hostuser)
Mksubenutzer=""                                 # prefix to run commands as user defined by --user
Hostgidaudio=""                                 # host GID of group audio. Can differ from container GID
Hostgidvideo=""                                 # host GID of group video. Can differ from container GID

# Gaining root privileges to run docker
Passwordprompt=""                               # way to ask for password. one of pkexec, su, sudo, gksu, gksudo, auto
Getroot=""                                      # prefix for commands needing root (only dockerrc script)
Sudo=""                                         # "sudo" or empty
Needpassword="yes"                              # Need password? assume yes, check later

# Cache folders
Cacherootfolder=""                              # cache folder to store temporary files
Cachefolder=""
Sharefolder=share                               # subfolder for shared files
Cshare=/x11docker                               # mountpoint of $Sharefolder in container

# Parsed arguments
X11dockermode="run"                             # can be either "xonly", "run" or "exe", depends on options. while parsing, xonly changes to run or exe
X11dockerargs="$*"                              # arguments for x11docker
Imagename=""                                    # name of image to run
Imagecommand=""                                 # image command [+args]
Hostexe=""                                      # can contain host executable
Dockeroptions=""                                # options for docker after -- and before image name

# docker variables
Containername=""                                # name of container set by x11docker to make --cleanup able to find orphaned containers
Containerpid=""                                 # process ID of script process with docker container

# docker related files
Dockerrc=dockerrc                               # init script run by docker. Creates $Imagecommandscript
Imagecommandscript=x11docker.CMD.sh             # name of shared script containing image command
Dockerlogfile=docker.log                        # file to log output of docker
Containerpidfile=container.pid                  # file to store process ID of script -c docker
Containeridfile=container.id                    # file to store process ID of script -c docker
Containerip=container.ip                        # IP adress of container
Setupscript=containersetup.sh

# X server config files, log files and such stuff
Xinitrc=xinitrc                                 # file to store xinitrc commands
Xinitlogfile=xinit.log                          # file to log output of X server
Xtermrc=xtermrc                                 # file for password prompt script
Pullrc=pullrc                                   # file for pull dialog script
Compositorlogfile=compositor.log                # file to log output of Weston or KWin 
Compositorpidfile=compositor.pid                # process id of compositor
Xpraserverlogfile=xpraserver.log                # logfile for xpra server
Xpraclientlogfile=xpraclient.log                # logfile for xpra client
Westonini=weston.ini                            # config file for weston
Customwestonini=""                              # custom config file for weston
Xdummyconf=xdummy.xorg.conf                     # xorg.conf for dummy video driver
Xdummywrapper=Xdummywrapper                     # fork from xpra to wrap Xorg for Xdummy
Xservercookie=Xservercookie                     # file to store new X server cookies
Xclientcookie=Xclientcookie                     # file to store new X client cookies
Xkbkeymapfile=xkb_keymap                        # file to store output of 'setxkbmap -display $Hostdisplay -print'

# stdin stdout stderr
Cmdstdinfile=stdin                              # stdin for image command piped to x11docker
Cmdstdoutlogfile=stdout                         # stdout for image command
Cmdstderrlogfile=stderr                         # stderr for image command

# host environment
Hostsystem="$(source /etc/os-release ; echo $ID)"
Hostdisplay="$DISPLAY"                          # store environment variable containing name of current display
Hostdisplaynumber="$(echo $Hostdisplay | cut -d: -f2 | cut -d. -f1)"                         # display number without ":" and ".0"
Hostxauthority="Xauthority-$Hostdisplaynumber"                                               # file to store copy of $XAUTHORITY
[ -n "$Hostdisplay" ] && Hostxsocket="/tmp/.X11-unix/X$Hostdisplaynumber" || Hostxsocket=""  # X socket from host, needed for --hostdisplay
[ -e "$Hostxsocket" ] || Hostxsocket=""                                                      # can miss in SSH session

# X server settings
Xserver=""                                      # X server to use
Xcommand=""                                     # command to start X server
Newdisplay=""                                   # new display for new X server
Newdisplaynumber=""                             # Like Newdisplay, but without ':'
Newxsocket=""                                   # New X socket
Newxenv=""                                      # environment variables for new X server DISPLAY XAUTHORITY XSOCKET WAYLAND_DISPLAY
Newxvt=""                                       # Virtual console to use for core new X server (>7)
Newxlock=""                                     # .Xn-lock - exists for running X server with socket n
Xserveroptions=""                               # options for new X server
Xpraservercommand=""
Xpraclientcommand=""
Xpraoptions=""                                  # options for xpra server and client
Xprashm=""                                      # content XPRA_XSHM=0 disables usage of MIT-SHM in xpra
Xpraversion=""                                  # $(xpra --version)
Nxagentoptions=""                               # options for nxagent
Xephyroptions=""                                # options for Xephyr
Xephyrglamor="yes"                              # former option '--glamor': enable Xephyr glamor 2D acceleration (deprecated, now always yes)
Xfishtank="no"                                  # --fish: xfishtank on new X server
Xtest=""                                        # enable extension Xtest yes/no. If empty, yes for --xpra/--xdummy/--xvfb, otherwise no
Xkblayout=""                                    # option '--keymap': Layout for keymap, compare /usr/share/X11/xkb/symbols 

# Main X server options
Autochooseserver="yes"                          # option '--auto': automated choosing server
Desktopmode="no"                                # option --desktop: image contains a desktop enironment.
Windowmanager=""                                # option '-w, --wm': window manager to use. if not given but needed, autodetection is used
Gpu="no"                                        # option '--gpu': Use hardware accelerated OpenGL, share files in /dev/dri

# Screensize and related X server adjustments
Screensize=""                                   # option --size  XxY
Xaxis=""                                        # virtual screen width
Yaxis=""                                        # virtual screen height
Modeline=""                                     # screen modeline describing display size, see "man cvt"
Maxxaxis=""                                     # describes maximal screen size of display to support fullscreen beside windowed desktop
Maxyaxis=""
Fullscreen="no"                                 # option '-f, --fullscreen': use fullscreen mode (Xephyr only)
Scaling="0"                                     # option --scale: Scaling factor for xpra and weston
Rotation=""                                     # option --rotate: Rotation for --weston and --weston-xwayland 0/90/180/270/flipped/flipped-90/..
Dpi=""                                          # option --dpi: dots per inch to tell the clients.
Outputcount="1"                                 # option --output-count, quantum of virtual screens for Weston and Xephyr

# Wayland and Weston
Hostwayland="$WAYLAND_DISPLAY"                  # store host wayland display
Compositorcommand=""                            # command to start Weston or KWin
Waylandsocket=""                                # Wayland socket for Xwayland in weston
Waylandtoolkitenv=("XDG_SESSION_TYPE=wayland GDK_BACKEND=wayland QT_QPA_PLATFORM=wayland CLUTTER_BACKEND=wayland SDL_VIDEODRIVER=wayland ELM_DISPLAY=wl ELM_ACCEL=opengl ECORE_EVAS_ENGINE=wayland_egl")
Compositorpid=""                                # pid of weston or kwin
Westonoutput=""                                 # Xn, WLn or monitor identifier
Sharewayland="no"                               # option --sharewayland: Share wayland socket and WAYLAND_DISPLAY
Setwaylandenv="no"                              # option --setwaylandenv: Set environment variables $Waylandtoolkitenv
Dbuslaunch="no"                                 # option '--dbus': run image command with dbus-launch
Dbusdaemon="no"                                 # option '--dbus-dameon': set up dbus daemon in container

# Available terminal emulators
Passwordterminal=""                             # terminal emulator to use for password prompt (if no terminal emulator is needed, it will be 'bash -c')
Pullterminal=""                                 # terminal emulator to show progress of 'docker pull'
Anyterminal=""                                  # terminal emulator for alert()
Terminallist=""                                 # list of possible terminal emulators. Only a few work on wayland

# regular options
Benutzerhosthome="no"                           # option '-m, --home' (or '--homedir'): share a folder ~/.local/share/x11docker/Imagename with created container
Benutzerhosthomefolder=""                       #   "        "   : path to shared folder. 
Sharevolumes=""                                 # option --volume: host folders to share, array
Sharevolumescount="0"                           # counts shared folders in array
Shareclipboard="no"                             # option '-c, --clipboard' enable clipboard sharing
Shareclipboardscript=clipboard.bash             #    "              "      script used for text clipboard sharing
Showdisplayenvironment="no"                     # option -E, --env: Show environment variables of new display
Customenvironment=""                            # option '--env': set custom environment variables 
Pulseaudio="no"                                 #   "                    use pulseaudio yes/no
Pulseserver=""
Pulseaudioconf=pulseclient.conf
Pulseaudiosocketdir=""
Pulseaudiosocketname=""
Alsa="no"                                       # option --alsa: enable ALSA sound, share /dev/snd
Noentrypoint="no"                               # option --no-entrypoint: disable entrypoint in image
Internetaccess="yes"                            # option --no-internet: disable internet access
Langwunsch=""                                   # option --lang: search or create UTF-8 locale and set LANG
Workdir=""                                      # option --workdir: set working directory

# verbosity options
Verbose="no"                                    # option '-v, --verbose': if "yes", be verbose
Showstdout="no"                                 # option --stdout: show image command stdout
Showstderr="no"                                 # option --stderr: show image command stderr
Silent="no"                                     # option --silent: do not show messages
Verbosecolors="yes"                             # colored output for --verbose and deleting some systemd error messages. currently without option.
Debug="no"                                      # option --debug: Throw it all out
DebugPS4='+ \033[32m${LINENO}:${FUNCNAME[0]:+${FUNCNAME[0]}(): }\033[0m'

# developer options
Sudouser="no"                                   # option --sudouser: Create user and root with sudo permissions with password 'x11docker'
Capdropall="yes"                                # option --cap-default: (don't) drop all container capabilities
Adminusercaps="no"                              # options --sudouser, --systemd: add capabilities for general sys administration
Switchcontaineruser="no"                        # options --dbus, --sudouser and initsystems: add capabilities for su/sudo user switching
Sharehostipc="no"                               # option --hostipc, set --ipc=host.
Sharehostnet="no"                               # option --hostnet, set --ipc=net
Preservecachefiles="no"                         # if yes, dont delete cache files
Preservecontainer="no"                          # option '-p, --ps': if yes, preserve container instead of removing it with 'docker run --rm'
Initsystem="tini"
Capsysadmin="no"                                # option --sys-admin: add capability SYS_ADMIN (deprecated)
Sharecgroup="no"                                # options --systemd, --cgroup: share /sys/fs/cgroup
Addcommand=""                                   # option --add: add host command to xinitrc

# X authentication
Xauthentication="yes"                           # option '--no-auth' use cookie authentication yes/no
Trusted="yes"                                   # create trusted or untrusted cookies, see --trusted and --untrusted. Important for --hostdisplay
Forcetrusted="no"                               # option --trusted: enforce trusted cookies for --hostdisplay
Noxhost="no"                                    # option '--no-xhost': if yes, disable all X server access granted by xhost
Xhost=""                                        # option '--xhost': xhost + on new X server

# special options not starting X or docker
Checkorphaned="no"                              # option '--cleanup': check for non-removed containers and maybe root-owned files in cache
Createdesktopstarter="no"                       # option '--starter': create desktop starter and exit yes/no
Installermode=""                                # options --install/--update/--remove

# some temporary or loop variables
Pid=""
Name=""
Zeit=""
Line=""
Count=""

# these window managers are known to work well with x11docker (alphabetical order)(excluding $Wm_not_recommended and $Wm_ugly):
Wm_good="amiwm blackbox cinnamon compiz ctwm enlightenment fluxbox flwm fvwm"
Wm_good="$Wm_good jwm kwin lxsession mate-session mate-wm marco metacity notion olwm olvwm openbox ororobus pekwm"
Wm_good="$Wm_good sawfish twm wmaker w9wm xfwm4"
# these wm's are recommended and lightweight, but cannot show desktop options. best first:
Wm_recommended_nodesktop_light="xfwm4 metacity marco sawfish"
# these wm's are recommended and heavy, but cannot show desktop options (especially exiting themselves). best first:
Wm_recommended_nodesktop_heavy="kwin compiz"
# these wm's are recommended, lightweight AND desktop independent. best first:
Wm_recommended_desktop_light="flwm blackbox fluxbox jwm mwm wmaker afterstep amiwm fvwm ctwm pekwm olwm olvwm openbox" 
# these wm's are recommended, heavy AND desktop independent. best first:
Wm_recommended_desktop_heavy="lxsession mate-session enlightenment cinnamon cinnamon-session plasmashell"
# these wm's are not really useful (please don't hit me) (best first):
Wm_not_recommended="awesome evilwm herbstluftwm i3 lwm matchbox miwm spectrwm subtle windowlab wmii wm2"
# these wm's cannot be autodetected by wmctrl if they are already running
Wm_nodetect="aewm aewm++ afterstep awesome ctwm mwm miwm olwm olvwm sapphire windowlab wm2 w9wm"
# these wm's can cause problems (they can be beautiful, though):
Wm_ugly="icewm sapphire aewm aewm++"
# these wm's doesn't work:
Wm_bad="clfswm tinywm tritium mutter muffin gnome-shell"
# List of all working window managers, recommended first: (excluding $Wm_bad)
Wm_all="$Wm_recommended_nodesktop_light $Wm_recommended_nodesktop_heavy  $Wm_recommended_desktop_light $Wm_recommended_desktop_heavy $Wm_good $Wm_ugly $Wm_not_recommended $Wm_nodetect"
}

{ #### part: parsing cli options
  Shortoptions="aAbcdeEfgGhHKml:MnNopPrsSutTvw:WxXyY"
  Longoptions="auto,x,X,xpra,xephyr,x11,xorg,hostdisplay,xwayland,weston-xwayland,xpra-xwayland,nxagent,wayland"           # X servers
  Longoptions="$Longoptions,weston,hostwayland,kwin,kwin-xwayland,xdummy,xvfb,nothing"                                     # more X/Wayland servers
  Longoptions="$Longoptions,wm:,desktop,exe,xonly"
  Longoptions="$Longoptions,fullscreen,size:,glamor,scale:,rotate:,dpi:,output-count:,gpu,xfishtank"                       # screen options
  Longoptions="$Longoptions,user:,home,clipboard,pulseaudio,alsa,lang:"                                                    # comfort options
  Longoptions="$Longoptions,no-xhost,trusted,untrusted,dbus,dbus-system,pw:,no-internet,workdir:"                          # advanced options
  Longoptions="$Longoptions,tini,no-init,systemd,runit,openrc,sysvinit,sys-admin,sharecgroup"                              # init system options
  Longoptions="$Longoptions,starter,cleanup,license,licence,help,version,install,update,update-master,remove,wmlist"       # special options without starting X server
  Longoptions="$Longoptions,xhost:,no-auth,vt:,display:,xtest,no-xtest,env:,showenv"                                       # X and environment options
  Longoptions="$Longoptions,verbose,stdout,stderr,silent,debug"                                                            # verbose options
  Longoptions="$Longoptions,hostipc,hostnet,ps,cache,cap-default,no-entrypoint,sudouser,hostuser:"                         # capabilities, users
  Longoptions="$Longoptions,cachedir:,homedir:,westonini:,sharedir:,keymap:,add:"                                          # developer options
  Longoptions="$Longoptions,xsocket,tcp,tcpxsocket,virtualgl,glamor,volume:,xhost+,resizeable,orphaned,rw"                 # deprecated
  Longoptions="$Longoptions,xpra-image,xpra-attach,xorg-image,xdummy-image,kwin-native,nopwd,no-password,root,sudo"        # deprecated
  Longoptions="$Longoptions,ipc,net,dbus-daemon,dbusdaemon,sharewayland,waylandenv"                                        # deprecated

  Parsedoptions="$(getopt --options $Shortoptions --longoptions $Longoptions --name "$0" -- "$@" 2>/tmp/x11docker_parsererror)"
  [ -e /tmp/x11docker_parsererror ] && Parsererror=$(cat /tmp/x11docker_parsererror) && rm /tmp/x11docker_parsererror
  [ -n "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"

  [ "$*" = "-h --" ] &&    usage         && exit 0         # catch single -h for usage info, otherwise it means --hostdisplay
  
  while [ $# -gt 0 ] ; do
    case "${1:-}" in
      --help)              usage         && exit 0  ;;     # show help/usage and exit
      --license|--licence) license       && exit 0  ;;     # show MIT license and exit
      --version)           echo $Version && exit 0  ;;     # output version number and exit

      -e|--exe)        X11dockermode="exe"   ;;            # execute application from host instead of running docker image
         --xonly)      X11dockermode="xonly" ;;            # only create X erver
         
     #### X servers
         --auto)                                                   Autochooseserver="yes" ;; # use xpra or --xephyr, --xorg or hostdisplay, --xpra-xwayland or --weston-xwayland
      -a|--xpra)                     Xserver="--xpra" ;            Autochooseserver="no"  ;; # use xpra on host
      -y|--xephyr)                   Xserver="--xephyr" ;          Autochooseserver="no"  ;; # use Xephyr
      -x|--xorg|--x11)               Xserver="--xorg" ;            Autochooseserver="no"  ;; # use core Xorg
      -h|--hostdisplay)              Xserver="--hostdisplay" ;     Autochooseserver="no"  ;; # use host display :0 with shared X socket
      -X|--xwayland)                 Xserver="--xwayland" ;        Autochooseserver="no"  ;; # Xwayland needs already running Wayland
      -A|--xpra-xwayland)            Xserver="--xpra-xwayland" ;   Autochooseserver="no"  ;; # Xpra with Xwayland
      -Y|--weston-xwayland)          Xserver="--weston-xwayland" ; Autochooseserver="no"  ;; # Weston-Xwayland as Wayland compositor with Xwayland, runs in X or standalone from console
         --xdummy)                   Xserver="--xdummy" ;          Autochooseserver="no" ; Showdisplayenvironment="yes" ;;  # use Xdummy. Invisible on host. For custom network setups with VNC or xpra
         --xvfb)                     Xserver="--xvfb" ;            Autochooseserver="no" ; Showdisplayenvironment="yes" ;;  # use Xvfb. Invisible on host. For custom network setups with VNC or xpra
         --nothing)                  Xserver="--nothing" ;         Autochooseserver="no"  ;; # Do not provide any X nor Wayland
      -T|--weston)                   Xserver="--weston" ;          Autochooseserver="no"  ;; # Wayland in Weston only, no X
      -H|--hostwayland)            [ "$Xserver" = "--hostdisplay" ] || Xserver="--hostwayland" # share host wayland. Allow coexistence with option --hostdisplay
                                     Sharewayland="yes" ;          Autochooseserver="no"  ;;
      -K|--kwin)                     Xserver="--kwin" ;            Autochooseserver="no"  ;;
         --kwin-xwayland)            Xserver="--kwin-xwayland" ;   Autochooseserver="no"  ;;
      -n|--nxagent)                  Xserver="--nxagent" ;         Autochooseserver="no"  ;;
      -W|--wayland)                  Sharewayland="yes" ; Setwaylandenv="yes"             ;; # set up wayland environment, regards --desktop
      
     #### Influencing X server 
      -d|--desktop)    Desktopmode="yes" ;;                # image contains a desktop environment.
      -g|--gpu)        Gpu="yes" ;;                        # share files in /dev/dri
      -w|--wm)         case ${2:-} in
                         ""|"n"|"none") Windowmanager="none" ;;
                         "m"|"auto")    Windowmanager="auto" ;;
                         *)             Windowmanager=${2:-} ;;
                       esac
                       shift 
                       Desktopmode="yes" ;;
                       
     #### Appearance
      -f|--fullscreen) Fullscreen="yes"  ;;                # fullscreen mode for Xephyr and Weston
         --size)       Screensize="${2:-}" ;  shift ;;     # set virtual screen size
      -l|--scale)      Scaling=${2:-} ; shift ;;           # zoom
         --rotate)     Rotation=${2:-} ; shift ;;          # rotation and mirroring
         --dpi)        Dpi=${2:-} ; shift ;;               # dots per inch / influences font size
         --output-count) Outputcount="${2:-}" ; shift ;;   # number of virtual outputs
         --xfishtank)   Xfishtank="yes" ;;                 # Run xfishtank on new X server
         
     #### Options
      -m|--home)       Benutzerhosthome="yes" ;;                # share folder ~/x11docker/Imagename with container
      -c|--clipboard)  Shareclipboard="yes"  ;;            # share host clipboard with dockered applications (xpra only)
         --alsa)       Alsa="yes" ;;                       # enable ALSA sound (shares /dev/snd)
      -p|--pulseaudio) Pulseaudio="yes"  ;;                # enable pulseaudio sound with shared pulse socket
         --lang)       Langwunsch=${2:-} ; shift ;;        # locale/language setting
      
     #### Advanced options
      -b|--dbus)       Dbuslaunch="yes" ;;                 # run image command with dbus-launch or dbus-run-session
         --no-entrypoint) Noentrypoint="yes" ;;            # don't use ENTRYPOINT of image
         --no-internet)Internetaccess="no" ;;              # disallow internet access
         --workdir)    Workdir="$(escapestring "${2:-}")" ; shift ;; # set working directory
         --pw)         Passwordprompt="${2:-}" ; shift ;;  # frontend for password prompt
         --add)        Addcommand="${2:-}" ; shift ;;      # add custom host command in xinitrc
         
     #### Verbose options
      -v|--verbose)    Verbose="yes"  ;;                   # be verbose
         --stdout)     Showstdout="yes" ;;                 # show stdout of image command
         --stderr)     Showstderr="yes" ;;                 # show stderr of image command
         --silent)     Silent="yes" ; exec 3>/dev/null ;;  # do not show warnings or errors
         --debug)      Debug="yes" ;;                      # debugging mode
      
     #### Developer options
       ## User settings
         --user)       Benutzer="${2:-}"  ; shift ;;       # set container user instead of host user
         --hostuser)   Hostuser="${2:-0}"                  # set host user different from logged in user
                       [ "$(echo $Hostuser | cut -c1)" = "-" ] && {  ### FIXME: fuzzy validation, not reliable
                         warning "You are using --hostuser without an argument.
  Maybe you are using it in deprecated form to have container user similar
  to host user. That is default now. Now, option --hostuser expects an 
  argument to specify a different user than default user $(logname)"
                         Hostuser=""
                       } || shift ;;
         --sudouser)   Sudouser="yes" ;;                   # give container user sudo without password
         
       ## init system
         --no-init)    Initsystem="none" ;;                # no init, image command is PID 1
         --tini)       Initsystem="tini" ;;                # default init system tini (run option --init)
         --runit)      Initsystem="runit" ;;               # run runit as init system and image command as a service
         --openrc)     Initsystem="openrc" ;;
         --systemd)    Initsystem="systemd" ;;             # run systemd as init system and image command as a service
         --sysvinit)   Initsystem="sysvinit" ;;
         --sharecgroup)Sharecgroup="yes" ;;                # share /sys/fs/cgroup. default for --systemd, possible use with --openrc
         --sys-admin)  Capsysadmin="yes" ;;                # add capability SYS_ADMIN for older systemd versions in image (i.e. debian 9 needs it, debian 10 runs well)
         --dbus-system|--dbus-daemon|--dbusdaemon) Dbusdaemon="yes" # set up dbus system daemon
                       { [ "${1:-}" = "--dbus-daemon" ] || [ "${1:-}" = "--dbusdaemon" ] ;} && note "Option --dbus-daemon changed to --dbus-system.
  Please use --dbus-system in future." ;;                  
         
       ## Environment
         --showenv)    Showdisplayenvironment="yes" ;;     # output of display number and cookie file on stdout. Catch with  ~$ read xdenv < <(x11docker --showenv)
         --env)        Customenvironment="$(escapestring "${2:-}")
$Customenvironment"    ;  shift ;;                         # set custom environment variables
         --vt)         Newxvt="vt${2:-}" ;       shift ;;  # set virtual console to use
         --display)    Newdisplaynumber=${2:-}             # display number to use
                       [ "$(echo $Newdisplaynumber | cut -c1)" = ":" ] && Newdisplaynumber="$(echo $Newdisplaynumber | cut -c2-)"
                       shift ;;
         --xtest)      Xtest="yes" ;;                      # allow extension XTEST. default for xvfb, xdummy and xpra
         --no-xtest)   Xtest="no" ;;                       # disable extension XTEST. default for most X server options
         --keymap)     Xkblayout="${2:-}" ; shift ;;       # keymap layout for xkbcomp. Compare /usr/share/X11/xkb/symbols 
         
       ## X Authentication
         --xhost)      Xhost="xhost $2" ; shift ;;         # set 'xhost +' on both X servers
         --xhost+)     Xhost="xhost +"  ;;                 # set 'xhost +' on both X servers (deprecated, please use --xhost N)
         --no-auth)    Xauthentication="no" ;;             # disable cookie authentication
      -o|--no-xhost)   Noxhost="yes"  ;;                   # disable any access granted by xhost
         --trusted)    Forcetrusted="yes"  ;;              # force trusted cookies for --hostdisplay
      -t|--untrusted)  Trusted="no"  ;;                    # create untrusted cookies

         
       ## host folders
         --homedir)    Benutzerhosthomefolder="${2:-}" ; Benutzerhosthome="yes" ; shift ;; # set host folder to share as home folder instead of ~/x11docker/NAME
         --cachedir)   Cacherootfolder="${2:-}" ; shift ;; # set cache folder instead of default $Cacherootfolder
         --sharedir)   [ -e "${2:-}" ] && {                # share host folder at same location in container with rw access
                         Sharevolumescount=$(($Sharevolumescount + 1))
                         Sharevolumes[$Sharevolumescount]="${2:-}"
                       } || warning "Option --sharedir: file or folder not found.
  ${2:-}" ;            shift ;;
         
       ## docker options
         --hostipc|--ipc) Sharehostipc="yes"                   # docker run option --ipc=host
                       [ "${1:-}" = "--ipc" ] && note "Option --ipc changed to --hostipc.
  Please use --hostipc in future." ;; 
         --hostnet|--net) Sharehostnet="yes"                   # docker run option --net=host 
                       [ "${1:-}" = "--net" ] && note "Option --net changed to --hostnet.
  Please use --hostnet in future." ;; 
         --cap-default) Capdropall="no" ;;                 # don't use --cap-drop=ALL

       ## miscellaneous
         --ps)         Preservecontainer="yes"  ;;         # preserve container instead of removing it with 'docker run --rm'
         --westonini)  Customwestonini="${2:-}" ; shift ;; # custom weston.ini

     #### special options not starting X or docker
      --starter)       Createdesktopstarter="yes" ;;       # create desktop starter and exit
      --cleanup)       Checkorphaned="yes"  ;;             # check for orphaned containers and files owned by root, created by docker)
      --orphaned)      Checkorphaned="yes" ; note "Option '--orphaned' is now called '--cleanup'." ;;
      --install|--update|--update-master|--remove) Installermode="${1:-}" ;;   # installer
      --wmlist)        echo $Wm_all ; exit 0 ;;            # special option for x11docker-gui to retrieve list of window managers

     #### deprecated
      --rw)                                                                       note "Option --rw is deprecated. 
  x11docker allows read/write access to container root file system now." ;;
      --virtualgl|--tcpxsocket|--xsocket|--tcp|--cache)                           note "Option ${1:-} is deprecated and has no effect now." ;; 
   -r|--resizeable)                                                               note "Option --resizeable is deprecated.
  Xephyr tends to crash on resize." ;;
      --xpra-image|--xpra-attach|--xorg-image|--xdummy-image)                    error "Option ${1:-} is no longer included." ;;
      --volume)              Sharevolumes="$Sharevolumes\n${2:-}" ; shift ;       note "Option --volume is now called --sharedir
  to avoid confusion with divergent docker run option --volume.
  Please use --sharedir instead." ;;
   -P|--nopwd|--no-password) Passwordprompt="none" ;                              note "Option --no-password is deprecated. 
  x11docker checks on its own if it can run docker without password prompt.
  To explicitly disable password prompt,  you can set '--pw=none'" ;;
   -s|--sudo)               Passwordprompt="sudo" ;                               note "Option --sudo is deprecated.
  x11docker checks on its own if sudo is needed or possible.
  To explicitly use sudo, you can set '--pw=sudo'" ;;
      --root)                Hostuser="root" ;                                    note "Option --root is deprecated.
  To have root in container, use --user=root.
  To run X as root (discouraged!), use --hostuser=root.
  Fallback: Setting discouraged option --hostuser=root" ;;
      -N|--kwin-native)      Xserver="--kwin-xwayland" ; Autochooseserver="no" ;  note "Option --kwin-native is deprecated.
  Fallback: using option --kwin-xwayland." ;;
      -S|--sharewayland) Sharewayland="yes" ;                                     note "Option --sharewayland is deprecated.
  Wayland is shared with options --wayland, --hostwayland, --weston and --kwin." ;;
      -E|--waylandenv) Setwaylandenv="yes" ;                                      note "Option --waylandenv is deprecated.
  Use option --wayland instead." ;;


      ##### custom docker options / image name + image command
      --) shift
        while [ $# -gt 0 ] ; do
          [ -n "${1:-}" ] && [ -z "$Imagename" ] && [ "$(echo "${1:-}" | cut -c1)"  = "-" ]  && Dockeroptions="$Dockeroptions ${1:-}"
          [ -n "${1:-}" ] && [ -z "$Imagename" ] && [ "$(echo "${1:-}" | cut -c1)" != "-" ]  && Imagename="${1:-}" && shift
          [ -n "${1:-}" ] && [ -n "$Imagename" ] && Imagecommand="$Imagecommand$(escapestring "${1:-}") "
          shift
        done
        [ -z "$Imagename" ] && X11dockermode="xonly"
      ;;
      '') ;;
      *) error "Unknown option ${1:-}
  Parsed options:
  $Parsedoptions" ;;
    esac  
    shift
  done
}

{ #### part: check host user
  # check host user, want an unprivileged one to run X server
  # default behaviour:
  #  x11docker started as unprivileged user:          starting X server as this user and create same user in container
  #  x11docker started as root:                       determine real user with $(logname), instead of root use real user like above
  #  x11docker started as root with --hostuser=root:  root runs X server and root is container user (discouraged)
  #                                                   if you want root in container, just use --user=root
  #  x11docker with --user=someuser                   container user is someuser, host user is unprivileged user $(logname)
  # 
  # root permissions are only needed to run docker. If started unprivileged, a password prompt appears.
  
  # not root? Use current user.
  [ -z "$Hostuser" ] && [ "$(id -un)" != "root" ] && Hostuser="$(id -un)"
  
  # root? find unprivileged user
  Lognameuser="$(logname 2>/dev/null)"
  [ -z "$Lognameuser" ] && [ -z "$Hostuser" ] && warning "Your terminal seems to be not POSIX compliant.
  Command 'logname' does not return a value.
  Consider to use another terminal emulator.
  Fallback: Will try to check \$SUDO_USER and \$PKEXEC_UID."
  [ -z "$Lognameuser" ] && [ -n "${SUDO_USER:-}" ]  && Lognameuser="${SUDO_USER:-}"  && [ -z "$Hostuser" ] && note "Will use \$SUDO_USER = ${SUDO_USER:-} as host user."
  [ -z "$Lognameuser" ] && [ -n "${PKEXEC_UID:-}" ] && Lognameuser="${PKEXEC_UID:-}" && [ -z "$Hostuser" ] && note "Will use user with uid \$PKEXEC_UID = ${PKEXEC_UID:-} as host user."
  [ -z "$Lognameuser" ] &&                         Lognameuser="$(id -un)"   && [ -z "$Hostuser" ] && note "Will use \$(id -un) = $Lognameuser as host user."
  
  # option --hostuser
  [ -z "$Hostuser" ] && Hostuser=$Lognameuser
  [ "$Hostuser" != "$Lognameuser" ] && {
    [ "$(id -un)" = "root" ] || error "x11docker must run as root to choose a host user
  different from user '$Lognameuser'. (option --hostuser)"
  }
  getent passwd $Hostuser >/dev/null 2>&1 || error "Could not find user '$Hostuser' in /etc/passwd."
  
  Hostuser=$(id -un $Hostuser)
  Hostuseruid=$(id -u $Hostuser)
  Hostusergid=$(id -g $Hostuser)
  Hostuserhome=$(getent passwd $Hostuser | cut -d: -f6)

  # Mksu: prefix to run command as unprivileged host user
  [ "$Hostuser" = "$(id -un)" ] && Mksu="bash -c" || Mksu="su $Hostuser -c"  # differenciated as only root can use su on itself and others without password
  
  chown $Hostuser $Logfile
  
  [ "$Hostuser" = "root" ] && warning "Running as user root. 
  Maybe \$(logname) did not provide an unprivileged user. 
  Please use option --hostuser=USER to specify an unprivileged user.
  Otherwise, new X server runs as root, and container user will be root."
  
  [ -z "$Hostuserhome" ] && error "No home directory found for user '$Hostuser'.
  You need to specify option --cachedir.
  (Also specify --homedir if you want to use option --home)."
  
  [ -z "$Cacherootfolder" ] && Cacherootfolder="$Hostuserhome/.cache/x11docker"
  
  # Need host GIDs to use in container
  Hostgidaudio=$(getent group audio | cut -d: -f3)
  Hostgidvideo=$(getent group video | cut -d: -f3)
}

{ #### part: some init
  verbose "$(date) $(source /etc/os-release ; echo "$PRETTY_NAME") $(Xorg -version 2>&1 | grep X.Org)
Command: $0 $X11dockerargs
Parsed options: $Parsedoptions"

  [ "$Debug" = "yes" ] && {
    #PS4="$DebugPS4"    # useful output for set -x
    #set -x             # show every executed line
    set -Eu -o pipefail 
    trap 'traperror $? $LINENO $BASH_LINENO "$BASH_COMMAND" $(printf "::%s" ${FUNCNAME[@]})'  ERR
  }
  
  [ "$Cacherootfolder" != "$(echo $Cacherootfolder | sed -e 's/ *//g')" ] && error "Cache root folder must not contain whitespaces.
  $Cacherootfolder"
    
  # options --install --update --remove
  [ -n "$Installermode" ] && {
    [ "0" = "$(id -u)" ] || error "Must run as root to install, update or remove x11docker."
    installer $Installermode
    exit
  }
   
  # option --cleanup: check for non-removed containers and left cache files
  [ "$Checkorphaned" = "yes" ] && {
    docker images >/dev/null 2>&1 || error "'x11docker --cleanup' must run as root."   ### FIXME: could be more flexible
    checkorphaned
    exit
  }
  
  [ "$Tty" = "no" ] && [ -z "$Hostdisplay" ] && warning "Environment variable DISPLAY is empty, but
  it seems x11docker was started within X, not from console. 
  Please set DISPLAY and XAUTHORITY.
  If you have started x11docker with su or sudo, su/sudo may be configured to
  unset X environment variables. It may work if you run x11docker with
    sudo -E x11docker [...]
  If your system does not support 'sudo -E', you can try
    sudo env DISPLAY=\$DISPLAY XAUTHORITY=\$XAUTHORITY x11docker [...]
  Otherwise, you can use tools like gksu/gksudo/kdesu/kdesudo/lxsu/lxsudo."
  
  [ "$Sudouser" = "yes" ] && warning "You allow $Benutzer sudo permissions (password: x11docker).
  Also, the container gains additional capabilities to allow sudo and su.
  This is a severe reduction of default x11docker security.
  If an application breaks out of container, it can harm your system
  in every way without you noticing."
  
  # check whether x11docker runs on tty1-tty6, number can be changed with --vt N
  # console users have to use their own tty for X since debian 9
  [ "$Tty" = "yes" ] && [ "$Newxvt" = "" ] && {
    Newxvt="vt$(tty | rev | cut -d/ -f1 | rev | tr -d ty)"
    [ "$Ssh" = "yes" ] && Newxvt=""
  }
  
  # Weston and Xwayland need XDG_RUNTIME_DIR
  [ -z "$XDG_RUNTIME_DIR" ] && [ -e "/run/user/$Hostuseruid" ] && export XDG_RUNTIME_DIR="/run/user/$Hostuseruid" 
  [ -z "$XDG_RUNTIME_DIR" ] && {
    $Mksu "mkdir -p /tmp/XDG_RUNTIME_DIR.x11docker.$Hostuseruid"
    export XDG_RUNTIME_DIR=/tmp/XDG_RUNTIME_DIR.x11docker.$Hostuseruid
    $Mksu "chmod 700 $XDG_RUNTIME_DIR"
  }
  [ -n "$Customwestonini" ] && [ ! -e "$Customwestonini" ] && { 
    warning "Custom weston.ini (option --westonini) not found.
  $Customwestonini"
    Customwestonini=""
  }
  
  # validate $WAYLAND_DISPLAY
  [ -n "$Hostwayland" ] && [ ! -S "$XDG_RUNTIME_DIR/$Hostwayland" ] && {
    warning "WAYLAND_DISPLAY $Hostwayland is set, but does not exist
  or is not a socket.
  $XDG_RUNTIME_DIR/$Hostwayland"
    Hostwayland=""
  }
  
  [ "$Initsystem" = "tini" ] && {
    docker run --help | grep -q ' --init' || {
      warning "Your docker version seems to be outdated
  and does not support \"docker run --init\".
  It is recommended to update docker to have a minimal container init system.
  Fallback: disabling init system in container with x11docker option --no-init."
      Initsystem="none"
    }
    command -v docker-init >/dev/null || { 
      note "docker-init not found in PATH.
  This is probably a docker packaging error of your distribution.
  Zombie process reaping will not work.
  Fallback: Running x11docker with option --no-init."
      Initsystem="none"
    }
  }
  
  [ "$Capdropall" = "no" ] && warning "Option --cap-default disables security hardening
  for containers. Granting docker's default capabilities is considered insecure."
  
  [ "$Capsysadmin" = "yes" ] && warning "Option --sys-admin may be dangerous.
  It adds insecure capability SYS_ADMIN to container.
  It is needed to run debian 9 images with option --systemd.
  Debian 10 images run well without --sys-admin."  
}

{ #### part: check X server dependencies, use fallbacks if needed, auto-choose X server
  ## option '--auto': Try to automatically choose best matching and available X server
  [ "$Autochooseserver" = "yes" ] && {
    Xserver="--xpra"
    [ -n "$Hostwayland" ]      && Xserver="--xpra-xwayland"
    [ "$Gpu" = "yes" ]         && Xserver="--xpra-xwayland"
    [ "$Xfishtank" = "yes" ]   && [ "$Desktopmode" = "no" ] && Xserver="--xephyr"
    [ "$Desktopmode" = "yes" ] && Xserver="--xephyr"
    [ -z "$Imagename" ]        && { Xserver="--xephyr" ; Desktopmode="yes" ; }
    [ "$Xserver" = "--xephyr" ] && { command -v "Xephyr" >/dev/null 2>&1 || command -v "Xnest" >/dev/null 2>&1 || Xserver="--weston-xwayland" ; } # try weston if Xephyr and Xnest are missing
    [ "$Gpu" = "yes" ] && [ "$Xserver" = "--xephyr" ]  && Xserver="--weston-xwayland"
    [ -z "$Hostdisplay" ] && Xserver="--xorg"
    [ "$Outputcount" != "1" ]  && Xserver="--weston-xwayland"
    [ -n "$Rotation" ]         && Xserver="--weston-xwayland"
    [ "$Scaling" != "0" ] && [ "$Gpu" = "yes" ] && Xserver="--xpra-xwayland"
    [ "$Scaling" != "0" ] && [ "$Gpu" = "no" ]  && Xserver="--xpra"
    [ -z "$Hostdisplay" ] && [ -n "$Hostwayland" ] && Xserver="--xwayland"
    [ "$Sharewayland" = "yes" ] && {
      [ -n "$Hostwayland" ] && [ "$Desktopmode" = "no" ] && Xserver="--hostwayland" || Xserver="--weston"
    }
  }

  [ "$Gpu" = "yes" ] && case $Xserver in
    --xpra) 
      note "Option --xpra does not support GPU access.
  Fallback: Will try to use option --xpra-xwayland."
      Xserver="--xpra-xwayland"
    ;;
    --xephyr)
      note "Option --xephyr does not support GPU access.
  Fallback: Will try to use option --weston-xwayland."
      Xserver="--weston-xwayland"
    ;;
    --nxagent)
      note "Option --nxagent does not support GPU access.
  Fallback: Will try to use option --xpra-xwayland."
      Xserver="--xpra-xwayland"
    ;;
    --xdummy|--xvfb) 
      note "Using special setup with Weston, Xwayland and xdotool
  instead of Xdummy or Xvfb to allow GPU access."
      Xserver="--xdummy-xwayland"
    ;;
  esac
  
  ## check if dependencies for chosen X server are installed, fall back to best alternatives if not

  [ "$Xserver" = "--xvfb" ] && { 
    command -v Xvfb >/dev/null || { note "Xvfb not found.
  Fallback: Will try to use Xdummy (option --xdummy)."
      Xserver="--xdummy"
    }
  }
  
  [ "$Xserver" = "--hostwayland" ] && [ -z "$Hostwayland" ] && {
    note "WAYLAND_DISPLAY is not set, but is needed for --hostwayland.
  Fallback: Will try to run Weston (option --weston)."
    Xserver="--weston"
  }
  
  [ "$Xserver" = "--nxagent" ] && {
    command -v "nxagent" >/dev/null 2>&1 || {  
      [ "$Desktopmode" = "yes" ] && Xserver="--xephyr" || Xserver="--xpra"
      [ "$Autochooseserver" = "no" ] && note "could not find executable 'nxagent'. 
  Fallback: Will try to use option $Xserver"
    }
  }
  
  case $Xserver in
    --xpra)
      command -v "xpra" >/dev/null 2>&1 || { 
        [ "$Autochooseserver" = "no" ] && note "could not find executable 'xpra'. 
  Fallback: x11docker will try to use --nxagent or --xephyr."
        command -v nxagent >/dev/null && Xserver="--nxagent" || Xserver="--xephyr"
      }
    ;;
    --xpra-xwayland)
      command -v "xpra" >/dev/null 2>&1 || { 
        [ "$Autochooseserver" = "no" ] && note "could not find executable 'xpra'. 
  Fallback: x11docker will try to use option --weston-xwayland."
        Xserver="--weston-xwayland" 
      }
    ;;
  esac
  
  case $Xserver in 
    --xpra-xwayland)
      command -v weston >/dev/null || { 
        [ "$Autochooseserver" = "no" ] && case $Desktopmode in
          yes) note "Could not find executeable weston.
  Fallback: Will try kwin_wayland with xwayland (option --kwin-xwayland)."
            Xserver="--kwin-xwayland" ;;
          no) note "Could not find executeable weston.
  Fallback: Will use insecure option --hostdisplay instead.
  If you have kwin_wayland installed, you can try --kwin-xwayland instead."
            Xserver="--hostdisplay" ;;
        esac
      }
    ;;
  esac
  
  [ "$Xserver" = "--nxagent" ] && [ "$Hostsystem" = "mageia" ] && {
    [ "$Desktopmode" = "no" ] && [ "$Autochooseserver" = "yes" ] && Desktopmode="yes" && Windowmanager="auto"
    [ "$Desktopmode" = "no" ] && warning "nxagent version 3.5.0 on Mageia 6 is known to crash
    in seamless mode. (Detected version: '$(strings --bytes 20 /usr/libexec/nx/nxagent | grep "NXAGENT - Version")').
    If you encounter issues, please try seamless --xpra (secure), 
    --hostdisplay (insecure), or run --nxagent in desktop mode with a
    host window manager (--wm=WINDOWMANAGER or --wm=auto or -wm)."
  }
  
  [ "$Xserver" = "--xwayland" ] && [ -z "$Hostwayland" ] && {
    [ "$Autochooseserver" = "no" ] && note "WAYLAND_DISPLAY is not set. 
  Fallback: Will try option --weston-xwayland (weston and Xwayland)."
    Xserver="--weston-xwayland"
  }
  
  case $Xserver in
    --kwin|--kwin-xwayland) command -v kwin_wayland >/dev/null || { 
      [ "$Autochooseserver" = "no" ] && note "kwin_wayland not found.
  Fallback: Will try to use weston instead."
      [ "$Xserver" = "--kwin" ] && Xserver="--weston" || Xserver="--weston-xwayland" 
    } ;;
  esac
  
  case $Xserver in
    --weston)
      command -v "weston" >/dev/null 2>&1 || { 
        [ "$Autochooseserver" = "no" ] && note "could not find executable 'weston'. 
  Fallback: x11docker will try to use 'kwin_wayland' (option --kwin)."
        Xserver="--kwin"
      } ;;
    --weston-xwayland|--xdummy-xwayland)
      command -v "weston" >/dev/null 2>&1 || { 
        [ "$Autochooseserver" = "no" ] && note "could not find executable 'weston'. 
  Fallback: x11docker will try to use 'kwin_wayland' (option --kwin-xwayland)."
        Xserver="--kwin-xwayland"
      } ;;
  esac
  
  case $Xserver in
    --kwin|--kwin-xwayland) command -v kwin_wayland >/dev/null || { 
      [ "$Autochooseserver" = "no" ] && note "kwin_wayland not found.
  Fallback: Will try to use Xephyr (option --xephyr) instead."
      Xserver="--xephyr" 
    } ;;
  esac
  
  case $Xserver in
    --xwayland|--weston-xwayland|--kwin-xwayland|--xdummy-xwayland|--xpra-xwayland)
      command -v "Xwayland" >/dev/null 2>&1 || { 
        [ "$Autochooseserver" = "no" ] && note "could not find executable 'Xwayland'. 
  Fallback: x11docker will try to use Xephyr (option --xephyr)."
        Xserver="--xephyr" 
      } ;;
  esac
  
  [ "$Xserver" = "--xephyr" ] && {
    command -v "Xephyr" >/dev/null 2>&1 || { 
      [ "$Autochooseserver" = "no" ] && note "could not find executable 'Xephyr'. 
  Fallback: x11docker will try to use Xnest, nxagent or xpra."
      command -v Xnest >/dev/null || {
        command -v nxagent >/dev/null && Xserver="--nxagent" || Xserver="--xpra"
      }
    }
    [ "$Autochooseserver" = "yes" ] && [ "$Gpu" = "yes" ] && {
      case $Desktopmode in
        yes) Xserver="--xorg" ;;
        no)  Xserver="--hostdisplay" ;;
      esac
      note "Did not find a satisfying solution to provide hardware
  acceleration with option --gpu. Best solutions to provide security:
  Either install: xpra weston Xwayland xdotool (seamless mode support)
  or install: weston Xwayland (desktop mode)
  or install: kwin_wayland Xwayland (desktop mode)
  or use options: --xorg --gpu (may need additional setup).
  Fallback: Using option $Xserver"
    }
  }
  
  [ "$Xserver" = "--xpra" ] && { command -v "xpra" >/dev/null 2>&1 || { 
      [ "$Autochooseserver" = "no" ] && note "could not find executable 'xpra'. 
  Fallback: x11docker will try to use --hostdisplay or --xorg."
      [ "$Desktopmode" = "yes" ] && Xserver="--xorg" || Xserver="--hostdisplay"
    }
  }
  
  case $Xserver in
    --xpra|--xpra-xwayland)
      Xpraversion="$(xpra --version)"
      verlt "$Xpraversion" "xpra v1.0" && {
        note "Your xpra version '$Xpraversion' is out of date. It is
  recommended to install latest stable from www.xpra.org, or at least v1.0."
        [ "$Desktopmode" = "yes" ] && {
          note "Your xpra version does not support desktop mode.
  Fallback: Will try to use core Xorg (option --xorg)."
          Xserver="--xorg"
        } ||:
      } || {
        Xpraoptions="$Xpraoptions --webcam=no"
      }

      [ "$Desktopmode" = "yes" ] && verlt "$Xpraversion" "xpra v2.2-r17117" && note "Xpra desktop mode works best since xpra v2.2-r17117.
  You have installed lower version $Xpraversion.
  It is recommended to use Xephyr (option --xephyr) instead.
  Rendering issues can be reduced disabling OpenGL in Xpra tray icon. Screen
  size issues can be avoided with non-integer scaling (f.e. --scale=1.01)."
    ;;
  esac
  
  case $Xserver in
    --xpra|--xephyr|--hostdisplay|--xpra-xwayland|--nxagent) 
      [ -z "$Hostdisplay" ] && {
        [ "$Autochooseserver" = "no" ] && note "You only can use $Xserver within an already running X server.
  Fallback: Will try to use core Xorg (option --xorg)."  
        Xserver="--xorg"
      } ;;
  esac
  
  case $Xserver in
    --xpra-xwayland|--xdummy-xwayland)
      command -v "xdotool" >/dev/null || { [ -z "$Hostwayland" ] && note "Could not find xdotool to autohide weston window.
  A bothersome weston window will appear. 
  To avoid this, please install 'xdotool'" 
      } ;;
  esac
  
  [ -n "${PKEXEC_UID:-}" ] && [ -z "$Hostdisplay" ] && [ "$Tty" = "no" ] && [ "$Xserver" != "--xorg" ] && {
    note "It seems you have started x11docker with pkexec.
  Can not determine DISPLAY and XAUTHORITY, can not use your X server.
  To allow other X server options, please provide environment variables with
    pkexec env DISPLAY=\$DISPLAY XAUTHORITY=\$XAUTHORITY x11docker [ARGS]
  Fallback: Will try to use Xorg (option --xorg)."
    Xserver="--xorg"
  }
  
  [ "$Autochooseserver" = "yes" ] && note "Using X server option $Xserver"

  case $Xserver in 
    --xorg|--xdummy)
      command -v "Xorg" >/dev/null 2>&1 || error "Could not find executable 'Xorg'." ;;
  esac
  [ "$Xserver" = "--xorg" ] && {
    [ "$Hostsystem" = "opensuse" ] && [ "$Tty" = "no" ] && error "openSUSE does not support starting a second Xorg server
  from within X. Possible solutions: install nested X server 'Xephyr',
  or for --gpu support: install 'Weston' and 'Xwayland'.

  Or switch to console tty1...tty6 with <CTRL><ALT><F1>...<F6>
  and start x11docker there."
  
    [ "$Autochooseserver" = "yes" ] && [ -n "$Hostdisplay" ] && note "Could not find Xephyr or an alternative
  to run desktop in container. 
  Fallback: Will try to run a second core Xorg server (option --xorg)."
  
    note "You can switch between X servers and console terminals
  with [CTRL][ALT][F1]...[F12]."
  
    warning "On debian 9, switching often between multiple X servers can 
  cause a crash of one X server. This bug may be debian specific and is 
  probably some sort of race condition. If you know more about this or it 
  occurs on other systems, too, please report."
  
    # if x11docker is running from within an X server, check if user is allowed to run a new core X server
    [ -z "$Newxvt" ] && {
      if [ ! -e "/etc/X11/Xwrapper.config" ] || [ -z "$(cat /etc/X11/Xwrapper.config | grep "allowed_users" | grep "anybody")" ] ; then
        error "Your configuration does not allow you to start
  a second core Xorg server from within X.
  (As a default configuration, only root or console users can do that).
  
  Recommended easy solution: install nested X server 'Xephyr'.
  Solution with --gpu support: install 'Weston' and 'Xwayland'.
  
  Or you can switch to console tty1...tty6 with <CTRL><ALT><F1>...<F6>
  and start x11docker there.
  
  Setup to start a second Xorg X server from within already running X:
  Edit file '/etc/X11/Xwrapper.config' and replace line:
      allowed_users=console
  with lines
      allowed_users=anybody
      needs_root_rights=yes
  If the file does not exist already, you can create it.
  On Ubuntu 16.04 and debian 9 you need package xserver-xorg-legacy."
      fi
    }
  }
  [ "$Xserver" = "--xorg" ] && [ "$Autochooseserver" = "yes" ] && [ -z "$Imagename" ] && error "Will not run an empty Xorg in auto-choosing mode.
  If you want this, please use option --xorg explicitly."
}

{ #### part: check multiple option interferences

  [ "$Desktopmode" = "no" ] && [ -z "$Windowmanager" ] && case $Xserver in
    --xephyr|--weston-xwayland|--kwin-xwayland|--xorg|--xwayland) 
      Windowmanager="auto" 
      [ "$Autochooseserver" = "yes" ] && [ "$Tty" = "no" ] && {
        case $Gpu in
          no)  note "Did not find a nice solution to run a seamless application
  on your desktop. (Only insecure option --hostdisplay would work).
  It is recommended to install xpra (www.xpra.org) or nxagent." ;;
          yes) note "Did not find a nice solution to run a seamless application with
  option --gpu on your desktop. (Only insecure option --hostdisplay would work).
  It is recommended to install xpra, weston, Xwayland and xdotool." ;;
        esac
      }
    ;;
  esac
  
  [ "$Tty" = "yes" ] && Fullscreen="no" # avoid weston error on tty. --fullscreen is nonsense here at all.
  
  [ "$Xserver" = "--hostdisplay" ] && [ "$Autochooseserver" = "yes" ] && note "To allow protection against X security leaks,
  please install xpra, nxagent and/or Xephyr (recommended),
  or run a second Xorg server with options --xorg --wm=auto."
    
  [ "$Gpu" = "yes" ] && {
    case $Xserver in
      --xpra|--xdummy|--nxagent|--xephyr)
        note "Option $Xserver does not support hardware acceleration.
  Fallback: using software rendering, disabling option --gpu" 
        Gpu="no" 
      ;;
    esac
  }
  [ "$Gpu" = "yes" ] && {
    warning "Option --gpu degrades container isolation.
  Container gains access to GPU hardware.
  This allows reading host window content (palinopsia leak)
  and GPU rootkits (compare proof of concept: jellyfish)."
    note "Hardware acceleration (option --gpu) works quite well with open
  source drivers (radeon, nouveau, intel ...) on host and OpenGL/MESA in image.
  If you have closed source drivers on your host, you need to install
  the very same driver version in your image to get hardware acceleration."
    ls /dev/nvidia* >/dev/null 2>&1 && warning "It seems you are using proprietary NVIDIA drivers on host. 
  GPU acceleration will only work if you have the very same driver version 
  installed in image. That makes images less portable.
  It is recommended to use the free nouveau driver on host instead.
  Insist that NVIDIA corporation at least publishes their closed source API,
  or even better supports open source drivers at all."
    Forcetrusted="yes"
  }
  
  [ "$Xserver" = "--hostdisplay" ] && Trusted="no"
  [ "$Forcetrusted" = "yes" ]      && Trusted="yes"
  
 [ "$Xserver" = "--hostdisplay" ] &&  [ "$Sharehostipc" = "no" ] && [ "$Gpu" = "yes" ] && {
    note "To allow GPU acceleration (option --gpu) with --hostdisplay,
  x11docker will share host resources with insecure option --hostipc 
  and allow trusted cookies with option --trusted."
    Sharehostipc="yes"
  }
  
  [ "$Xserver" = "--hostdisplay" ] && [ "$Trusted" = "no" ] && {
    command -v xdpyinfo >/dev/null && {
      xdpyinfo | grep -q SECURITY || {
        note "Your X server does not support untrusted cookies.
  Have to use trusted cookies and to enable insecure option --hostipc.
  Consider to use options --xpra or --nxagent instead of --hostdisplay."
        Trusted="yes"
        Sharehostipc="yes"
      } 
    } || note "'xdpyinfo' not found. Need it to check
  whether Xorg supports untrusted cookies for --hostdisplay.
  Please install 'xdpyinfo'."
  }
  
  [ "$Shareclipboard" = "yes" ] && { 
    case $Xserver in
      --weston|--kwin) note "Sharing clipboard with $Xserver is not supported" ;;
      --hostwayland) note "Sharing clipboard may or may not work.
  Cannot enable or disable it, it depends on your Wayland compositor." ;;
      --hostdisplay) 
        warning "To allow clipboard sharing with option --hostdisplay,
  trusted cookies and insecure option --hostipc will be enabled.
  No protection against X security leaks is left!
  Please consider to use another X server option."
        Trusted="yes"
        Sharehostipc="yes"
      ;;
    esac
  }
  
  [ "$Xserver" = "--hostdisplay" ] && [ "$Ssh" = "yes" ] && {
    [ "$Sharehostipc" = "no" ] || [ "$Trusted" = "no" ] || [ "$Sharehostnet" = "no" ]  && {
      warning "For SSH connection with option --hostdisplay
  x11docker must enable options --hostipc, --hostnet and --trusted.
  It is recommended to user other X server options 
  like --xpra, --nxagent or --xephyr."
      Sharehostipc="yes"
      Sharehostnet="yes"
      Trusted="yes"
    }
  }
  
  [ "$Trusted" = "no" ] && warning "$Xserver runs with untrusted cookies restricting
  access to X resources. Some applications may misbehave, especially those 
  needing OpenGL. Also, some keys like AltGr may not work. 
  Some applications crash if using the X clipboard.
  You can degrade isolation and allow trusted cookies with option --trusted.
  You may also need insecure option --hostipc to avoid RAM access errors.
  (Options --gpu and --clipboard enable trusted cookies, too).
  It is recommended to use another X server option like --xpra or --nxagent."
  
  [ "$Xserver" = "--hostdisplay" ] && {
    [ "$Trusted" = "no" ] && {
      warning "Option --hostdisplay provides only low container isolation!
  It is recommended to use another X server option like --xpra or --nxagent."
    } || {
      warning "Option --hostdisplay with trusted cookies provides 
      QUITE BAD CONTAINER ISOLATION !
  Keylogging and controlling host applications is possible!"
      [ "$Sharehostipc" = "no" ] && warning "Using --hostdisplay with --trusted but without 
  insecure option --hostipc can lead to graphical issues and RAM access errors."
    }
    [ "$Desktopmode" = "yes" ] && note "Can not avoid to use host window manager
  along with option --hostdisplay. 
  You may get strange interferences with your host desktop.
  Can be interesting though, having two overlapping desktops."
  }

  [ "$Sharehostnet" = "yes" ] && [ "$Internetaccess" = "no" ] && {
    note "You have chosen --hostnet and --no-internet. That does not work.
  You can not share host network stack (--hostnet) and forbid internet access
  at the same time (except you disconnect your host from internet).
  Fallback: disabling option --hostnet, keeping --no-internet."
    Sharehostnet="no"
  }
  
  [ "$Sharehostipc" = "yes" ] && warning "Security risk:
  Option --hostipc causes severe reduction of container isolation!
  Drawback: IPC namespace remapping is disabled.
  Advantage: X extension MIT-SHM is possible."
  [ "$Sharehostnet" = "yes" ] && warning "Security risk: 
  Option --hostnet causes severe reduction of container isolation!
  Network namespacing is disabled.
  Drawback: Container shares host network stack.
  Advantage: dbus communication between host and container is possible."
  
  [ "$Fullscreen" = "yes" ] && {
    case $Xserver in
      --xephyr|--weston|--weston-xwayland|--nxagent|--xpra|--xpra-xwayland) ;;
      --xdummy|--xdummy-xwayland|--xvfb|--xorg) ;;
      *) note "$Xserver does not support option --fullscreen" ;;
    esac
  }
  
  [ "$Scaling" != "0" ] && {
    case $Xserver in
      --weston|--weston-xwayland)
        [[ $Scaling =~ ^[1-9]$ ]] || {
          note "The scale factor for option $Xserver must be 
  one of   1  2  3  4  5  6  7  8  9
  Fallback: disabling option --scale"
          Scaling="0"
        }
      ;;
      --xpra|--xpra-xwayland|--xorg)
        isnum $Scaling || {
          note "Option --scale needs a number. '$Scaling' is not allowed.
  Fallback: disabling option --scale"
          Scaling="0"
        }
      ;;
      *) 
        note "Option $Xserver does not support option --scale
  Fallback: disabling option --scale"
        Scaling="0" 
      ;;
    esac
    case $Xserver in
      --xpra|--xpra-xwayland)
        verlt "$Xpraversion" "xpra v0.16" && {
          note "Your xpra version is too old and does not support --scale.
  You need at least xpra version 0.16
  Fallback: disabling option --scale"
          Scaling="0"
        }        
      ;;
    esac
    case $Xserver in
      --weston-xwayland) note "Weston does not work well with Xwayland in scaled mode.
  In summary, Xwayland does not get the right screen resolution from Weston.
  (Bug report at https://bugzilla.redhat.com/show_bug.cgi?id=1498669 ).
  Try out if it works for you. Otherwise, you can combine 
  '--xpra-xwayland --desktop --scale $Scaling' for better desktop scaling support.
  --scale for single applications works best with --xpra / --xpra-xwayland.
  --scale in desktop mode works best with option --xorg." 
      ;;
      --xpra-xwayland)
        [ "1" = "$(awk -v a="$Scaling" 'BEGIN {print (a < 1)}')" ] && {
          command -v weston >/dev/null || { 
            note "Option --xpra-xwayland needs weston 
  for scale factor smaller than 1.
  Fallback: disabling option --scale"
            Scaling="0"
          }
        }
      ;;
      --xorg) 
        [ "1" = "$(awk -v a="$Scaling" 'BEGIN {print (a < 1)}')" ] && [ -n "$Rotation" ] && note "--xorg does not work well with combination
  of --scale smaller than 1 and rotation diferent from 0."
      ;;
    esac
  }
  
  [ -n "$Rotation" ] && {
    case $Xserver in
      --weston|--weston-xwayland|--xorg)
        echo "0 90 180 270 flipped flipped-90 flipped-180 flipped-270" | grep -q "$Rotation" || {  # fuzzy test, have been lazy
          note "Unsupported value '$Rotation' for option --rotate. 
  Must be one of 0 90 180 270 flipped flipped-90 flipped-180 flipped-270
  Fallback: disabling option --rotate"
          Rotation=""
        }
      ;;
      *) 
        note "Option $Xserver does not support option --rotate.
  Fallback: disabling option --rotate"
        Rotation=""
      ;;
    esac
  }
  [ "$Rotation" = "0" ] && Rotation="normal"
  
  command -v xrandr >/dev/null || case $Xserver in
    --xorg) { [ "$Scaling" != "0" ] || [ -n "$Rotation" ] || [ -n "$Screensize" ] ; } && note "Option --xorg needs 'xrandr' to support
  options --size, --scale and --rotate.
  Please install 'xrandr'."
    ;;
  esac
    
  case $Xserver in
    --weston|--kwin|--hostwayland)
     note "You are running a pure Wayland environment.
  X applications without Wayland support will fail."
    [ "$Dbuslaunch" = "no" ] || [ "$Setwaylandenv" = "no" ] && note "QT5 / KDE applications need 
  options --dbus --wayland to run in Wayland.
  GTK3 applications often fail with option --dbus."
    [ "$Xserver" = "--kwin" ] && note "kwin_wayland (option --kwin) does not support the xdg_shell
  interface in all versions. Some GTK3 Wayland applications depend on it.
  If application startup fails, try --weston instead."
    ;;
  esac

  [ -n "$Dpi" ] && case $Xserver in
    --weston|--kwin|--hostwayland|--hostdisplay) note "Option --dpi has no effect with option $Xserver" ;;
  esac
  
  [ "$Outputcount" != "1" ] && {
    case $Xserver in
      --xephyr|--weston|--kwin|--weston-xwayland|--kwin-xwayland) 
        [[ "$Outputcount" =~ ^[1-9]$ ]] || {
          note "--output-count value must be one of 1 2 3 4 5 6 7 8 9
  Disabling invalid value $Outputcount"
          Outputcount="1"
        }
        [ "$Tty" = "yes" ] && {
          note "Option --outputcount only works in nested/windowed mode,
  but not on tty. Fallback: disabling --outputcount"
          Outputcount="1"
        }
      ;;
      *) note "$Xserver does not support option --output-count.
  Only available for Weston, KWin and Xephyr, thus for options
  --weston, --weston-xwayland, --kwin, --kwin-xwayland, --xephyr." 
        Outputcount="1"
      ;;
    esac
    case $Xserver in
      --weston-xwayland) note "Xwayland sometimes does not position itself well
  at origin 0+0 of first virtual screen, and some screens appear to be unused. 
  You may need to move Xwayland manually with [META]+[LeftMouseButton].
  (Bug report at https://bugzilla.redhat.com/show_bug.cgi?id=1498665 )" ;;
      --xephyr) note "Xinerama support would be best for multiple outputs,
  but is disabled in Xephyr because Xephyr does not handle it well.
  Different window managers handle this different. Just try out." ;;
    esac
  }
  
  [ "$Xfishtank" = "yes" ] && {
    command -v xfishtank >/dev/null || {
      note "xfishtank not found. Can not show a fish tank.
  Please install 'xfishtank' for option --xfishtank to show a fish tank."
      Xfishtank="no"
    }
    case $Xserver in
      --xpra|--xpra-xwayland|--nxagent) 
        [ "$Desktopmode" = "no" ] && [ -z "$Windowmanager" ] && Windowmanager="auto" && Desktopmode="yes" ;;
      --weston|--kwin|--hostwayland|--hostdisplay)
        note "Option --xfishtank is not supported for $Xserver." 
        Xfishtank="no"
      ;;
    esac
  }
  
  [ -n "$Xkblayout" ] && case $Xserver in
    --kwin|--kwin-xwayland)
      [ "$Tty" = "yes" ] && note "Option --keymap does not work with option $Xserver
  if running from console."
    ;;
  esac
}

{ #### part: check free display, create cache folder and cache files

  $Mksu "mkdir -p $Cacherootfolder"         || error "Could not create cache folder
  $Cacherootfolder"
  writeaccess $Hostuseruid $Cacherootfolder || error "User $Hostuser does not have write access to
  cache folder $Cacherootfolder"  # can happen with --cachedir

  [ -z "$Newdisplaynumber" ] && {
    # Look for next free display and change some display specific variables
    case $Xserver in               # set initial value for searching free display number
      --xorg)                            Newdisplaynumber="8"   ;;
      --hostdisplay)                     Newdisplaynumber="50"  ;; # dummy number to look for free cache folder, DISPLAY will be $Hostdisplay
      --xpra|--xpra-xwayland)            Newdisplaynumber="100" ;;
      --xephyr)                          Newdisplaynumber="200" ;;
      --weston-xwayland)                 Newdisplaynumber="250" ;;
      --xdummy|--xvfb|--xdummy-xwayland) Newdisplaynumber="300" ;;
      --nxagent)                         Newdisplaynumber="400" ;;
      --xwayland)                        Newdisplaynumber="500" ;;
      --hostwayland)                     Newdisplaynumber="550" ;; # dummy number to look for free cache folder, DISPLAY will be empty
      --weston)                          Newdisplaynumber="600" ;;
      --kwin)                            Newdisplaynumber="700" ;;
      --kwin-xwayland)                   Newdisplaynumber="750" ;;
      --nothing)                         Newdisplaynumber="900" ;; # dummy number to look for free cache folder
    esac
    # search free X socket number, passing already used cache folders
    while [ -n "$(find /tmp/.X11-unix/X$Newdisplaynumber /tmp/.X$Newdisplaynumber-lock /tmp/.X11-unix/X$Newdisplaynumber $XDG_RUNTIME_DIR/wayland-$Newdisplaynumber $Cacherootfolder/X$Newdisplaynumber-* 2>/dev/null)" ] ; do
      Newdisplaynumber=$(($Newdisplaynumber + 1))
    done
  }
  
  Newdisplay=":$Newdisplaynumber"
  Newxsocket="/tmp/.X11-unix/X$Newdisplaynumber"
  Newxlock="/tmp/.X$Newdisplaynumber-lock"
  [ -z "$Newxvt" ] && Newxvt="vt$Newdisplaynumber"     # FIXME: assuming instead of knowing whether VT is free
  [ "$Xserver" != "--hostdisplay" ] && [ -n "$(find $Newxsocket $Newxlock 2>/dev/null)" ] && error "Display $Newdisplay is already in use."
  
  Cachefolder="$Cacherootfolder/X$Newdisplaynumber-$(echo $Imagename | tr / - | cut -d: -f1)"
  [ -d "$Cachefolder" ] && error "Cache folder already exists:
  $Cachefolder"
  
  [ "$Cachefolder" != "$(escapestring "$Cachefolder")" ] && error "Invalid name created for cache folder:
    $Cachefolder
  Most probably provided image name (or --exe command) is invalid in some way:
    $(escapestring "$Imagename")
  For special setups like command chains use a syntax like:
    x11docker IMAGENAME  --  sh -c \"cd /etc && xterm\""
  
  Sharefolder="$Cachefolder/$Sharefolder"
  $Mksu "mkdir -p $Sharefolder"
  export Cachefolder Sharefolder
  
  case $Xserver in
    --hostdisplay)
      Newdisplay=$Hostdisplay
      Newdisplaynumber=$(echo $Newdisplay | cut -d: -f2 | cut -d. -f1)
      [ -e "$Hostxsocket" ] && Newxsocket=$Hostxsocket || Newxsocket=
      Newxlock="/tmp/.X$Newdisplaynumber-lock"
      [ -e "$Newxlock" ] || Newxlock=""
    ;;
  esac
  
  Timetosaygoodbye="$Sharefolder/$Timetosaygoodbye"
  Xinitrc="$Cachefolder/$Xinitrc"                           && mkfile $Xinitrc
  Xinitlogfile="$Cachefolder/$Xinitlogfile"                 && mkfile $Xinitlogfile
  Xtermrc="$Cachefolder/$Xtermrc"                           && mkfile $Xtermrc
  Pullrc="$Cachefolder/$Pullrc"                             && mkfile $Pullrc
  Dockerlogfile="$Cachefolder/$Dockerlogfile"               && mkfile $Dockerlogfile
  Containerpidfile="$Cachefolder/$Containerpidfile"         && mkfile $Containerpidfile
  Containeridfile="$Cachefolder/$Containeridfile"           && mkfile $Containeridfile
  Dockerrc="$Cachefolder/$Dockerrc"                         && mkfile $Dockerrc
  Setupscript="$Sharefolder/$Setupscript"                   && mkfile $Setupscript
  Containerip="$Cachefolder/$Containerip"                   && mkfile $Containerip
  Xservercookie="$Cachefolder/$Xservercookie"               && mkfile $Xservercookie
  Xclientcookie="$Sharefolder/$Xclientcookie"               && mkfile $Xclientcookie
  Hostxauthority="$Cachefolder/$Hostxauthority"             && mkfile $Hostxauthority
  Xpraserverlogfile="$Cachefolder/$Xpraserverlogfile"       && mkfile $Xpraserverlogfile
  Xpraclientlogfile="$Cachefolder/$Xpraclientlogfile"       && mkfile $Xpraclientlogfile
  Compositorlogfile="$Cachefolder/$Compositorlogfile"       && mkfile $Compositorlogfile
  Compositorpidfile="$Cachefolder/$Compositorpidfile"
  Pulseaudioconf="$Cachefolder/$Pulseaudioconf"             && mkfile $Pulseaudioconf
  Bgpidfile="$Cachefolder/$Bgpidfile"                       && mkfile $Bgpidfile
  Imagecommandscript="$Sharefolder/$Imagecommandscript"     && mkfile $Imagecommandscript
  Shareclipboardscript="$Cachefolder/$Shareclipboardscript" && mkfile $Shareclipboardscript
  Westonini="$Cachefolder/$Westonini"                       && mkfile $Westonini
  Xdummyconf="$Cachefolder/$Xdummyconf"                     && mkfile $Xdummyconf
  Xdummywrapper="$Cachefolder/$Xdummywrapper"               && mkfile $Xdummywrapper
  Xkbkeymapfile="$Cachefolder/$Xkbkeymapfile"               && mkfile $Xkbkeymapfile
  
  Logfile2="$Sharefolder/x11docker.log"                     && mkfile $Logfile2
  Logfile3="$Cacherootfolder/x11docker.log"
  
  Cmdstdinfile="$Sharefolder/$Cmdstdinfile"                 && mkfile $Cmdstdinfile
  Cmdstdoutlogfile="$Sharefolder/$Cmdstdoutlogfile"         && mkfile $Cmdstdoutlogfile 666
  Cmdstderrlogfile="$Sharefolder/$Cmdstderrlogfile"         && mkfile $Cmdstderrlogfile 666 
  
  # catch stdin (submitted in x11docker.CMD.sh)
  [ -t 0 ] || cat >> $Cmdstdinfile
}

{ #### part: create $Hostxenv: Environment variables for host X display
  [ -n "$Hostdisplay" ] && {
    xauth nlist $Hostdisplay 2>/dev/null | $Mksu "xauth -f $Hostxauthority nmerge - 2>/dev/null"
    chown $Hostuser $Hostxauthority
    chmod 600 $Hostxauthority
  } || {
    Hostdisplay=""
    Hostxauthority=""
    Hostxsocket=""
  }
  Hostxenv="DISPLAY=$Hostdisplay"  
  [ -s "$Hostxauthority" ] && {
    Hostxenv="$Hostxenv XAUTHORITY=$Hostxauthority"  
    export XAUTHORITY=$Hostxauthority
    verbose "Cookie of $Hostdisplay: $(xauth list $Hostdisplay)"
  } || {
    Hostxauthority=
    unset XAUTHORITY
  }
  [ -n "$Hostxsocket" ] && Hostxenv="$Hostxenv XSOCKET=$Hostxsocket"  
  [ -n "$Hostwayland" ] && Hostxenv="$Hostxenv WAYLAND_DISPLAY=$Hostwayland"
  Hostxenv="$Hostxenv XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR"
  [ -n "$Hostdisplay" ] && [ -z "$Hostxauthority" ] && warning "Your host X server seems to run without any cookies."
}

{ #### part: check physical and virtual screen size

  # check whole display size, can include multiple monitors
  [ -n "$Hostdisplay" ] && {
    command -v xrandr >/dev/null && {
      Maxxaxis=$(xrandr 2>/dev/null | grep current | head -n1 | cut -d, -f2 | cut -d' ' -f3)
      Maxyaxis=$(xrandr 2>/dev/null | grep current | head -n1 | cut -d, -f2 | cut -d' ' -f5)
    } 
    [ -z "$Maxxaxis" ] && command -v xdpyinfo >/dev/null && {
      Maxxaxis=$(xdpyinfo | grep dimensions | cut -dx -f1 | rev | cut -d ' ' -f1 | rev)
      Maxyaxis=$(xdpyinfo | grep dimensions | cut -dx -f2 | cut -d ' ' -f1)
    }
    [ -z "$Maxxaxis" ] && command -v xwininfo >/dev/null && {
      Maxxaxis=$(xwininfo -root -stats | grep Width  | rev | cut -d' ' -f1 | rev)
      Maxyaxis=$(xwininfo -root -stats | grep Height | rev | cut -d' ' -f1 | rev)
    } 
    [ -z "$Maxxaxis" ] && note "Could not determine your screen size. 
  Please improve this by installing one of xrandr, xdpyinfo or xwininfo. 
  Or use option --size=XxY."
  }
  
  [ -n "$Maxxaxis" ] && {
    Xaxis=$Maxxaxis
    Yaxis=$Maxyaxis
  }
  
  [ "$Fullscreen" = "yes" ] && [ "$Tty" = "no" ] && [ -n "$Maxxaxis" ] && Screensize="${Maxxaxis}x${Maxyaxis}"
  
  # size for windowed desktops, roughly maximized relative to primary monitor
  case $Xserver in
    --xpra|--xpra-xwayland) [ "$Desktopmode" = "yes" ] && Xserver="${Xserver}-desktop" ;;
  esac
  case $Xserver in
    --xephyr|--weston-xwayland|--weston|--kwin|--kwin-xwayland|--nxagent|--xpra-desktop|--xpra-xwayland-desktop)
      [ "$Tty" = "yes" ] && {
        : # nothing to do on tty; maybe should check --size=$Screensize
      } || {
        command -v xrandr > /dev/null 2>/dev/null && xrandr 2>/dev/null | grep -q ' connected' && { # reduce size to primary monitor for windowed desktop
          Xaxis=$(xrandr 2>/dev/null | grep ' connected' | head -n1 | cut -dx -f1 | rev | cut -d' ' -f1 | rev)
          Yaxis=$(xrandr 2>/dev/null | grep ' connected' | head -n1 | cut -dx -f2 | cut -d' ' -f1 | cut -d+ -f1)
          Xaxis=$((Xaxis-100))
          Yaxis=$((Yaxis-100))
        } || { 
          note "Could not determine size of your primary display to
  create a roughly maximized window for $Xserver. 
  Please install xrandr or use option --size=XxY.
  Fallback: setting virtual screen size 800x600"
          Xaxis="800"
          Yaxis="600"
        }
      }
    ;;
  esac
  Xserver=${Xserver%-desktop}
  
  [ -z "$Xaxis" ] && {       ### FIXME: arbitrary resolution. At least, --xorg checks again with xrandr in xinitrc
    Xaxis="4720"
    Yaxis="3840"
  }
  
  # regard scaling (option --scale)
  [ "$Scaling" = "0" ] || {
    Xaxis=$(awk -v a=$Xaxis -v b=$Scaling 'BEGIN {print (a / b)}')
    Xaxis=${Xaxis%.*}
    Yaxis=$(awk -v a=$Yaxis -v b=$Scaling 'BEGIN {print (a / b)}')
    Yaxis=${Yaxis%.*}
  }
  [ -n "$Screensize" ] && {  # regard --size, overwriting Xaxis/Yaxis from above
    Xaxis=${Screensize%x*}
    Yaxis=${Screensize#*x}
  }
  case $Xserver in
    # avoid grey edge, Xwayland needs full byte x width
    --weston-xwayland|--kwin-xwayland) Xaxis=$(( $(( $Xaxis / 8 )) * 8 )) ;;
  esac
  case $Xserver in
    --xorg) ;;  # Xorg autodetects screen size, preset only with option --size
    *) [ "$Tty" = "no" ] && Screensize="${Xaxis}x${Yaxis}" ;;
  esac
  [ -z "$Maxxaxis" ] && {
    Maxxaxis=$Xaxis
    Maxyaxis=$Yaxis
  }
  Modeline="$(cvt $Xaxis $Yaxis | tail -n1 | cut -d' ' -f2-)"
}

{ #### part: check window manager (option --wm)
  case $Windowmanager in
    ""|"none") Windowmanager="" ;;
    *)
      [ "$Windowmanager" = "auto" ] && Windowmanager=""
      [ -n "$Windowmanager" ] && {
        command -v $Windowmanager > /dev/null || {
          warning "Host window manager '$Windowmanager' not found.
  Fallback: Will try to autodetect a host window manager."
          Windowmanager=""
        }
      }
      # try to find out recommended window manager to use it for x11docker (i.e. run a new instance of it)
      [ -z "$Windowmanager" ] && [ -e "/etc/alternatives/x-window-manager" ] && {
        note "Looking for windowmanager linked with x-window-manager.
  You can set the default one detected in auto mode with
    update-alternatives --config x-window-manager"
        Windowmanager=$(command -v $(ls -l /etc/alternatives/x-window-manager | cut -d ">" -f2))
      }
        
      # try to find one in list
      [ -z "$Windowmanager" ] && {
        for Windowmanager in $Wm_all "" ; do
          command -v $Windowmanager >/dev/null && break
        done
      }
        
      # try with wmctrl
      [ -z "$Windowmanager" ] && command -v wmctrl >/dev/null && {
        Windowmanager=$(wmctrl -m | grep 'PID' | awk '{print $2}')                 # wmtrl, if installed, can find already running wm. At first get pid
        [ -e "/proc/$Windowmanager" ] && {                                         # check if pid is valid
          Windowmanager=$(ls -l "/proc/$Windowmanager/exe" | awk '{print $11}')    # if yes, then get /path/executable
        } || {                                                                     # otherwise, try insecure way over name
          Windowmanager=$(wmctrl -m | grep 'Name' | awk '{print $2}' | tr '[:upper:]' '[:lower:]')
        }
      }
        
      # check some wm specific settings
      [ -n "$Windowmanager" ] && case $(basename $Windowmanager | awk '{print $1}') in
        cinnamon|cinnamon-session) Windowmanager="cinnamon --sm-disable";;
        compiz) # if none, create minimal config to have useable window decoration and can move windows
          [ -e "$Hostuserhome/.config/compiz-1/compizconfig/Default.ini" ] || {
            $Mksu "mkdir -p '$Hostuserhome/.config/compiz-1/compizconfig'"
            mkfile "$Hostuserhome/.config/compiz-1/compizconfig/Default.ini"
            echo '[core]
s0_active_plugins = core;composite;opengl;decor;resize;move;
' >> "$Hostuserhome/.config/compiz-1/compizconfig/Default.ini"
          }  ;;
        enlightenment|e17|e16|e19|e20|e) Windowmanager="enlightenment_start" ;;
        gnome|gnome-shell|gnome-session) # crashes without option '--sm-disable', crashes host X, too!
          Windowmanager="gnome-shell --sm-disable" ;;
        matchbox) Windowmanager="matchbox-window-manager"  ;;
        mate|mate-session) Windowmanager="mate-session -f" ;;
        mate-wm) Windowmanager="marco --sm-disable"  ;;
        openbox) Windowmanager="openbox --sm-disable" ;;
      esac
        
      [ -n "$Windowmanager" ] && case $(basename $Windowmanager | awk '{print $1}') in
        enlightenment_start|gnome-shell|lxsession|mate-session|cinnamon) 
          note "Using extensive window manager $(basename $Windowmanager | awk '{print $1}').
  It is recommended to install and use a lightweight window manager like
  $Wm_recommended_nodesktop_light"
        ;;
        *) note "Using host window manager $Windowmanager"
      ;;
    esac

    [ -n "$Windowmanager" ] && ! command -v $Windowmanager >/dev/null && warning "No executeable window manager '$Windowmanager' found."
    [ -z "$Windowmanager" ] && note "Could not detect a host window manager.
  Please specify one with option --wm=WINDOWMANAGER or install one of
  $Wm_good"
  ;;
  esac
}

{ #### part: check sound (options --pulseaudio and --alsa)
  # option '--pulseaudio'
  [ "$Pulseaudio" = "yes" ] && {
    warning "Option --pulseaudio allows container applications
  to catch your audio output and microphone input."
    Pulseaudiosocketdir="$XDG_RUNTIME_DIR/pulse"
    [ -d "$Pulseaudiosocketdir" ] || Pulseaudiosocketdir="$(pax11publish -d | grep Server | cut -d'}' -f2 | cut -d' ' -f1 | cut -d: -f2)"
    [ -d "$Pulseaudiosocketdir" ] || {
      warning "Did not find directory 'pulse' in XDG_RUNTIME_DIR.
  Is pulseaudio up and running on your host?
  Fallback: Will try to use ALSA (option --alsa) instead."
      Pulseaudio="no"
      Alsa="yes"
    }
    [ -s "$Pulseaudiosocketdir/native" ] && Pulseaudiosocketname="native"
    [ -z "$Pulseaudiosocketname" ] && Pulseaudiosocketname="$(find "$Pulseaudiosocketdir" -type s | rev | cut -d/ -f1 | rev | head -n1)"
    [ -z "$Pulseaudiosocketname" ] && {
      warning "Did not find pulseaudio socket
  in $Pulseaudiosocketdir
  Fallback: Will try to use ALSA (option --alsa) instead."
      Pulseaudio="no"
      Alsa="yes"
    }
    [ "$Pulseaudio" = "yes" ] && Pulseserver="PULSE_SERVER=unix:/pulse/$Pulseaudiosocketname"
    echo "# Connect to the host's server using the mounted UNIX socket
default-server = unix:/pulse/$Pulseaudiosocketname
# Prevent a server running in the container
autospawn = no
daemon-binary = /bin/true
# Prevent the use of shared memory
enable-shm = false
" >> $Pulseaudioconf
  }
  
  # option --alsa
  [ "$Alsa" = "yes" ] && {
    warning "ALSA sound with option --alsa degrades container isolation.
  Shares device files in /dev/snd, container gains access to sound hardware.
  Container applications can catch audio output and microphone input."
  
    note "You can specify the sound card to use setting environment
  variable ALSA_CARD. Example:  --env ALSA_CARD=Generic
  Following sound cards found on your system:
$(cat /proc/asound/cards | grep ':' | cut -d[ -f2 | cut -d] -f1)
  Option --alsa allows a general access to real sound cards. 
  To use virtual ALSA devices like dmix, too, install ALSA libraries in image.
  (Example: debian images would need package libasound2)."
  
    pgrep pulseaudio >/dev/null && note "It seems that pulseaudio is running on your host.
  Pulseaudio can interfere with ALSA sound (option --alsa).
  Host sound may not work while container is playing sound and vice versa.
  Alternative: with pulseaudio on host and in image, use option --pulseaudio."
  }  
}

{ #### part: create xorg.conf and Xorg wrapper for --xdummy (options --xdummy, --xpra)
  case $Xserver in
    --xpra|--xdummy)
      # create xorg.conf for Xdummy
      { echo '# This xorg configuration file is forked and changed from xpra to start a dummy X11 server.
# For original and details, please see: https://xpra.org/Xdummy.html
Section "ServerFlags"
  Option "DontVTSwitch" "true"
  Option "AllowMouseOpenFail" "true"
  Option "PciForceNone" "true"
  Option "AutoEnableDevices" "false"
  Option "AutoAddDevices" "false"
EndSection
Section "Device"
  Identifier "dummy_videocard"
  Driver "dummy"
  DacSpeed 600
  Option "ConstantDPI" "true"
  VideoRam '$(($Maxxaxis * $Maxyaxis * 2 * 32 / 8 / 1024))'
EndSection
Section "Monitor"
  Identifier "dummy_monitor"
  HorizSync   1.0 - 2000.0
  VertRefresh 1.0 - 200.0
  Modeline '$Modeline'
  '
  echo "# add some virtual display sizes to allow flexible xpra client window resizing from 25% up to fullscreen"
  for Ycount in 25 30 35 40 45 50 55 60 65 60 75 80 85 90 95 100; do
    for Xcount in 25 30 35 40 45 50 55 60 65 60 75 80 85 90 95 100; do
      cvt $(awk -v a=$Maxxaxis -v b=$Xcount 'BEGIN {print (a * b / 100)}') $(awk -v a=$Maxyaxis -v b=$Ycount 'BEGIN {print (a * b / 100)}') | tail -n1
    done
  done
  echo '
EndSection
Section "Screen"
  Identifier "dummy_screen"
  Device "dummy_videocard"
  Monitor "dummy_monitor"
  DefaultDepth 24
  SubSection "Display"
    Viewport 0 0
    Depth 32
    Modes '$(echo $Modeline | cut -d " " -f1)'
    Virtual '$Xaxis' '$Yaxis'
  EndSubSection
EndSection
Section "ServerLayout"
  Identifier   "dummy_layout"
  Screen       "dummy_screen"
EndSection
' 
  } >> $Xdummyconf
      # create starter script for Xdummy
      echo '#!/bin/sh
#@PydevCodeAnalysisIgnore
# fork of https://xpra.org/trac/browser/xpra/trunk/src/scripts/xpra_Xdummy
find_ld_linux() {
	arch=$(uname -m)

	if [ $arch = "x86_64" ]; then
		LD_LINUX="/lib64/ld-linux-x86-64.so.2"
	elif [ $arch = "i386" ]; then
		LD_LINUX="/lib/ld-linux.so.2"
	elif [ $arch = "i486" ]; then
		LD_LINUX="/lib/ld-linux.so.2"
	elif [ $arch = "i586" ]; then
		LD_LINUX="/lib/ld-linux.so.2"
	elif [ $arch = "i686" ]; then
		LD_LINUX="/lib/ld-linux.so.2"
	elif [ $arch = "armel" ]; then
		LD_LINUX="/lib/ld-linux.so.3"
	elif [ $arch = "armhfp" ]; then
		LD_LINUX="/lib/ld-linux.so.3"
	elif [ $arch = "armhf" ]; then
		LD_LINUX="/lib/ld-linux-armhf.so.3"
	elif [ $arch = "ppc64" ]; then
		LD_LINUX="/lib64/ld64.so.1"
	elif [ $arch = "s390x" ]; then
		LD_LINUX="/lib64/ld64.so.1"
	else
		#suitable for: powerpc/ppc, mips/mipsel, s390 and others:
		LD_LINUX="/lib/ld.so.1"
	fi

	if [ ! -x "$LD_LINUX" ]; then
		# Musl C / Alpine Linux
		ldmusl=$(ls /lib | grep ^ld-musl)
		if [ -n "$ldmusl" ]; then
			LD_LINUX="/lib/$ldmusl"
		else
			LD_LINUX=""
			echo "could not determine ld path for $arch, please file an xpra bug"
		fi
	fi
}

if [ -x "/usr/libexec/Xorg" ]; then
	#Fedora 22+ workaround where /usr/bin/Xorg is not suid
	#because it is a script, command -v calls /usr/libexec/Xorg.wrap
	#command -v is setuid, and command -v eventually calls this one:
	XORG_BIN="/usr/libexec/Xorg"
elif [ -x "/usr/libexec/Xorg.bin" ]; then
	#Fedora 21 workaround where /usr/bin/Xorg is not suid
	#because it is a script, command -v calls /usr/libexec/Xorg.wrap
	#command -v is setuid, and command -v eventually calls this one:
	XORG_BIN="/usr/libexec/Xorg.bin"
elif [ -x "/usr/lib/xorg-server/Xorg" ]; then
	#Arch Linux:
	exec "/usr/lib/xorg-server/Xorg" "$@"
elif [ -x "/usr/lib/xorg/Xorg" ]; then
	#Ubuntu 16.10:
	exec "/usr/lib/xorg/Xorg" "$@"
else
	XORG_BIN=$(command -v Xorg)
fi
if [ ! -x "$XORG_BIN" ]; then
	echo "failed to locate Xorg binary to run"
	exit 1
fi
if [ -u "$XORG_BIN" ]; then
	# setuid is set, we need to do magic
	find_ld_linux
	if [ -n "$LD_LINUX" ]; then
		if [ -n "$BASH" ]; then
			#running in bash, can show a more helpful command name:
			exec -a "Xorg-nosuid" "$LD_LINUX" "$XORG_BIN" "$@"
		else
			exec "$LD_LINUX" "$XORG_BIN" "$@"
		fi
	else
		#fallback to making a copy of the binary:
		DOTXPRA_DIR="$HOME/.xpra"
		if [ ! -d "$DOTXPRA_DIR" ]; then
	 		mkdir "$DOTXPRA_DIR"
	 		chmod 700 "$DOTXPRA_DIR"
	 	fi
		NOSUID_XORG="$DOTXPRA_DIR/Xorg-nosuid"
	 	cp -f "$XORG_BIN" "$NOSUID_XORG"
	 	exec "$NOSUID_XORG" "$@"
	 fi
else
	# setuid is not set on xorg_bin
	exec "$XORG_BIN" "$@"
fi
' >> $Xdummywrapper    ;;
  esac
}

{ #### part: create command to start X server and/or Wayland compositor
  Xserveroptions="-nolisten tcp -dpms"
  case $Xserver in
    --nxagent)
      { [ "$Sharehostipc" = "yes" ] || [ "$X11dockermode" = "exe" ] ; } && Xserveroptions="$Xserveroptions -shmem -shpix" || Xserveroptions="$Xserveroptions -noshmem -noshpix"
      Xserveroptions="$Xserveroptions \\
  +extension Composite"
    ;;
    *)
      Xserveroptions="$Xserveroptions -retro"
      Xserveroptions="$Xserveroptions \\
  +extension Composite +extension RANDR +extension RENDER +extension GLX\\
  +extension XVideo +extension DOUBLE-BUFFER"
      Xserveroptions="$Xserveroptions \\
  -extension X-Resource +extension SECURITY +extension DAMAGE"
      Xserveroptions="$Xserveroptions \\
  -extension XINERAMA -xinerama"
      { [ "$Sharehostipc" = "yes" ] || [ "$X11dockermode" = "exe" ] ; } && {
        Xserveroptions="$Xserveroptions +extension MIT-SHM"
      } || { 
        Xserveroptions="$Xserveroptions -extension MIT-SHM"
        Xprashm="XPRA_XSHM=0"
      }
    ;;
  esac
  [ "$Xauthentication" = "yes" ] && Xserveroptions="$Xserveroptions \\
  -auth $Xservercookie"
  
  # extension XTEST
  [ -z "$Xtest" ] && {
    case $Xserver in
      --xpra|--xpra-xwayland) Xtest="yes" ;;
      --xdummy|--xdummy-xwayland|--xvfb) 
        Xtest="yes" 
        note "Enabled X extension XTEST to allow custom access to new X server
  with Xpra. You can disable XTEST with option --no-xtest."
      ;;
      *) Xtest="no" ;;
    esac
  }
  case "$Xtest" in
    yes) Xserveroptions="$Xserveroptions \\
  +extension XTEST" 
      [ -n "$Windowmanager" ] && warning "Did not disable X extension XTEST
  for X server $Xserver.
  If your host window manager $Windowmanager can start applications
  on its own (for example, with a context menu), container applications
  can abuse this to run and remotely control host applications.
  If you provide content of X server $Xserver over network to others,
  they may take control over your computer!"
      ;;
    no)  Xserveroptions="$Xserveroptions \\
  -extension XTEST -tst"
      case $Xserver in
        --xpra|--xpra-xwayland) warning "You have disabled extension XTEST with --no-xtest.
  Xpra will not be able to provide keyboard and mouse." ;;
      esac
    ;;
  esac
  
  # check DPI
  case $Xserver in
    --xpra|--xpra-xwayland)
      { [ -n "$Dpi" ] || [ "$Scaling" != "0" ] ; } && verlt "$Xpraversion" "xpra v2.1-r16547" && ! verlt "$Xpraversion" "xpra v2.1" && {
        note "Option --dpi is buggy in $Xpraversion
  due to xpra bug #1605. Need at least xpra v2.1-r16547 or one of 2.0 series.
  This affects option --scale, too, leading to wrong font sizes.
  Fallback: disabling dpi settings."
        # disabling further down
      } ;;
  esac
  case $Xserver in
    --weston|--kwin|--nothing|--hostdisplay) ;;
    *)
      [ -z "$Dpi" ] && {
        xdpyinfo >/dev/null 2>&1 && {
        Dpi=$(xdpyinfo | grep dots | cut -dx -f2 | cut -d' ' -f1)
        } || {
          [ -n "$Hostdisplay" ] && [ -z "$(command -v xdpyinfo)" ] && note "Could not determine dpi settings. If you encounter too big or
  too small fonts with $Xserver, please install xdpyinfo or use option --dpi."
        }
        case $Xserver in
          --xpra|--xpra-xwayland)
            [ "$Scaling" != "0" ] && {
              [ "$Desktopmode" = "no" ] || ! verlt "$Xpraversion" "xpra v2.2" && {  # xpra desktop mode has same dpi baviour as non-desktop since v2.2. Before that, dpi in xpra desktop mode must not be adjusted
                Dpi=$(awk -v a="$Scaling" -v b="$Dpi" 'BEGIN {print (b * a * a)}')
                Dpi=${Dpi%.*}
              }
            }
          ;;
        esac
      }
    ;;
  esac

  case $Xserver in
    --xpra|--xpra-xwayland)
      # disable --dpi for buggy versions
      [ -n "$Dpi" ] && verlt "$Xpraversion" "xpra v2.1-r16547" && ! verlt "$Xpraversion" "xpra v2.1" &&  Dpi=""
      # disable proxy for high versions
      verlt "$Xpraversion" "xpra v2.1" || Xpraoptions="$Xpraoptions --start-via-proxy=no"
      # disable sound transfer, --pulseaudio works different
      Xpraoptions="$Xpraoptions -z0 --no-speaker --no-pulseaudio"
      # disable possibly leaking options
      Xpraoptions="$Xpraoptions --daemon=no --fake-xinerama=no --notifications=no --file-transfer=off --printing=no --html=off --systemd-run=no --mdns=no"
      [ "$Fullscreen" = "yes" ]  && Xpraoptions="$Xpraoptions --desktop-fullscreen=yes"
      [ "$Desktopmode" = "yes" ] && Xpraoptions="$Xpraoptions --title='$Imagename on $Newdisplay (shift+F11 toggles fullscreen)'"
      [ "$Xkblayout" ] && Xpraoptions="$Xpraoptions --keyboard-layout='$Xkblayout' --keyboard-raw=yes"
      # version check for scaling already done above
      [ "$Scaling" != "0" ] && Xpraoptions="$Xpraoptions --desktop-scaling=$Scaling"
      # debug options for xpra
      #Xpraoptions="$Xpraoptions -d randr,geometry,screen"
    ;;
  esac

  [ -n "$Dpi" ] && { :
    Xserveroptions="$Xserveroptions -dpi $Dpi"
    Xpraoptions="$Xpraoptions --dpi $Dpi"
  }
  
  Waitforgoodbye="mywatch 'ls $Timetosaygoodbye 2>/dev/null'" 

  # Prepare weston.ini: config file for Weston
  case $Xserver in
    --weston|--weston-xwayland|--xpra-xwayland|--xdummy-xwayland)
      echo "
[core]
shell=desktop-shell.so
idle-time=0
[shell]
panel-location=none
panel-position=none
locking=false
background-color=0xff002244
animation=fade
startup-animation=fade
[keyboard]
" >> "$Westonini"
      [ -n "$Xkblayout" ] && echo "keymap_layout=$Xkblayout" >> "$Westonini"
      [ -z "$Xkblayout" ] && [ "$Tty" = "yes" ] && echo "$(echo -n "keymap_layout=" && cat /etc/default/keyboard | grep XKBLAYOUT | cut -d= -f2 | cut -d'"' -f2)" >> "$Westonini"
      [ -n "$Hostwayland" ] &&  [ "$Xserver" != "--xpra-xwayland" ] && [ "$Hostsystem" != "ubuntu" ] && {
        Westonoutput="WL"
      } || {
        [ -n "$Hostdisplay" ] && Westonoutput="X"
      }
      [ "$Tty" = "yes" ] && { 
        [ -n "$Screensize" ] || [ "$Scaling" != "0" ] || [ -n "$Rotation" ] && {
          # short start&stop of Weston to grep name of monitor
          $Mksu "weston --no-config >> $Compositorlogfile 2>&1 & echo \$! >>$Compositorpidfile"
          Compositorpid=$(cat $Compositorpidfile)
          waitforlogentry weston $Compositorlogfile "connector" || error "Weston startup failed. Can not run $Xserver.
  Last lines of weston log:
$(tail "$Compositorlogfile")"
          Westonoutput="$(cat $Compositorlogfile | grep Output | grep connector | head -n1 | cut -d ' ' -f3 | rev | cut -c2- | rev)"
          kill $Compositorpid
          mkfile "$Compositorlogfile"
          mkfile "$Compositorpidfile"
        }
      }
    ;;
  esac

  case $Xserver in
    --xorg)
      Xserveroptions="$Xserveroptions \\
  +extension XFree86-DRI +extension XFree86-DGA +extension XFree86-VidModeExtension"
      Xserveroptions="$Xserveroptions \\
  -verbose"                  # make X verbose
      [ "$Tty" = "yes" ] && Xserveroptions="$Xserveroptions -keeptty"
      Xcommand="$(command -v Xorg) $Newdisplay $Newxvt \\
  $Xserveroptions"
      warning "Although x11docker starts Xorg as unprivileged user,
  most system setups wrap Xorg to give it root permissions (setuid).
  Evil containers may try to abuse this.
  Other x11docker X server options like --xephyr are more secure at this point."
    ;;
    
    --xpra) # To use xpra, Xdummy will run first. xpra server uses it later. Use Xvfb if available.
      command -v Xvfb >/dev/null && {
        Xcommand="$(command -v Xvfb) $Newdisplay -screen 0 ${Maxxaxis}x${Maxyaxis}x24 \\
  $Xserveroptions"
      } || {
        Xcommand="$Xdummywrapper $Newdisplay $Newxvt \\
  -config $Xdummyconf \\
  $Xserveroptions"
        note "Xvfb not found. Will try to use dummy video driver Xdummy.
  If you encounter xpra startup errors, please install 'Xvfb'."
      }
    ;;
    
    --xdummy)
      Xcommand="$Xdummywrapper $Newdisplay $Newxvt \\
  -config $Xdummyconf \\
  $Xserveroptions"
    ;;
    
    --xvfb)
      Xcommand="$(command -v Xvfb) $Newdisplay -screen 0 ${Screensize}x24 \\
  $Xserveroptions"   ### FIXME: hardcoded setting of depth 24. Could be better?
    ;;
    
    --xephyr)
      case $Fullscreen in
        yes) Xephyroptions="$Xephyroptions -fullscreen" ;;
        no)  for ((Count=1 ; Count<=$Outputcount ; Count++)) ; do Xephyroptions="$Xephyroptions -screen $Screensize" ; done ;;
      esac
      [ "$Xephyrglamor" = "yes" ] && Xephyroptions="$Xephyroptions -glamor"      # deprecated option '--glamor'
      Xcommand="$(command -v Xephyr) $Newdisplay $Xephyroptions \\
  -title '$Imagename on $Newdisplay (ctrl+shift grabs mouse and keyboard)' \\
  $Xserveroptions"
  
      # Fallback: Xnest
      command -v Xephyr >/dev/null || {
        Xcommand="$(command -v Xnest) $Newdisplay -geometry $Screensize -scrns $Outputcount \\
  -name '$Imagename on $Newdisplay' \\
  $Xserveroptions "
        note "Xephyr not found. Fallback: using Xnest.
  Xnest is less stable and has less features than Xephyr.
  For example, it misses RandR and Composite extensions and fullscreen mode.
  It is recommended to install 'Xephyr'."
      }
    ;;
    
    --xwayland) 
      Xcommand="$(command -v Xwayland) $Newdisplay \\
  $Xserveroptions"
      Waylandsocket="$Hostwayland"
    ;;
    
    --xpra-xwayland|--xdummy-xwayland)
      Xcommand="$(command -v Xwayland) $Newdisplay \\
  $Xserveroptions"
      [ -z "$Hostwayland" ] && Waylandsocket="wayland-$Newdisplaynumber" || {
        Waylandsocket="$Hostwayland"
        [ "$Scaling" != "0" ] && [ "1" = "$(awk -v a="$Scaling" 'BEGIN {print (a < 1)}')" ] && Waylandsocket="wayland-$Newdisplaynumber"
      }
      echo "[output]" >> $Westonini
      case $Westonoutput in
        X|WL) echo "name=${Westonoutput}1" >> $Westonini ;;
        *)    echo "name=${Westonoutput}"  >> $Westonini ;;
      esac
      echo "mode=$Screensize" >> $Westonini
      [ -n "$Customwestonini" ] && Westonini="$Customwestonini"
      Compositorcommand="weston --config='$Westonini' --socket=$Waylandsocket"
      case $Westonoutput in
        WL) Compositorcommand="$Compositorcommand --backend=wayland-backend.so" ;;
        X)  Compositorcommand="$Compositorcommand --backend=x11-backend.so" ;;
        *) 
          case "$Tty" in
            yes) Compositorcommand="$Compositorcommand --backend=drm-backend.so" ;;
            no)  Compositorcommand="$Compositorcommand --backend=x11-backend.so" ;;
          esac
        ;;
      esac
    ;;
    
    --weston|--weston-xwayland)
      [ "$Xserver" = "--weston-xwayland" ] && Xcommand="$(command -v Xwayland) $Newdisplay \\
  $Xserveroptions"
      [ "$Xserver" = "--weston" ]          && Sharewayland="yes"
      Waylandsocket="wayland-$Newdisplaynumber"
      [ -n "$Westonoutput" ] && for ((Count=1 ; Count<=$Outputcount ; Count++)) ; do
        [ "$Westonoutput" = "WL" ] || [ "$Westonoutput" = "X" ] || { 
          Count=""
          [ -z "$Screensize" ] && Screensize="preferred"
        }
        echo "[output]
name=$Westonoutput$Count
mode=$Screensize
" >> $Westonini
        [ "$Scaling" != "0" ] && echo "scale=$Scaling"      >> $Westonini
        [ -n "$Rotation" ]    && echo "transform=$Rotation" >> $Westonini
      done
      [ -n "$Customwestonini" ] && Westonini="$Customwestonini"
      Compositorcommand="weston --socket=$Waylandsocket --config='$Westonini'"
      [ "$Fullscreen" = "yes" ] && Compositorcommand="$Compositorcommand --fullscreen"
      [ "$Outputcount" = "1" ]  || Compositorcommand="$Compositorcommand --output-count=$Outputcount"
      case $Westonoutput in
        WL) Compositorcommand="$Compositorcommand --backend=wayland-backend.so" ;;
        X)  Compositorcommand="$Compositorcommand --backend=x11-backend.so" ;;
        *) 
          case "$Tty" in
            yes) Compositorcommand="$Compositorcommand --backend=drm-backend.so" ;;
            no)  Compositorcommand="$Compositorcommand --backend=x11-backend.so" ;;
          esac
        ;;
      esac
    ;;
    
    --kwin-xwayland)
      Xcommand="$(command -v Xwayland) $Newdisplay \\
  $Xserveroptions"
      Waylandsocket="wayland-$Newdisplaynumber"
      Compositorcommand="kwin_wayland --xwayland --socket=$Waylandsocket --width=$Xaxis --height=$Yaxis --output-count=$Outputcount" 
      [ "$Xkblayout" ] && Compositorcommand="KWIN_XKB_DEFAULT_KEYMAP=$Xkblayout $Compositorcommand" 
      Compositorcommand="env QT_XKB_CONFIG_ROOT=/usr/share/X11/xkb $Compositorcommand" 
      case $Tty in
        yes) Compositorcommand="$Compositorcommand --drm" ;;
        no)  Compositorcommand="$Compositorcommand --windowed" ;;
      esac
    ;;
    
    --kwin)
      Waylandsocket="wayland-$Newdisplaynumber"
      Sharewayland="yes"
      Compositorcommand="kwin_wayland --xwayland --socket=$Waylandsocket --width=$Xaxis --height=$Yaxis --output-count='$Outputcount'" 
      #[ "$Xkblayout" ] && Compositorcommand="KWIN_XKB_DEFAULT_KEYMAP=$Xkblayout $Compositorcommand" 
      Compositorcommand="env QT_XKB_CONFIG_ROOT=/usr/share/X11/xkb $Compositorcommand"
      case $Tty in
        yes) Compositorcommand="$Compositorcommand --drm" ;;
        no)  Compositorcommand="$Compositorcommand --windowed" ;;
      esac    
    ;;
    
    --nxagent)
      Nxagentoptions="$Nxagentoptions \\
  -options $Cachefolder/nxagentoptions \\
  -norootlessexit -verbose -ac"
      case $Desktopmode in
        "yes") Nxagentoptions="$Nxagentoptions \\
  -D -name '$Imagename on $Newdisplay (shift+F11 toggles fullscreen)'" ;; # desktop mode,  similar to xephyr
        "no")  Nxagentoptions="$Nxagentoptions -R" ;; # rootless mode, similar to xpra
      esac
      export NXAGENT_KEYSTROKEFILE="$Cachefolder/nx_keys"
      Xcommand="$(command -v nxagent) $Newdisplay $Xserveroptions $Nxagentoptions \\
  -keystrokefile $NXAGENT_KEYSTROKEFILE"
      # create file for additional nxagent options
      Nxagentoptions="nx/nx"
      [ "$Shareclipboard" = "yes" ] && Nxagentoptions="$Nxagentoptions,clipboard=both" || Nxagentoptions="$Nxagentoptions,clipboard=none"
      [ "$Fullscreen" = "yes" ] && Nxagentoptions="$Nxagentoptions,fullscreen=1" || {
        [ -n "$Screensize" ] && Nxagentoptions="$Nxagentoptions,geometry=$Screensize" 
      }
      # set keyboard layout
      command -v setxkbmap >/dev/null && { 
        Nxagentoptions=$Nxagentoptions,keyboard=$(setxkbmap -query | grep rules | rev | cut -d" " -f1 | rev)/$(setxkbmap -query | grep layout | rev | cut -d" " -f1 | rev)
      } || note "Could not check your keyboard layout due to missing setxkbmap
  If you get mismatching keys, please install setxkbmap."
      Nxagentoptions="$Nxagentoptions$Newdisplay"
      mkfile "$Cachefolder/nxagentoptions"
      echo $Nxagentoptions >> "$Cachefolder/nxagentoptions"
      # workaround as nxagent ignores XAUTHORITY and fails to start if option -auth is given. Option -ac above complies "xhost +" and is disabled in xinitrc
      [ "$Xauthentication" = "yes" ] && {
        $Mksu "cp '$Hostxauthority' '$Xservercookie'"
        $Mksu "xauth -f '$Xclientcookie' add   $Newdisplay . $(mcookie)"
        $Mksu "xauth -f '$Xclientcookie' nlist $Newdisplay | xauth -f '$Xservercookie' nmerge -"
      }
      # fake NXclient
      export NX_CLIENT="$Cachefolder/nx_client"
      mkfile "$NX_CLIENT"
      echo '#! /bin/bash
# helper script to terminate nxagent. 
# nxagent runs program noted in NX_CLIENT if window close button is pressed.
# (real nxclient does not exist)
echo "NXclient: $*" >> '$Xinitlogfile'
parsed=$(getopt --options="" --longoptions="parent:,display:,dialog:,caption:,window:,message:" -- "$@")
eval set -- $parsed
while [ -n "${1:-}" ] ; do
  case "${1:-}" in
    --dialog) dialog=${2:-} && shift ;;
    --display|--caption|--message) shift ;;
    --window) shift ;;
    --parent) pid=${2:-} && shift ;;
    --) ;;
  esac
  shift
done
case $dialog in
  pulldown) ;;
  yesnosuspend) 
    kill $pid 
    touch "'$Timetosaygoodbye'"
  ;;
esac
' >> "$NX_CLIENT"
      $Mksu "chmod +x '$NX_CLIENT'"
      
      mkfile "$NXAGENT_KEYSTROKEFILE"
      echo '<!DOCTYPE NXKeystroke>
    <keystrokes>
    <keystroke action="fullscreen" AltMeta="0" Control="0" Shift="1" key="F11" />
    <keystroke action="fullscreen" AltMeta="1" Control="1" Shift="1" key="f" />
</keystrokes>' >> "$NXAGENT_KEYSTROKEFILE"
    ;;
    
    --hostwayland) Waylandsocket="$Hostwayland" ;;
    --hostdisplay|--nothing) ;;
  esac
  
  [ "$Sharewayland" = "yes" ] && [ -z "$Waylandsocket" ] && Sharewayland="no" && note "No wayland socket to share"
}

{ #### part: create $Newxenv: Environment variables
  case $Xserver in
    --xpra|--xephyr|--xpra-xwayland|--weston-xwayland|--hostdisplay|--xorg|--xdummy|--xvfb|--xdummy-xwayland|--xwayland|--kwin-xwayland|--nxagent)
      Newxenv="DISPLAY=$Newdisplay"
      [ "$Xauthentication" = "yes" ] && Newxenv="$Newxenv XAUTHORITY=$Xclientcookie"
      Newxenv="$Newxenv XSOCKET=$Newxsocket"
      Newxenv="$Newxenv $Xprashm"
    ;;
    --weston|--kwin|--hostwayland|--nothing)
      Newxenv="DISPLAY= XAUTHORITY="
      Newdisplay=""
      Newxsocket=""
      Xclientcookie=""
      Xservercookie=""
    ;;
  esac
  [ "$Sharewayland" = "yes" ] && {
    [ -n "$Waylandsocket" ]                              &&  Newxenv="$Newxenv WAYLAND_DISPLAY=$Waylandsocket"
    [ -z "$Waylandsocket" ] && [ -n "$Hostwayland" ]     &&  Newxenv="$Newxenv WAYLAND_DISPLAY=$Hostwayland"
    [ -z "$Waylandsocket" ] && [ -z "$Hostwayland" ]     &&  { note "No wayland environment to share,
  neither from host nor from $Xserver (--sharewayland)"
      Sharewayland="no" 
    }  ||  Newxenv="$Newxenv XDG_RUNTIME_DIR=$XDG_RUNTIME_DIR"
  }
  [ "$Setwaylandenv" = "yes" ] && for Line in $Waylandtoolkitenv ; do Newxenv="$Newxenv $Line" ; done
  Newxenv="$Newxenv X11DOCKER_CACHE=$Cachefolder"
  
  # custom environment
  IFS=$'\n'
  for Line in $Customenvironment; do Newxenv="$Newxenv $Line" ; done
  IFS=$' \t\n'
}

{ #### part: create shareclipboard script (option --clipboard)
  # use xclip to share text clipboard content between X servers.
  # xpra and nxagent have their own clipboard management.
  # only xpra supports image clips.
 
  case $Shareclipboard in                        # option '-c, --clipboard'
    yes) Xpraoptions="$Xpraoptions --clipboard"   ;;
    no)  Xpraoptions="$Xpraoptions --no-clipboard" ;; 
  esac
  
  [ "$Shareclipboard" = "yes" ] && case $Xserver in
    --nothing|--weston|--hostwayland|--kwin) Shareclipboard="no" 
      note "Option --clipboard is not supported for $Xserver" ;;
    --nxagent) ;; # look at "create command to start X server", nxagent has its own clipboard management
    --xephyr|--xorg|--xdummy|--xdummy-xwayland|--xvfb|--xwayland|--weston-xwayland)
      command -v xclip >/dev/null && {
        echo "#! /bin/bash
# share clipboard between X servers $Hostdisplay and $Newdisplay
while [ ! -e '"$Timetosaygoodbye"' ] ; do
    # read content of clipboard of first X server
    D1CLIP=\"\$(env XAUTHORITY=$Hostxauthority xclip -selection clipboard -o -display $Hostdisplay)\"
    # check if clipboard of first X server has changed; if yes, send new content to second X server
    [ \"\$CLIP\" != \"\$D1CLIP\" ] && {
        CLIP=\"\$D1CLIP\"
        env XAUTHORITY=$Hostxauthority xclip -selection clipboard -o -display $Hostdisplay | env XAUTHORITY=$Xclientcookie xclip -selection clipboard -i -display $Newdisplay
    }
    [ -z \"\$CLIP\" ] && CLIP=' '      # avoid empty string error
    
    # read content of clipboard of second X server
    D2CLIP=\"\$(env XAUTHORITY=$Xclientcookie xclip -selection clipboard -o -display $Newdisplay)\"
    # check if clipboard of second X server has changed; if yes, send new content to first X server
    [ \"\$CLIP\" != \"\$D2CLIP\" ] && {
        CLIP=\"\$D2CLIP\"
        env XAUTHORITY=$Xclientcookie xclip -selection clipboard -o -display $Newdisplay | env XAUTHORITY=$Hostxauthority xclip -selection clipboard -i -display $Hostdisplay
    }
    [ -z \"\$CLIP\" ] && CLIP=' '      # avoid empty string error
    
    sleep 0.5                        # sleep a bit to avoid high cpu usage
done
" >> $Shareclipboardscript
      } || {
        note "Cannot share clipboard. Need package 'xclip'."
        Shareclipboard="no"
      }
    ;;
  esac
}

{ #### part: check run/--exe/--xonly
  [ -z "$Imagename" ] && X11dockermode="xonly" && Showdisplayenvironment="yes"
  case $X11dockermode in
    run)
      command -v docker >/dev/null || error "docker is not installed.
  To run docker images, you need to install docker."
      pidof dockerd >/dev/null     || error "Please make sure docker daemon is running.
  Try as root: 'systemctl start docker'"
    ;;
    exe)
      Hostexe="$Imagename $Imagecommand"
      Imagename=""
      Imagecommand=""
      [ -z "$Hostexe" ]              && error "No host executable defined"
      command -v $Hostexe >/dev/null || error "Command '$Hostexe' not found."
      Hostexebasename="$(basename $(echo $Hostexe | cut -d' ' -f1))"
      [ -n "$Windowmanager" ] && {
        Hostexe="$Windowmanager & $Hostexe"
        Windowmanager=""
      }
    ;;
    xonly)
      case $Xserver in
        --nothing|--hostwayland) 
          note "You are using $Xserver along with --xonly. 
  That will achieve nothing"
        ;;
        *)
          case $Windowmanager in
            "") Hostexe="mywatch 'ls $Timetosaygoodbye 2>/dev/null'" ;;
            *)  Hostexe="$Windowmanager" ; Windowmanager="" 
            ;;
          esac
          Imagename=""
          Imagecommand=""
          Hostexebasename="xonly"
          X11dockermode="exe"
        ;;
      esac
    ;;
  esac
}

{ #### part: check password prompt frontend (pkexec, su, sudo, ...) 
  # check if x11docker can run docker without prompting for password
  [ "$Passwordprompt" = "none" ] && Needpassword="no"
  [ -z "$Passwordprompt" ] && docker images >/dev/null 2>&1 && Passwordprompt="none" && Needpassword="no"
  [ -z "$Passwordprompt" ] && sudo -n env   >/dev/null 2>&1 && Passwordprompt="sudo" && Needpassword="no"

  # check sudo. Check is not reliable, compare https://unix.stackexchange.com/questions/383918/su-or-sudo-how-to-know-which-one-will-work
  ### FIXME: just guessing that members of group sudo or wheel are allowed to run commands docker and env as root
  [ -z "$Passwordprompt" ] && { sudo -ln docker >/dev/null 2>&1  ||  id | grep -q '(sudo)'  ||  id | grep -q '(wheel)' ; } && command -v sudo >/dev/null && {
    [ -z "$Hostdisplay$Newdisplay" ] && Passwordprompt="sudo"
    sudo -ln env >/dev/null 2>&1  ||  id | grep -q '(sudo)'  ||  id | grep -q '(wheel)'  && {
      [ -z "$Passwordprompt" ] && command -v gksudo  >/dev/null && Passwordprompt="gksudo" 
      [ -z "$Passwordprompt" ] && command -v lxsudo  >/dev/null && Passwordprompt="lxsudo"
      [ -z "$Passwordprompt" ] && command -v kdesudo >/dev/null && Passwordprompt="kdesudo"
    }
    [ -z "$Passwordprompt" ] && Passwordprompt="sudo"
  }
  
  # check su
  [ -n "$Hostdisplay$Newdisplay" ] && {
    [ -z "$Passwordprompt" ] && command -v gksu  >/dev/null && Passwordprompt="gksu"
    [ -z "$Passwordprompt" ] && command -v lxsu  >/dev/null && Passwordprompt="lxsu"
    [ -z "$Passwordprompt" ] && command -v kdesu >/dev/null && Passwordprompt="kdesu"
    [ -z "$Passwordprompt" ] && command -v beesu >/dev/null && Passwordprompt="beesu"
  }
  [ -z "$Passwordprompt" ] && Passwordprompt="su" # default if everything else fails

  # Getroot: prefix to start dockerrc. Sudo: prefix to start docker in dockerrc
  case $Passwordprompt in
    pkexec|"") Getroot="bash -c"                                                ; Passwordterminal="bash -c" ;;
    su)        Getroot="su -c"                                                  ;;
    sudo)      Getroot="bash -c"                                                ; Sudo="sudo -E " ;;
    gksu)      Getroot="gksu    --message 'x11docker $Imagename'"               ; Passwordterminal="bash -c" ;;
    gksudo)    Getroot="gksudo  --message 'x11docker $Imagename'"               ; Passwordterminal="bash -c" ;;
    lxsu)      Getroot="lxsu"                                                   ; Passwordterminal="bash -c" ;;
    lxsudo)    Getroot="lxsudo"                                                 ; Passwordterminal="bash -c" ;;
    kdesu)     Getroot="kdesu -c"                                               ; Passwordterminal="bash -c" ;;
    kdesudo)   Getroot="kdesudo --comment 'x11docker $Imagename'"               ; Passwordterminal="bash -c" ;;
    beesu)     Getroot="beesu -c"                                               ; Passwordterminal="bash -c" ;;
    none)      Getroot="bash -c"                                                ; Passwordterminal="bash -c" ;;
    *) error "Unknown password prompt '$Passwordprompt' (option --pw).
  Possible: su sudo gksu gksudo lxsu lxsudo kdesu kdesudo beesu pkexec none" ;;
  esac
  command -v $(echo $Getroot|cut -d' ' -f1) >/dev/null || error "Password prompt frontend $(echo $Getroot|cut -d' ' -f1) not found"
}

{ #### part: check terminal for password prompt of su or sudo and for 'docker pull'
  # $Passwordterminal:  To prompt for su or sudo password
  # $Pullterminal:      To show output of "docker pull"
  
  # Not working: pangoterm lilyterm fbterm
  # Makes problems if X and Wayland are independently available at same time: xfce4-terminal
  # Works, but does not appear: 'guake -te'
  
  Terminallist=("xterm lxterm lxterminal stterm sakura termit pterm terminator terminology Eterm konsole qterminal gnome-terminal mate-terminal mrxvt rxvt xvt kterm mlterm xfce4-terminal NOLUCK")
  [ -z "$Hostdisplay$Newdisplay" ] && {
    case $Xserver in
      --weston|--hostwayland)  Terminallist=("konsole qterminal gnome-terminal NOLUCK") ;;
      --kwin)                  Terminallist=("konsole NOLUCK") ;;
      --nothing)               Terminallist=("bash NOLUCK") ;;
      *)                       Terminallist=("konsole NOLUCK") ;;
    esac
  }
  
  for Pullterminal in $Terminallist ; do command -v $Pullterminal >/dev/null && break ; done
  [ "$Pullterminal" = "NOLUCK" ] && error "Can not find a terminal emulator that works for $Xserver.
  Please install one of:
  ${Terminallist%"NOLUCK"}"
  
  [ -z "$Hostdisplay" ] && [ -n "$Waylandsocket" ] && {
    case $Pullterminal in 
      qterminal) Pullterminal="env QT_QPA_PLATFORM=wayland $Pullterminal" ;;
      konsole) Pullterminal="env QT_QPA_PLATFORM=wayland dbus-launch $Pullterminal --nofork" ;;
    esac
  }
  case $Pullterminal in
    xfce4-terminal) Pullterminal="$Pullterminal --disable-server -x" ;;
    gnome-terminal|mate-terminal) Pullterminal="dbus-launch $Pullterminal -x" ;;
    terminator)     Pullterminal="dbus-launch $Pullterminal --no-dbus -x" ;;
    konsole)        Pullterminal="dbus-launch $Pullterminal --nofork -e" ;;
    *)              Pullterminal="$Pullterminal -e" ;;
  esac
  [ -z "$Passwordterminal" ] && Passwordterminal="$Pullterminal"
  Anyterminal="$Pullterminal"
  
  [ -z "$Hostdisplay$Newdisplay" ] && {
    case $Xserver in
      --weston|--kwin|--hostwayland) ;;
      *) Passwordterminal="bash -c" ; Pullterminal="" ;;
    esac
  }
}

{ #### part: check container user and shared home folder
  ## check container user
  [ -z "$Benutzer" ] && Benutzer=$Hostuser                 # default: containeruser = hostuser. can be changed with --user
  [ -n "$Benutzer" ] && echo $Benutzer | grep -q ':' && {  # option --user can specify a group/gid after :
    Benutzergid="$(echo $Benutzer | cut -d: -f2)"
    Benutzer="$(echo $Benutzer | cut -d: -f1)"
  }
  [ -n "$(getent passwd $Benutzer)" ] && {                 # user exists on host
    Benutzer=$(getent passwd $Benutzer | cut -d: -f1)      # can be name or uid -> now name
    Benutzeruid=$(getent passwd $Benutzer | cut -d: -f3)
    [ -z "$Benutzergid" ] && Benutzergid=$(getent passwd $Benutzer | cut -d: -f4)
    Benutzerhome=$(getent passwd $Benutzer | cut -d: -f6)
  } || {                                                   # user does not exist on host
    [[ $Benutzer =~ ^[0-9]+$ ]] || error "Unknown user or invalid user number '$Benutzer' for option --user."  # virtual users can only be specified as uid
    Benutzeruid=$Benutzer
    Benutzer="unknown$Benutzer"
    [ -z "$Benutzergid" ] && Benutzergid=100
    Benutzerhome="/fakehome/$Benutzer"
    [ -z "$Benutzerhosthomefolder" ] && [ "$Benutzerhosthome" = "yes" ] && { 
      warning "Will not create a persistent home folder on host
  for a non-existing user. (Instead, you can specify --homedir to a location
  where user '$Benutzer' has write access.)
  Fallback: Disabling option --home, not creating a persistent home folder."
      Benutzerhosthome="no"
    }
  }
  Benutzergruppe="$(getent group $Benutzergid | cut -d: -f1 || echo group_$Benutzer)"

  [ "$Benutzer" = "$Hostuser" ] && Mksubenutzer=$Mksu || { 
    Mksubenutzer="su $Benutzer -c"
    [ "$X11dockermode" = "exe" ] && {
      [ "$(id -un)" != "root" ] && error "Must run as root to change user for option --exe"
      id $Benutzer >/dev/null 2>&1 || error "Option --exe supports real users only.
  Unknpwn user '$Benutzer' set with --user is not possible on host."
    }
  }
  
  ## option '--home':    share folder ~/.local/share/x11docker/imagename with created container as its home directory
  ## option '--homedir': share custom host folder as home
  case $Benutzerhosthome in
    yes)
      # if no home folder on host is specified (--homedir), create a standard one in ~/.local/share/x11docker
      [ -z "$Benutzerhosthomefolder" ] && Benutzerhosthomefolder="$Benutzerhome/.local/share/x11docker/$(echo $Imagename | tr / - | tr : - )$Hostexebasename"
      [ -d "$Benutzerhosthomefolder" ] || {
        [ "$(id -un)" = "root" ] && su $Benutzer -c "mkdir -p '$Benutzerhosthomefolder'"
        [ "$Benutzer" = "$Hostuser" ] && $Mksu "mkdir -p '$Benutzerhosthomefolder'" && {
          # create symbolic link to ~/x11docker
          echo "$Benutzerhosthomefolder" | grep -q .local/share/x11docker && [ ! -e "$Benutzerhome/x11docker" ] && $Mksu "ln -s '$Benutzerhome/.local/share/x11docker' '$Benutzerhome/x11docker'"
          :
        } || {
          # errors can occur if specifying a user with --user different from current user
          error "Can not create persistent home folder for 
  user '$Benutzer' on host (option --home or --homedir). 
  Four possibilities to solve issue: 
  1.) Create folder with write access for user '$Benutzer'
  $Benutzerhosthomefolder
  2.) Run x11docker one time as user '$Benutzer'.
  3.) Run x11docker one time as user 'root'.
  4.) Use option --homedir=DIR with DIR pointing to a writeable folder."
        }
      }
      writeaccess $Benutzeruid "$Benutzerhosthomefolder" || warning "User '$Benutzer' does not have write access to
  $Benutzerhosthomefolder."
    ;;
    no) Benutzerhome="/fakehome/$Benutzer" ;;
  esac
  
  # create entry for /etc/passwd
  Benutzerpasswdentry="$Benutzer:x:$Benutzeruid:$Benutzergid:$Benutzer,,,:$Benutzerhome:/bin/sh"
}

{ #### part: create init service files (options --systemd, --runit, --openrc)
  case $Initsystem in
    none|tini) [ "$Dbusdaemon" = "yes" ] && [ "$Capdropall" = "yes" ] && warning "Option --dbus-system allows capabilities
  for user switching in container." ;;
    systemd)
      warning "Option --systemd degrades container isolation.
  It allows some docker container capabilities (nearly like --cap-default).
  It shares access to host cgroups in /sys/fs/cgroup."
  
      Systemdtarget=$Cachefolder/x11docker.target             && mkfile $Systemdtarget
      Systemdstartcmd=$Cachefolder/x11docker-startcmd.service && mkfile $Systemdstartcmd
      Systemdwatch=$Cachefolder/x11docker-watch.service       && mkfile $Systemdwatch
      Systemdjournal=$Cachefolder/x11docker-journal.service   && mkfile $Systemdjournal
      Journallogfile=$Sharefolder/journalctl                  && mkfile $Journallogfile
      Systemdenvironment=$Cachefolder/systemd.env.conf        && mkfile $Systemdenvironment
    
      echo "[Unit]
Description=x11docker target
Wants=multi-user.target
After=multi-user.target
[Install]
Also=x11docker-startcmd.service
Also=x11docker-watch.service
Also=x11docker-journal.service
" >> $Systemdtarget

      echo "[Unit]
Description=x11docker start CMD service
Wants=multi-user.target
After=multi-user.target
Wants=x11docker-watch.service
Wants=x11docker-journal.service
Wants=dbus.service
[Service]
Type=simple
#User=$Benutzer # disabled because it does not invoke logind
#ExecStart=/bin/sh $Cshare/x11docker.CMD.sh
ExecStart=/bin/su - -s /bin/sh $Benutzer $Cshare/x11docker.CMD.sh
[Install]
WantedBy=x11docker.target
WantedBy=multi-user.target
" >> $Systemdstartcmd

      echo "[Unit]
Description=x11docker watch service
[Service]
Type=simple
ExecStart=/bin/sh -c 'while sleep 1; do systemctl is-active x11docker-startcmd >/dev/null || { su --shell /bin/sh $Benutzer -c touch $Cshare/timetosaygoodbye ; systemctl halt ; } ; [ -e $Cshare/timetosaygoodbye ] && systemctl halt ; done'
[Install]
WantedBy=x11docker.target
" >> $Systemdwatch

      echo "[Unit]
Description=x11docker journal log service
[Service]
Type=simple
ExecStart=/bin/sh -c '/bin/journalctl --follow --no-tail --merge >> $Cshare/journalctl 2>&1'
[Install]
WantedBy=x11docker.target
" >> $Systemdjournal

      echo "[Manager]
DefaultEnvironment=DISPLAY=$Newdisplay XAUTHORITY=$Cshare/Xclientcookie $(IFS=$'\n' ; for Line in $Customenvironment ; do echo -n "$Line " ; done)
" >> $Systemdenvironment
    ;;
    
    runit)
      warning "Option --runit slightly degrades container isolation.
  Beside some user switching capabilities x11docker would disable otherwise
  it adds capability SYS_BOOT."
    ;;
    
    openrc)
      warning "Option --openrc slightly degrades container isolation.
  Beside some user switching capabilities x11docker would disable otherwise
  it adds capability SYS_BOOT."
    ;;
    
    sysvinit)
      warning "Option --sysvinit slightly degrades container isolation.
  Beside some user switching capabilities x11docker would disable otherwise
  it adds capability SYS_BOOT."
    ;;
  esac
}

{ #### part: create command to run docker
  case $X11dockermode in
    exe) Dockercommand="# dontrundocker"  ;;
    run) Dockercommand="docker run -d --tty"
      [ "$Preservecontainer" = "no" ] && Dockercommand="$Dockercommand --rm"
      
      Containername="x11docker_X${Newdisplaynumber}_${Mycookie}_$(echo $Imagename | tr / _ | tr : _ )"
      Dockercommand="$Dockercommand --name=$Containername"
      
  
      case $Initsystem in
        runit|openrc|systemd|sysvinit) Dbusdaemon="yes" ;;
      esac
  
      [ "$Benutzeruid" = "0" ]     && Adminusercaps="yes"
      [ "$Sudouser" = "yes" ]      && Adminusercaps="yes"
      [ "$Adminusercaps" = "yes" ] && Switchcontaineruser="yes"
      [ "$Dbusdaemon" = "yes" ]    && Switchcontaineruser="yes"
      
      case $Initsystem in
        none|tini)
          case $Switchcontaineruser in
            no) Dockercommand="$Dockercommand \\
  --user $Benutzeruid:$Benutzergid --env USER=$Benutzer" ;;
            yes) Dockercommand="$Dockercommand \\
  --user root" ;;
          esac
        ;;
        systemd|runit|openrc|sysvinit) 
          Dockercommand="$Dockercommand \\
  --user root" ;;
      esac
      
      # Disable user namespacing if host home folder is in use. Files need same UID/GID.
      [ "$Benutzerhosthome" = "yes" ] && Dockercommand="$Dockercommand \\
  --userns=host"

      [ "$Capdropall" = "yes" ] && Dockercommand="$Dockercommand \\
  --cap-drop=ALL"
      
      # option --sys-admin (deprecated)
      [ "$Capsysadmin" = "yes" ] && Dockercommand="$Dockercommand \\
  --cap-add SYS_ADMIN"

      case $Initsystem in
        none) ;;
        tini) Dockercommand="$Dockercommand \\
  --init" ;;
  
        systemd)
          Switchcontaineruser="yes"
          Sharecgroup="yes"
          Dockercommand="$Dockercommand \\
  --stop-signal SIGRTMIN+3\\
  --cap-add FSETID      --cap-add FOWNER  --cap-add SETPCAP \\
  -v $Systemdtarget:/etc/systemd/system/x11docker.target:ro \\
  -v $Systemdstartcmd:/etc/systemd/system/x11docker-startcmd.service:ro \\
  -v $Systemdwatch:/etc/systemd/system/x11docker-watch.service:ro \\
  -v $Systemdjournal:/etc/systemd/system/x11docker-journal.service \\
  -v $Systemdenvironment:/etc/systemd/system.conf.d/x11docker.conf"
        ;;
        
        runit)
          Switchcontaineruser="yes"
          Dockercommand="$Dockercommand \\
  --stop-signal HUP     --env VIRTUALIZATION=docker \\
  --cap-add SYS_BOOT    --cap-add KILL"
        ;;
        
        openrc)
          Switchcontaineruser="yes"
          Dockercommand="$Dockercommand \\
  --cap-add SYS_BOOT    --cap-add KILL"
        ;;
        
        sysvinit)
          Switchcontaineruser="yes"
          Dockercommand="$Dockercommand \\
  --cap-add SYS_BOOT    --cap-add KILL"
        ;;
      esac
      
      [ "$Capdropall" = "yes" ] && {
        [ "$Adminusercaps" = "yes" ] && {
          Switchcontaineruser="yes"
          Dockercommand="$Dockercommand \\
  --cap-add CHOWN       --cap-add KILL\\
  --cap-add FSETID      --cap-add FOWNER  --cap-add SETPCAP"
        }
        [ "$Switchcontaineruser" = "yes" ] && {
          Dockercommand="$Dockercommand \\
  --cap-add SETUID      --cap-add SETGID  --cap-add DAC_OVERRIDE\\
  --cap-add AUDIT_WRITE"
        } || {
          Dockercommand="$Dockercommand \\
  --security-opt no-new-privileges"
        }
        # option --dbusdaemon: dbus needs CHOWN for XDG_RUNTIME_DIR
        [ "$Dbusdaemon" = "yes" ] && [ "$Adminusercaps" = "no" ] && Dockercommand="$Dockercommand \\
  --cap-add CHOWN"
      }

      # SELinux restrictions for containers must be disabled to allow access to X socket. Flags z or Z do not help.
      Dockercommand="$Dockercommand \\
  --security-opt label=type:container_runtime_t"
  
      # option --sharecgroup
      [ "$Sharecgroup" = "yes" ] && Dockercommand="$Dockercommand \\
  -v /sys/fs/cgroup:/sys/fs/cgroup:ro"
      
      # Add video group for GPU access, needed by some systems
      # Add audio group for ALSA
      # Does only have real effect if /dev/dri or /dev/snd is shared
      # Use GID instead of group name as they can differ from container GIDs
      # entries in /etc/group are not regarded without user switching in container
      [ "$Switchcontaineruser" = "no" ] && {
        [ "$Hostgidaudio" ] && Dockercommand="$Dockercommand \\
  --group-add $Hostgidaudio"
        [ "$Hostgidvideo" ] && Dockercommand="$Dockercommand \\
  --group-add $Hostgidvideo"
      }
      
      # especially needed for --systemd, but others, too
      [ "$Dbusdaemon" = "yes" ] && Dockercommand="$Dockercommand \\
  --tmpfs /tmp --tmpfs /run --tmpfs /var/run --tmpfs /run/lock"
      
      # entrypoint is checked in dockerrc
      Dockercommand="$Dockercommand \\
  --entrypoint=env"
      
      # At least OpenRC and systemd regard this hint
      Dockercommand="$Dockercommand \\
  --env container=docker"

      # shared host folders
      Dockercommand="$Dockercommand \\
  -v $Sharefolder:$Cshare:rw"
      [ "$Benutzerhosthome" = "yes" ] && [ -n "$Benutzerhosthomefolder" ] && Dockercommand="$Dockercommand \\
  -v '$Benutzerhosthomefolder':'$Benutzerhome':rw"
      for ((Count=1 ; Count<=$Sharevolumescount ; Count++)) ; do
        case "${Sharevolumes[$Count]}" in
          "$Benutzerhome") Dockercommand="$Dockercommand \\
  -v '${Sharevolumes[$Count]}':'${Sharevolumes[$Count]}/$(basename $Benutzerhome)':rw" 
          ;;
          *) Dockercommand="$Dockercommand \\
  -v '${Sharevolumes[$Count]}':'${Sharevolumes[$Count]}':rw" 
          ;;
        esac
      done
      
      # X socket will be softlinked to /tmp/.X11-unix in x11docker.CMD.sh
      case $Xserver in
        --nothing) ;;
        --weston|--hostwayland|--kwin) ;;
        *) 
#          [ "$Newxlock" ] && Dockercommand="$Dockercommand \\
#  -v $Newxlock:/$(basename $Newxlock):rw"
          [ "$Newxsocket" ] && Dockercommand="$Dockercommand \\
  -v $Newxsocket:/X$Newdisplaynumber:rw"
        ;;
      esac
      # Wayland socket will be softlinked to XDG_RUNTIME_DIR in x11docker.CMD.sh
      [ "$Sharewayland" = "yes" ] && Dockercommand="$Dockercommand \\
  -v $XDG_RUNTIME_DIR/$Waylandsocket:/$Waylandsocket:rw"
      
      ## option --gpu : share graphics adapter device files
      [ "$Gpu" = "yes" ] && {
        while read -r Line ; do
          Dockercommand="$Dockercommand \\
  --device=$Line:$Line:rw \\
  -v $Line:$Line:rw"
        done < <(find /dev/dri /dev/nvidia* /dev/vga_arbiter -maxdepth 0 2>/dev/null ||:)
      }
      
      ## options --hostipc and --hostnet
      [ "$Sharehostipc" = "yes" ]      && Dockercommand="$Dockercommand \\
  --ipc=host"
      [ "$Sharehostnet" = "yes" ]      && Dockercommand="$Dockercommand \\
  --net=host"
      ## option --no-internet
      [ "$Internetaccess" = "no" ]     && Dockercommand="$Dockercommand \\
  --net=none"
      ## option --alsa      
      [ "$Alsa" = "yes" ]              && Dockercommand="$Dockercommand \\
  --device=/dev/snd:/dev/snd:rw -v /dev/snd:/dev/snd:rw"
      ## synchronize time location from host and container
      [ -e /etc/localtime ] && Dockercommand="$Dockercommand \\
  -v /etc/localtime:/etc/localtime:ro"
      ## option --pulseaudio
      [ "$Pulseaudio" = "yes" ]        && Dockercommand="$Dockercommand \\
  -v $Pulseaudiosocketdir:/pulse:rw \\
  -v $Cachefolder/pulseclient.conf:/etc/pulse/client.conf:rw"
      ## option --workdir
      [ "$Workdir" ] && Dockercommand="$Dockercommand \\
  --workdir $Workdir" || Dockercommand="$Dockercommand \\
  --workdir /tmp"
      
      # option --env: add custom environment. Only needed here for possible 'docker exec'. Otherwise set in x11docker.CMD.sh
      IFS=$'\n'
      for Line in $Customenvironment ; do
        Dockercommand="$Dockercommand \\
  --env $Line"
      done
      IFS=$' \t\n'
  
      # add custom docker arguments, imagename and imagecommand
      Dockercommand="$Dockercommand \\
  $Dockeroptions"
      case $Switchcontaineruser in
        no)       Dockercommand="$Dockercommand  --  $Imagename /bin/sh - $Cshare/x11docker.CMD.sh" ;;   # dockerrc runs containersetup.sh
        yes)      Dockercommand="$Dockercommand  --  $Imagename /bin/sh - $Cshare/containersetup.sh" ;;  # containersetup.sh runs x11docker.CMD.sh
      esac
    ;;
  esac
}

{ #### part: create container setup script
  echo "#! /bin/sh"
  echo "# set up docker container before ongoing in x11docker.CMD.sh"
  echo "# commands in this script are executed as root in container"
  [ "$Debug" = "yes" ] && echo "set -x"
  echo ""
  echo "# create some system dirs with needed permissions"
  echo "mkdir -v -p /var/lib/dbus /var/run/dbus"
  echo "mkdir -v -p -m 1777 /tmp/.ICE-unix /tmp/.X11-unix /tmp/.font-unix"
  echo "chmod -c 1777 /tmp/.ICE-unix /tmp/.X11-unix /tmp/.font-unix"
  echo "ln -s /X$Newdisplaynumber $Newxsocket" # done again in x11docker.CMD.sh. At least x11docker/deepin needs it here already.
  #[ "$Newxlock" ] && echo "ln -s /$(basename $Newxlock) $Newxlock"
  echo "ls -l $Newxsocket"
  echo "export DISPLAY=$Newdisplay XAUTHORITY=$Cshare/Xclientcookie"
  echo ""

  IFS=$'\n'
  for Line in $Customenvironment ; do
    [ "$Line" ] && echo "export $Line" 
  done
  IFS=$' \t\n'
  echo ""
  
  echo "# create user entry in /etc/passwd (and delete possibly existing same uid)"
  echo "getent passwd | grep -v \$(getent passwd $Benutzeruid || echo USERNOTFOUND) > /tmp/passwd"
  echo "echo $Benutzerpasswdentry >> /tmp/passwd"
  echo "mv /tmp/passwd /etc/passwd"
  echo ""
  echo "# make sure root has no password in /etc/shadow"
  echo "sed -i /root.*/d /etc/shadow"
  case $Sudouser in
    no)  echo "echo 'root:*:17219:0:99999:7:::' >> /etc/shadow" ;;
    yes) echo "echo 'root:$Benutzerpasswort:17219:0:99999:7:::' >> /etc/shadow  # with option --sudouser, set root password 'x11docker'" ;;
  esac
  echo ""
  echo "# create password entry for container user in /etc/shadow"
  echo "sed -i /$Benutzer.*/d /etc/shadow # delete user entry if already existing"
  echo "echo \"$Benutzer:$Benutzerpasswort:17293:0:99999:7:::\" >> /etc/shadow"
  echo ""
  echo "# add user to groups video, audio, systemd-journal"
  echo "# replace container GIDs of video and audio with host GIDs"
  echo "Gidvideo=$Hostgidvideo"
  echo "Gidaudio=$Hostgidaudio"
  echo "[ \"\$Gidvideo\" ] || Gidvideo=\$(getent group | grep video: | cut -d: -f3)"
  echo "[ \"\$Gidaudio\" ] || Gidaudio=\$(getent group | grep audio: | cut -d: -f3)"
  echo "getent group | sed \"s/^video.*/video:x:\$Gidvideo:\$(getent group | grep video: | cut -d: -f4 ),$Benutzer/ ;"
  echo "                     s/^audio.*/audio:x:\$Gidaudio:\$(getent group | grep audio: | cut -d: -f4 ),$Benutzer/ ;;"
  echo "                     s/^systemd-journal.*/\0,$Benutzer/ \" | sed 's/:,/:/' > /tmp/group"
  echo "cp /tmp/group /etc/group"
  echo ""
  echo "# create user group entry (and delete possibly existing same gid)"
  echo "getent group | grep -v \$(getent group $Benutzergid || echo USERNOTFOUND) > /tmp/group"
  echo "echo $Benutzergruppe:x:$Benutzergid: >> /tmp/group"
  echo "mv /tmp/group /etc/group"
  echo ""
  [ "$Benutzerhosthome" = "no" ] && echo "mkdir -v -m 777 /fakehome"
  echo ""
  [ "$Switchcontaineruser" = "yes" ] && {
    echo "# create /etc/sudoers, remove /etc/sudoers.d. Delete possible sudo setups in image."
    echo "echo 'root ALL=(ALL) ALL' > /etc/sudoers"
    echo "rm -R /etc/sudoers.d"
    [ "$Sudouser" = "yes" ] && {
      echo "# create sudo entry for container user"
      echo "echo '$Benutzer ALL=(ALL) ALL' >> /etc/sudoers"
    }
  }
  echo ""
  case $Initsystem in
    tini|none)
      [ "$Dbusdaemon" = "yes" ] && {
        echo "echo 'x11docker: starting dbus system daemon'"
        echo "dbus-daemon --system --fork"
      }
    ;;
    systemd)
      echo "# to be sure, allow/unmask most important services"
      echo "systemctl unmask systemd-logind dbus"
      echo "# disable cgproxy.service, can cause failing startup."
      echo "systemctl mask cgproxy"
      echo "# enable x11docker CMD service"
      echo "systemctl enable x11docker-startcmd.service"
    ;;
    runit)
     echo "# create and enable x11docker service containing image command"
     echo "mkdir -p /etc/sv/x11docker"
     echo "printf '#! /bin/sh
waitforservice() {
  Service=\$1
  [ \"\$(sv check \$Service | cut -d: -f1)\" = \"ok\" ] && {
    echo \"x11docker: waiting for service \$Service ...\"
    for Count in $(seq -s' ' 20); do
      [ \"\$(sv status \$Service | cut -d: -f1)\" = \"down\" ] && sleep 0.2 || break
    done
  }
}
# make stderr visible
exec 2>&1
# wait for all other services
for Service in \$(ls /etc/runit/runsvdir/default/) ; do waitforservice \$Service ;done
echo \"Current status of runit services:\"
for Service in \$(ls /etc/runit/runsvdir/default/) ; do sv status      \$Service ;done
# x11docker service should only run once
sv once x11docker
su - --shell=/bin/sh $Benutzer $Cshare/x11docker.CMD.sh
runit-init 0
' > /etc/sv/x11docker/run"
      echo "chmod +x /etc/sv/x11docker/run"
      echo "ln -s /etc/sv/x11docker /etc/runit/runsvdir/default"
      echo "echo 'x11docker: enabling dbus service'"
      echo "ln -s /etc/sv/dbus  /etc/runit/runsvdir/default"
    ;;
    openrc)
      echo "# create and enable x11docker service containing image command"
      echo "printf \"#!/sbin/openrc-run
name=x11docker
depend() {
  after *
}
start() {
  ebegin 'Starting x11docker.CMD.sh'
  su - -s /bin/sh $Benutzer $Cshare/x11docker.CMD.sh
  openrc shutdown
  halt
  eend \$?
}
\" > /etc/init.d/x11docker.service"
      echo "chmod +x /etc/init.d/x11docker.service"
      echo "rc-update add x11docker.service default"
      echo "echo 'x11docker: enabling dbus service'"
      echo "rc-update add dbus default"
      echo "# disable getty in inittab" 
      echo "sed -i 's/.*getty/##getty disabled by x11docker## \0/' /etc/inittab"
      echo "# tell openrc that it runs in docker"
      echo "sed -e 's/#rc_sys=\"\"/rc_sys=\"docker\"/g' -i /etc/rc.conf"
    ;;
    sysvinit)
      echo "# add x11docker start command to rc.local"
      echo "sed -i '/exit 0/d' /etc/rc.local"
      echo "echo 'su - -s /bin/sh $Benutzer $Cshare/x11docker.CMD.sh || echo \"x11docker: Exit code \$?\"' >> /etc/rc.local"
      echo "echo 'shutdown -hP 0' >> /etc/rc.local"
      echo "# disable getty in inittab" 
      echo "sed -i 's/.*getty/##getty disabled by x11docker## \0/' /etc/inittab"
    ;;  
  esac

  [ "$Langwunsch" ] && {
    echo "echo \"x11docker: Searching for language locale matching $Langwunsch\""
    echo "Locales=\"\$(locale -a)\""
    echo "Langall=\"\$(cat /usr/share/i18n/SUPPORTED | grep -E 'UTF-8|utf8' | cut -d' ' -f1 | cut -d. -f1 | cut -d@ -f1 | sort | uniq)\""
    echo "Langland=\$(echo $Langwunsch | cut -d. -f1)"
    echo "echo \$Langland | grep -q '_' || {"
    echo "  Langland=\"\$(echo \$Langland | tr '[:upper:]' '[:lower:]')_\$(echo \$Langland | tr '[:lower:]' '[:upper:]')\""
    echo "  echo \"\$Langall\" | grep -q \$Langland || {"
    echo "    echo \"\$Langall\" | grep -i -q $Langwunsch && {"
    echo "      Langland=\$(echo \"\$Langall\" | grep -i -m1 $Langwunsch)"
    echo "    }"
    echo "  }"
    echo "}"
    echo "Langland=\$(echo \$Langland | cut -d_ -f1 | tr '[:upper:]' '[:lower:]')_\$(echo \$Langland | cut -d_ -f2 | tr '[:lower:]' '[:upper:]')"
    echo "echo \"\$Locales\" | grep -q \$Langland.UTF-8 && Langcontainer=\$Langland.UTF-8"
    echo "echo \"\$Locales\" | grep -q \$Langland.utf8  && Langcontainer=\$Langland.utf8"
    echo "echo $Langwunsch | grep -E 'C|C.UTF-8|C.utf8|POSIX' >/dev/null && Langcontainer=$Langwunsch"
    echo "[ -z \"\$Langcontainer\" ] && {"
    echo "  [ -e /usr/share/i18n/SUPPORTED ] || echo \"x11docker ERROR: /usr/share/i18n/SUPPORTED not found."
    echo "  Please install locale package in image (belongs to glibc).\""
    echo "  Langcontainer=\$Langland.utf8"
    echo "  echo \"x11docker: Creating language locale \$Langcontainer\""
    echo "  command -v localedef >/dev/null || echo \"x11docker ERROR: command localedef not found in image.\""
    echo "  localedef --verbose --force -i \$Langland -f UTF-8 \$Langcontainer || echo \"x11docker: localedef exit code: \$?\""
    echo "  locale -a | grep -q \"\$Langcontainer\" || {"
    echo "    echo \"x11docker ERROR: locale creation of \$Langcontainer failed.\""
    echo "    Langcontainer=''"
    echo "  }"
    echo "} || {"
    echo "  echo \"x11docker: Found locale in image: \$Langcontainer\""
    echo "}"
    echo "[ \"\$Langcontainer\" ] && {"
    echo "  echo \"\$Langcontainer\" > /x11docker.LANG"
    echo "  echo \"LANG=\$Langcontainer\" > /etc/default/locale"
    echo "} || echo \"x11docker WARNING: desired locale for '--lang=$Langwunsch' not found and not created.\""
    echo "echo \"x11docker: Output of locale -a:\""
    echo "locale -a"
  }
  
  echo ""
  [ "$Pulseaudio" = "yes" ] && {
    echo "command -v pulseaudio >/dev/null || echo \"x11docker ERROR: pulseaudio not found in image (option --pulseaudio)\""
  }
  
  echo ""
  echo ":> /x11docker.setupready"
  [ "$Switchcontaineruser" = "yes" ] && {   # if "no", x11docker.CMD.sh is executed in command line $Dockercommand
    case $Initsystem in
      tini|none)             echo "exec /bin/su - -s /bin/sh $Benutzer $Cshare/x11docker.CMD.sh" ;;
      runit|openrc|sysvinit) echo "exec /sbin/init" ;;
      systemd)
        echo 'Systemd=/lib/systemd/systemd'
        echo '[ -e "$Systemd" ] || Systemd=/bin/systemd'
        echo '[ -e "$Systemd" ] || Systemd=/sbin/systemd'
        echo '[ -e "$Systemd" ] || {'
        echo '  echo "x11docker WARNING: executeable for systemd not found. Will try /sbin/init"'
        echo '  Systemd=/sbin/init'
        echo '}'
        echo '[ -e "$Systemd" ] || {'
        echo '  echo "x11docker ERROR: Is systemd really installed in image?"'
        echo '  exit 1'
        echo '}'
        echo 'exec $Systemd'
      ;;
    esac
  }
} >> $Setupscript

{ #### part: create dockerrc: inspect image, create x11docker.CMD.sh and run docker <- dockerrc is running as root on host (or as member of group docker)
  # create script that needs root permissions or docker group membership to use docker.
  # This is the part the password prompt / $Getroot is needed for.
  echo "#! /bin/bash"
  declare -f waitforfilecreation verbose warning note notestdout escapestring
  [ "$Debug" = "yes" ] && {
    echo "PS4='$DebugPS4'"
    echo "set -x"
    declare -f traperror | sed 's/Command/dockerrc: Command/'
    echo "set -Eu"
    echo "trap 'traperror \$? \$LINENO \$BASH_LINENO \"\$BASH_COMMAND\" \$(printf \"::%s\" \${FUNCNAME[@]})'  ERR"
  }
  echo "Imagename=\"$Imagename\""
  echo "Imagecommand=\"$Imagecommand\""
  
  echo "# check if image is available locally"
  echo "docker inspect --type=image $Imagename > /dev/null 2>&1 || {"
  #[ "$Pullterminal" = "$Passwordterminal" ] && Pullterminal=""
  [ -n "$Hostxenv" ]&& echo "  export $Hostxenv"
  [ -n "$Newxenv" ] && [ "$Tty" = "yes" ] && echo "  export $Newxenv"
  [ "$Xserver" = "--xorg" ] && echo "  export $Newxenv"
  echo "  $Pullterminal /bin/bash $Pullrc"
  echo "  waitforfilecreation $Cachefolder/pullready"
  echo "  docker inspect --type=image $Imagename > /dev/null 2>&1 || {"
  echo "    echo ''"
  echo "    echo \"ERROR: Image '$Imagename' not found locally and not pulled from docker hub. \" >&2"
  echo "    exit 1"
  echo "  }"
  echo "}"  
  echo "# check CMD"
  echo "[ -z \"\$Imagecommand\" ] && {"
  echo "  # extract image command from image if not given on cli"
  echo "  Imagecommand=\$(docker inspect --format='{{.Config.Cmd}}' $Imagename)"
  echo "  Imagecommand=\${Imagecommand#[}"
  echo "  Imagecommand=\${Imagecommand#/bin/sh -c }"
  echo "  Imagecommand=\${Imagecommand%]}"
  echo "}"
  [ "$Noentrypoint" = "no" ] && {
    echo "# check ENTRYPOINT"
    echo "Entrypoint=\$(docker inspect --format='{{.Config.Entrypoint}}' $Imagename)"
    echo "Entrypoint=\${Entrypoint#[}"
    echo "Entrypoint=\${Entrypoint#/bin/sh -c }"
    echo "Entrypoint=\${Entrypoint%]}"
    [ "$Initsystem" != "none" ] && {
      echo "echo \"\$Entrypoint\" | grep -qE '/tini|/init|/systemd' && {"
      echo "  note 'There seems to be an init system in ENTRYPOINT of image: \$ENTRYPOINT"
      echo "  Will disable it as x11docker already runs an init with option --$Initsystem."
      echo "  To allow this ENTRYPOINT, run x11docker with option --no-init.'"
      echo "  Entrypoint="
      echo "}"
    } ||:
  } || echo "Entrypoint="
  echo "[ -z \"\$Imagecommand\$Entrypoint\" ] && echo 'x11docker WARNING: No image command specified and no CMD or ENTRYPOINT found in image.'|tee -a $Logfile"
  
  echo "# create x11docker.CMD.sh (shared with container and given as image command to docker run)"
  echo "{ echo '#! /bin/sh'"
  [ "$Debug" = "yes" ] && echo "echo 'set -x'"
  echo "  echo '# created startscript for docker run: x11docker.CMD.sh'"
  echo '  echo Imagecommand="\"$Imagecommand\""'
  echo '  echo Entrypoint="\"$Entrypoint\""'
  echo "  echo ''"
  echo "  echo 'echo x11docker: container system:'"
  echo "  echo 'cat /etc/os-release'"
  echo "  echo ''"
  
  echo "  echo '# wait for container setup script do be ready'"
  echo "  echo 'for Count in $(seq -s' ' 30); do'"
  echo "  echo '  [ -e /x11docker.setupready ] && break'"
  echo "  echo '  echo x11docker: waiting for root setup to be ready && sleep 0.1'"
  echo "  echo 'done'"
  echo "  echo ''"
  echo "} >> $Imagecommandscript"
  
  [ "$Switchcontaineruser" = "yes" ] && {
    echo "echo '# Environment variables found in image:' >> $Imagecommandscript"
    echo "IFS=$'\n'"
    echo "while read -r Line; do"
    echo "  echo export \$(escapestring \"\$Line\") >> $Imagecommandscript"
    echo "done < <(docker run --rm --entrypoint env $Imagename env)"
    echo "IFS=$' \t\n'"
  }
  
  echo "{"
  echo "  echo ''"
  echo "  echo '# x11docker variable settings'"
  echo "  echo export USER=\"$Benutzer\""
  [ "$Benutzerhosthome" = "no" ] && {
    echo "  echo mkdir -p -v $Benutzerhome"
    for ((Count=1 ; Count<=$Sharevolumescount ; Count++)) ; do
      echo "  echo '# create soft links of shared folders to fake home'"
      echo "  echo 'ln -s ${Sharevolumes[$Count]} $Benutzerhome'"
    done
  }
  echo "  echo 'export HOME=\"$Benutzerhome\"'"
  echo "  echo 'cd \"\$HOME\"'"
  [ "$Workdir" ] && echo "  echo 'cd $Workdir'"

  echo "  echo ''"
  
  [ -n "$Newdisplay" ] && {
    echo "  echo 'export DISPLAY=$Newdisplay'"
    # already done in setup script as needed at least by x11docker/deepin, but repeated here as some init systems clean up /tmp
    echo "  echo 'ln -s /X$Newdisplaynumber /tmp/.X11-unix'"
    #[ "$Newxlock" ] && echo "  echo 'ln -s /$(basename $Newxlock) $Newxlock'"
  }
  [ "$Xauthentication" = "yes" ] && echo "  echo 'export XAUTHORITY=$Cshare/Xclientcookie'"
  [ "$Xserver" = "--nothing" ]   && echo "  echo 'unset DISPLAY WAYLAND_DISPLAY XAUTHORITY'"
  [ "$Dbusdaemon" = "yes" ] && Dbuslaunch="yes"
  [ "$Dbuslaunch" = "yes" ] && {
    echo "  echo ''"
    echo "  echo 'Dbus=\"\$(dbus-launch --help >/dev/null 2>&1 && echo dbus-launch)\"'"
    echo "  echo '[ -z \"\$Dbus\" ] && Dbus=\"\$(dbus-run-session --help >/dev/null 2>&1 && echo dbus-run-session)\"'"
    echo "  echo '[ -z \"\$Dbus\" ] && echo \"x11docker WARNING: Did not find dbus-launch or dbus-run-session (option --dbus).\" >&2'"
  } 
  echo "  echo 'echo x11docker: running dbus user session with: \${Dbus:-(none)} >&2'"
  echo "  echo ''"
  echo '  echo "[ -e \"\$XDG_RUNTIME_DIR\" ] || {"'
  echo "  echo '  export XDG_RUNTIME_DIR=/tmp/XDG_RUNTIME_DIR'"
  echo "  echo '  mkdir -v -m 700 -p \$XDG_RUNTIME_DIR'"
  echo "  echo '  export XDG_RUNTIME_DIR'"
  echo "  echo ''"
  echo "  echo '}'"
  
  [ "$Sharewayland" = "yes" ] && {
    echo "  echo ''"
    echo "  echo '# Wayland environment'"
    echo "  echo 'export WAYLAND_DISPLAY=$Waylandsocket'"
    echo "  echo 'ln -s /$Waylandsocket \$XDG_RUNTIME_DIR/$Waylandsocket'"
    echo "  echo 'ls -la \$XDG_RUNTIME_DIR/$Waylandsocket'"
  }
  [ "$Setwaylandenv" = "yes" ] && {
    for Line in $Waylandtoolkitenv ; do echo "  echo export $Line" ; done
  } || case $Xserver in
    --weston|--kwin|--hostwayland) echo "  echo 'export XDG_SESSION_TYPE=wayland'" ;;
    --nothing) ;;
    *)                             echo "  echo 'export XDG_SESSION_TYPE=x11'" ;;
  esac
  
  echo "  echo ''"
  echo "  echo '# xpra environment settings'"
  echo "  echo 'export UBUNTU_MENUPROXY= QT_X11_NO_NATIVE_MENUBAR=1 MWNOCAPTURE=true MWNO_RIT=true MWWM=allwm'"
  [ -n "$Xprashm" ] && echo "  echo 'export $Xprashm'"
  
  echo "  echo ''"
  echo "  echo 'bash --version >/dev/null 2>&1 && export SHELL=/bin/bash || export SHELL=/bin/sh'"
  echo "  echo 'export TERM=xterm'"
  echo "  echo ''"

  echo "  echo '[ -e /x11docker.LANG ] && export LANG=\"\$(cat /x11docker.LANG)\"'"
  echo "  echo ''"
  
  [ "$Pulseaudio" = "yes" ] && echo "  echo 'export $Pulseserver'"

  echo "  echo '# custom environment (--env)'"
  IFS=$'\n'
  for Line in $Customenvironment ; do
    echo "  echo export $(escapestring $Line)"
  done
  IFS=$' \t\n'
  echo "  echo ''"
  
  echo "  echo 'echo x11docker: container environment:'"
  echo "  echo 'env > $Cshare/environment'"
  echo "  echo 'sed -i \"/\(PWD=\|_=\)/d\" $Cshare/environment'"
  echo "  echo 'env | sort'"
  echo "  echo 'echo x11docker: copy of environment stored in $Cshare/environment'"
  echo "  echo ''"

  [ -s "$Cmdstdinfile" ] && echo "  echo \"cat $Cshare/stdin | \\\$Dbus \$Entrypoint \$Imagecommand >>$Cshare/stdout 2>>$Cshare/stderr\""
  [ -s "$Cmdstdinfile" ] || echo "  echo                \"exec \\\$Dbus \$Entrypoint \$Imagecommand >>$Cshare/stdout 2>>$Cshare/stderr\""

  echo "  echo '# Ready for docker run'"
  echo "} >> $Imagecommandscript"
  
  echo ""
  echo "cat $Imagecommandscript | nl -ba >> $Dockerlogfile"
  echo ""

  echo "read Containerid < <($Dockercommand)" # <- docker run is here!
  
  echo ""
  echo "[ -z \"\$Containerid\" ] && echo 'x11docker ERROR: Startup of docker failed.' && exit 1"
  echo "echo x11docker: container ID: \$Containerid"
  echo "echo \$Containerid >> $Containeridfile"
  echo "note 'Container ID:'"
  echo "notestdout \"\$(cat $Containeridfile)\""
  echo "docker logs -f \$Containerid >> $Dockerlogfile 2>&1 &"
  echo ""
  echo "# wait for container to be ready"
  echo "for ((Count=1 ; Count<=10 ; Count++)); do"
  echo "  sleep 0.2"
  echo "  docker exec $Containername sh -c : && { echo 'x11docker: container is up and running.' ; break ; } || echo \"x11docker: container not ready on \$Count. attempt, trying again.\" "
  echo "done"
  echo "cat $Dockerlogfile | grep 'Error response from daemon ||:'"  # repeat possible error message to make it visible in error() after verbose Count loop
  echo ""

  [ "$Initsystem" = "systemd" ] && ! mount -t cgroup | grep -q /sys/fs/cgroup/systemd && {
    [ "$(id -u)" != "0" ] && [ "$Capsysadmin" = "no" ] && warning "Need to create and mount a cgroup for systemd.
  As x11docker currently does not run as root, this will probably fail.
  You can either run x11docker as root, or you can mount yourself with:
    mkdir -p /sys/fs/cgroup/systemd
    mount -t cgroup cgroup /sys/fs/cgroup/systemd -o none,name=systemd
  Alternativly (and discouraged) you can run with option --sys-admin."
    echo "# create cgroup mount point for systemd"
    echo "mkdir -v -p /sys/fs/cgroup/systemd"
    echo "mount -t cgroup cgroup /sys/fs/cgroup/systemd -o none,name=systemd"
    echo ""
  }
  
  #echo "sleep 1 # wait a moment until IP is available. Currently, IP is only needed for --pulseaudio"
  echo "docker inspect --format '{{ .NetworkSettings.IPAddress }}' $Containername >> $Containerip"
  echo "echo x11docker: container IP: \$(cat $Containerip)"
  echo ""
  echo "# get PID of container"
  echo "Containerpid=\$(ps ax | grep \$Containerid | grep -v grep | grep -v ' logs' | awk '{print \$1}')"
  echo "echo x11docker: container PID: \$Containerpid"
  echo "echo \$Containerpid >> $Containerpidfile"
  echo ""
  [ "$Switchcontaineruser" = "no" ] && echo "docker exec -u root $Containername /bin/sh $Cshare/containersetup.sh"
} >> $Dockerrc

{ #### part: create pullrc: interactive script to pull image from docker hub
  echo "#! /bin/bash"
  [ "$Debug" = "yes" ] && echo "set -x"
  echo "touchpullready() {"
  echo "  $Mksu 'touch $Cachefolder/pullready'"
  echo "}"
  echo "trap touchpullready EXIT"
  echo "echo ''"
  echo "read -n1 -e -p \"Image '$Imagename' not found locally. "
  echo "Do you want to pull it from docker hub? [Y|n]\" Choice"
  echo "[[ \"\$Choice\" == [YyJj]* ]] || [ -z \"\$Choice\" ] && $Sudo docker pull $Imagename 2>&1"
  echo "sleep 2"
  echo "exit"
} >> $Pullrc

{ #### part: create xtermrc: prompt for password and run dockerrc
  echo "#! /bin/bash"
  [ "$Debug" = "yes" ] && echo "set -x"
  echo "touchxtermready() {"
  echo "  $Mksu 'touch $Cachefolder/xtermready'"
  echo "}"
  echo "trap touchxtermready EXIT"
  echo "export TERM=xterm SHELL=/bin/bash"
  [ "$Needpassword" = "yes" ] && case $Passwordprompt in
    su|sudo)
      echo "echo -e \"Created docker command for $Imagename $Imagecommand:"
      echo ""
      echo "$(echo $Dockercommand | sed 's,\\,\\\\ \n,g')"
      echo "\""
      echo "echo 'Please type in your password to run docker on display $Newdisplay'"
      echo "echo -n 'Password: '"
    ;;
  esac
  case $Passwordprompt in
    gksudo|lxsudo)  echo "$Getroot bash $Dockerrc  >>$Dockerlogfile 2>&1" ;;
    pkexec)         echo "pkexec env DISPLAY=\$DISPLAY XAUTHORITY=\$XAUTHORITY bash $Dockerrc  >>$Dockerlogfile 2>&1" ;;
    *)              echo "$Getroot \"${Sudo}bash $Dockerrc >>$Dockerlogfile 2>&1\"" ;;
  esac
  echo "exit"
} >> $Xtermrc

{ #### part: create xinitrc: set up X environment, create cookies
  echo "#! /bin/sh"
  [ "$Debug" = "yes" ] && echo "set -x"

  # declaring functions echoes them into xinitrc
  declare -f storepid
  declare -f mywatch
  declare -f no_xhost 
  declare -f warning 
  declare -f verbose
  declare -f note
  echo "Bgpidfile=$Bgpidfile"
  
  [ "$Noxhost" = "yes" ] && [ -n "$Hostdisplay" ] && {  
    echo "verbose 'option --no-xhost: disabling any access to host display granted by xhost'"
    echo "export $Hostxenv"
    echo "no_xhost"
  }

  echo "export $Newxenv"
  
  case $Xserver in
    --weston|--kwin|--hostwayland) ;;
    --nothing) echo "export WAYLAND_DISPLAY=''" ;;
    *) # here something for real X servers
      [ "$Xauthentication" = "yes" ] && {
        echo "# create new XAUTHORITY cookies"
        [ "$Xserver" = "--nxagent" ] && { 
          echo "cp $Xclientcookie $Xclientcookie.bak   # nxagent workaround cookie was created before starting xinit" 
          echo "export XAUTHORITY=$Xclientcookie.bak"
        }
        [ "$Trusted" = "yes" ] && Trusted="trusted" || Trusted="untrusted" 
        echo     ":> $Xclientcookie"
        [ "$Xserver" = "--hostdisplay" ] && {
          [ -s "$Hostxauthority" ] && echo "export XAUTHORITY=$Hostxauthority"
          echo   "xhost | grep -q 'SI:localuser:$Hostuser' && Xhostentry='yes' || xhost +SI:localuser:$Hostuser"
        }
        case "$Ssh" in
          no)
            echo "verbose 'Requesting $Trusted cookie from X server'" 
            echo "xauth -v -f $Xclientcookie generate $Newdisplay . $Trusted timeout 3600"
          ;;
          yes)
            echo "verbose 'Can not use cookies created over SSH. Will bake one myself.'"
          ;;
        esac
        echo     "export XAUTHORITY=$Xclientcookie"
        echo     "[ -s '$Xclientcookie' ] || { "
        echo     "  [ '$Trusted' = 'untrusted' ] && note 'Could not create untrusted cookie. "
        echo     "  Maybe your X server misses extension SECURITY.'"
        [ "$Xserver" = "--hostdisplay" ] && {
          [ "$Sharehostipc" = "no" ] && { 
            echo "  warning 'Memory access failures and rendering glitches may occur "
            echo "  due to unrestricted cookie."
            echo "  Avoid them with isolation breaking option --hostipc,"
            echo "  or use another X server option like --xpra or --nxagent.'"
          } 
          echo   "  warning 'SECURITY RISK! Keylogging and remote host control "
          echo   "  may be possible! Better avoid using option --hostdisplay,"
          echo   "  rather use --xpra or --nxagent.'"
          echo   "  cp $Hostxauthority $Xclientcookie"
        }
        echo     "}"
        echo     "[ -s '$Xclientcookie' ] || { "
        echo     "  # still no cookie? try to create one without extension security"
        echo     "  verbose 'Failed to retrieve cookie from X server. Will bake one myself.'"
        echo     "  xauth -f $Xclientcookie add $Newdisplay . $(mcookie)"
        echo     "}"
        echo     "# create prepared cookie with localhost identification disabled by ffff, needed if X socket is shared. ffff means 'familiy wild'"
        echo     "Cookie=\$(xauth -f $Xclientcookie nlist | sed -e 's/^..../ffff/')"
        echo     "echo \$Cookie | xauth -v -f $Xclientcookie nmerge -"
        echo     "cp $Xclientcookie $Xservercookie"
        echo     "[ -s '$Xclientcookie' ] || warning 'Cookie creation failed!'" 
        echo     "verbose \"Created cookie: \$(xauth list)\""
        echo     "chmod 644 $Xclientcookie"
        [ "$Xserver" = "--hostdisplay" ] && echo "[ '\$Xhostentry' = 'yes' ] || env XAUTHORITY=$Hostxauthority xhost -SI:localuser:$Hostuser"
        [ "$Xserver" = "--nxagent" ]     && echo "rm $Xclientcookie.bak"
      }
      
      echo "export XAUTHORITY=$Xclientcookie"
      echo "[ '$Xauthentication' = 'no' ] || [ ! -s '$Xclientcookie' ] && unset XAUTHORITY && warning 'X server $Newdisplay runs without cookie authentication.'"
      
      case "$Xserver" in
        --hostdisplay) ;;
        *)
          echo "verbose 'disabling any possible access to new X server possibly granted by xhost'"
          echo "no_xhost"
          [ -n "$Xhost" ] && {
            echo "verbose 'custom xhost setting (option --xhost): $Xhost'"
            echo "$Xhost" 
          }
          [ "$Initsystem" = "systemd" ] || [ "$Dbusdaemon" = "yes" ] && {
            echo "note 'Allowing xhost access for $Benutzer on display $Newdisplay with" 
            echo "  xhost +SI:localuser:$Benutzer"
            echo "to avoid service issues with X access. (option --systemd or --dbus-system)'"
            echo "xhost +SI:localuser:$Benutzer"
          }
          # Keyboard layout
          case "$Xkblayout" in
            "") [ -n "$Hostdisplay" ] && setxkbmap -display $Hostdisplay -print >> $Xkbkeymapfile ;;
            *)  setxkbmap "$Xkblayout" -print >> $Xkbkeymapfile ;;
          esac
          [ -s "$Xkbkeymapfile" ] && {
            echo "#"
            echo "# set keyboard layout on $Newdisplay to same as on host"
            echo "echo 'x11docker: keyboard layout:'"
            echo "cat $Xkbkeymapfile"
            echo "xkbcomp $Xkbkeymapfile $Newdisplay"
          }
        ;;
      esac
      
      [ "$Shareclipboard" = "yes" ] && [ -n "$Hostdisplay" ] && {
        case $Xserver in
          --xpra|--xpra-xwayland|--nxagent) ;;     # have their own clipboard management
          --hostdisplay) ;;                        # already same clipboard
          *)                                       # synchronizing between different X servers
            echo "# option '-c, --clipboard': Run clipboard script "
            echo "# (text copy only) (xpra has its own clipboard managment including images)"
            echo "bash $Shareclipboardscript & storepid \$! shareclipboard"
          ;;
        esac
      }
    ;;
  esac

  [ "$Setwaylandenv" = "yes" ] && for Line in $Waylandtoolkitenv ; do echo "export $Line" ;  done
  [ "$Sharewayland"  = "yes" ] &&       [ -n "$Waylandsocket" ]    && echo "export WAYLAND_DISPLAY=$Waylandsocket"
  
  case $Xserver in
    --weston|--kwin|--hostwayland|--nothing) ;;
    *)
      echo "getscreensize() {"
      echo "  CurrentXaxis=\$(xrandr | grep primary | cut -d' ' -f4 | cut -dx -f1 )"
      echo "  CurrentYaxis=\$(xrandr | grep primary | cut -d' ' -f4 | cut -dx -f2 | cut -d+ -f1)"
      echo "}"
      echo "checkscreensize() {"
      echo "  getscreensize"
      echo "  [ \"\$Xaxis\" = \"\$CurrentXaxis\" ] || return 1"
      echo "  [ \"\$Yaxis\" = \"\$CurrentYaxis\" ] || return 1"
      echo "  return 0"
      echo "}"
      echo "getprimary() {"
      echo "  xrandr | grep -q primary || xrandr --output \$(xrandr | grep ' connected' | head -n1 | cut -d' ' -f1) --primary"
      echo "  echo \$(xrandr | grep primary | cut -d' ' -f1)"
      echo "}"
      echo "Output=\$(getprimary)"
    ;;
  esac
      
  case $Xserver in 
    --xpra) # --xpra --desktop: New mode for window smaller than fullscreen
      echo "xrandr --newmode $Modeline"
      echo "xrandr --addmode \$Output $(echo $Modeline | cut -d " " -f1)"
      echo "xrandr --output  \$Output --mode $(echo $Modeline | cut -d " " -f1)"
    ;;
    --xorg) # --xorg: --scale, --size, --rotate
      echo "xrandr | grep connected | grep -v disconnected && {"
      [ -z "$Screensize" ] && {
        echo "  # determine screen size"
        echo "  getscreensize"
        echo "  Xaxis=\$CurrentXaxis"
        echo "  Yaxis=\$CurrentYaxis"
        [ "$Scaling" = "0" ] || echo "  Xaxis=\$(awk -v a=\$Xaxis -v b=$Scaling 'BEGIN {print (a / b)}')"
        echo "  Xaxis=\${Xaxis%.*}"
        [ "$Scaling" = "0" ] || echo "  Yaxis=\$(awk -v a=\$Yaxis -v b=$Scaling 'BEGIN {print (a / b)}')"
        echo "  Yaxis=\${Yaxis%.*}"
      } || {
        echo "  Xaxis=$Xaxis"
        echo "  Yaxis=$Yaxis"
      }
      echo "  Screensize=\${Xaxis}x\${Yaxis}"
      
      [ -n "$Screensize" ] && [ "$Scaling" = "0" ] && {
        echo "  [ -n \"\$(xrandr | grep \$Screensize)\" ] && { "
        echo "    note \"Will try to set native resolution \$Screensize."
        echo "  If that looks ugly, use --scale=1 to enforce a fake scaled resolution.\""
        echo "    xrandr --output \$Output --mode \$Screensize"
        echo "  }"
      }
       
      [ -n "$Screensize" ] && [ "$Scaling" = "0" ] && {
        echo "  note \"Panning \$Screensize. If virtual screen is greater than "
        echo "  maximal screen size, you can move virtual screen with mouse at screen edges."
        echo "  You can force the virtual screen to match your monitor with option --scale=1\""
        echo "  xrandr --output \$Output --panning \$Screensize+0+0/\$Screensize+0+0/100/100/100/100"
        echo "  checkscreensize || {"
        echo "    note 'Panning failed, trying to scale instead.'"
        echo "    xrandr --output \$Output --scale-from \$Screensize --panning \$Screensize+0+0/\$Screensize+0+0"
        echo "    checkscreensize && note \"Successfully set screen size \$Screensize\""
        echo '  }'
        echo "  checkscreensize || {"
        echo "    getscreensize"
        echo "    note \"Setting desired resolution \$Screensize failed."
        echo "  Fallback: Will use detected \${CurrentXaxis}x\${CurrentYaxis} instead.\""
        echo '  }'
      }
      
      [ "$Scaling" != "0" ] && {
        echo "  # Scaling $Scaling"
        echo "  verbose \"Setting scaled resolution \$Screensize\""
        # must use --scale-from and --panning because --scale causes mouse barriers/crtc-boundaries
        echo "  xrandr --output \$Output --scale-from \$Screensize --panning \$Screensize+0+0/\$Screensize+0+0"
        echo "  checkscreensize || {"
        echo "    getscreensize"
        echo "    note \"Setting desired resolution \$Screensize failed."
        echo "  Detected resolution \${CurrentXaxis}x\${CurrentYaxis} instead.\""
        echo "  }"
      }
      
      [ -n "$Rotation" ] && {
        echo "  verbose 'Rotation $Rotation'"
        case $Rotation in
          0|normal)    Rotation="" ;;
          90)          Rotation="--rotate right";;
          180)         Rotation="--reflect xy" ;; 
          270)         Rotation="--rotate left";;
          flipped)     Rotation="--reflect y";;
          flipped-90)  Rotation="--rotate right --reflect x";;
          flipped-180) Rotation="--reflect x";;
          flipped-270) Rotation="--rotate left --reflect x";;
        esac
        echo "  bash -c 'while read Line ; do xrandr --output \$Line $Rotation ; done < <(xrandr | grep \" connected\" | cut -d \" \" -f1)'"
      }
      echo "} || {"
      echo '  [ -z "$Xaxis" ] && Xaxis=1024 && Yaxis=768'
      echo "  Screensize=\${Xaxis}x\${Yaxis}"
      echo "  note \"Could not detect any connected monitor."
      echo "  Running on a server? Will try to set a framebuffer size"
      echo "  with \"xrandr --fb \$Screensize\" that may serve as a virtual display.\""
      echo "  xrandr --fb \$Screensize"
      echo "}"
    ;;
  esac
  [ -n "$Newdisplay" ] && echo "verbose \"Output of xrandr on $Newdisplay
\$(xrandr)\""

  [ "$Xfishtank" = "yes" ] && echo "xfishtank & storepid \$! xfishtank"
  [ -n "$Windowmanager" ] && {
    echo "verbose 'starting host window manager $Windowmanager on new display $Newdisplay'"
    echo "$Windowmanager & storepid \$! windowmanager"
  }
  
  [ -n "$Addcommand" ] && {
    echo "# added custom command with option --add"
    echo "$Addcommand"
  }
  
  echo "touch $Cachefolder/Xready"
  echo "mywatch 'ls $Timetosaygoodbye 2>/dev/null #xinitrc'"
} >> $Xinitrc

{ #### part: options --verbose, --stdout,--stderr and x11docker.log
    verbose "Host system: $Hostsystem
$(cowsay $(fortune -s 2>/dev/null || echo "The quick brown fox jumps over the lazy dog's back.") 2>/dev/null || { echo "Wanda the fish says: " ; fortune -s 2>/dev/null ;} )"
    [ "$Xserver" != "--nothing" ] && {
      verbose "X or Wayland server option: $Xserver"
      verbose "Virtual screen size: $Screensize"
      verbose "Real screen size: $(xrandr 2>/dev/null | grep Screen)"
      verbose "Environment variables: 
  $Newxenv"
    }
    verbose "Docker version: $(docker --version)"
    verbose "Image name: $Imagename"
    verbose "Image command: $Imagecommand"
    verbose "Users and terminal:
  x11docker was started by: $(id -un)
  As host user serves (running X, storing cache): $Hostuser
  Container user will be:   $Benutzer
  Container user password:  x11docker
  Getting permission to run docker with: $Getroot $Sudo
  Running X and other user commands with: $Mksu
  Terminal for password frontend: $Passwordterminal
  Terminal to show docker pull progress: $Pullterminal
  Running on console: $Tty"
    verbose "Current cache folder: $Cachefolder"
    [ -n "$Xcommand" ] && verbose "Created X server command:
  $Xcommand" 
    [ -n "$Xpraversion" ] && verbose "$Xpraversion"
    [ -n "$Compositorcommand" ] && verbose "Created compositor command:
  $Compositorcommand"
    [ -n "$Windowmanager" ] && verbose "As window manager from host serves: $Windowmanager"
    case $X11dockermode in
      run)
        verbose "Init system in container: $Initsystem"
        [ "$Benutzerhosthome" = "yes" ] && verbose "Sharing directory $Benutzerhosthomefolder 
  with container as its home directory $Benutzerhome"
        verbose "Created docker command:
  $Dockercommand"
        verbose "Created containersetup.sh:
$(cat $Setupscript | nl -ba)"
        verbose "Created dockerrc:
$(cat $Dockerrc | nl -ba)" 
        verbose "Created xtermrc:
$(cat $Xtermrc | nl -ba)"
      ;;
      exe) verbose "Running host application: $Hostexe" ;;
    esac
    verbose "Created xinitrc:
$(cat $Xinitrc | nl -ba)"
    [ -s "$Westonini" ] && verbose "Created weston.ini:
$(cat "$Westonini" | nl -ba)"
    verbose "Logfile: $Logfile2
In container: $Cshare/x11docker.log
After finish: $Logfile3"
    verbose "Running X server $Xserver on display $Newdisplay now ..."

    # create summary logfile
    tail --pid=$$ --retry -n +1 -F $Dockerlogfile \
                                   $Cmdstdoutlogfile $Cmdstderrlogfile ${Journallogfile:-} \
                                   $Xpraserverlogfile $Xpraclientlogfile \
                                   $Xinitlogfile $Compositorlogfile 2>/dev/null >> $Logfile &
    tail --pid=$$ --retry -n +1 -F $Logfile 2>/dev/null >> $Logfile2 &
    # option --verbose
    Esc="$(printf '\033')"
    [ "$Verbose" = "yes" ] && { 
      [ "$Initsystem" = "systemd" ] && note "x11docker deletes some systemd error messages
  that are harmless but numerous to get a better readable output.
  It deletes all lines with: 'Failed to add fd to store', 
  'Failed to set invocation ID' and 'Failed to reset devices.list'."
      case $Verbosecolors in
        no)  tail --pid=$$ --retry -n +1 -F $Logfile 2>/dev/null >&3 & ;;
        yes) tail --pid=$$ --retry -n +1 -F $Logfile 2>/dev/null | sed "
                                      /\(Failed to add fd to store\|Failed to set invocation ID\|Failed to reset devices.list\)/d;
                                      s/\(ERROR\|Error\|error\|FAILURE\|FATAL\|Fatal\|fatal\)/${Esc}[41m\1${Esc}[0m/g;
                                      s/\(Failed\|failed\|Failure\|failure\)/${Esc}[31m\1${Esc}[0m/g;
                                      s/\(WARNING\|Warning\|warning\)/${Esc}[33m\1${Esc}[0m/g;
                                      s/^==>.*/${Esc}[4m\0${Esc}[0m/;
                                      s/\(Starting\)/${Esc}[32m\0${Esc}[0m/;
                                      s/\(Started\|Reached target\)/${Esc}[42m\0${Esc}[0m/;
                                      s/^\(+\|++\|+++\)/${Esc}[42m\0${Esc}[0m/ ;
                                      s/^x11docker/${Esc}[32m\0${Esc}[0m/ " >&3 & ;;
      esac
    }
    # options --stdout, --stderr
    [ "$Showstdout" = "yes" ] && {
      waitforfilecontent $Containeridfile infinity
      tail --pid=$$ --retry -n +1 -F $Cmdstdoutlogfile >&1 2>/dev/null
    } &
    [ "$Showstderr" = "yes" ] && tail --pid=$$ --retry -n +1 -F $Cmdstderrlogfile >&4 2>/dev/null &
}

{ #### part: option '--starter': create desktop starter
  if [ "$Createdesktopstarter" = "yes" ] ; then
    command -v xdg-desktop-icon >/dev/null || error "Command 'xdg-desktop-icon' not found.
  x11docker needs it to place the new icon on your desktop.
  Please install xdg-utils"

    note "Will create a new starter on your desktop.
  If you move the new file to $Hostuserhome/.local/share/applications,
  it will appear in your applications menu."
  
    Name="$(echo $Imagename | tr / -) $(echo $Imagecommand | tr -cd '[:alpha:][:digit:][:blank:]-_.') x11docker"
    read -re -p "Please choose a name for your desktop starter: 
" -i "$Name" Name
    [ -z "$Name" ] && exit ### FIXME: check for valid file name / invalid chars?
    
    Parsedoptions=$(echo $Parsedoptions | sed 's/--starter/ /')
    mkfile "$Cachefolder/$Name.desktop"
    { 
      echo "#!/usr/bin/xdg-open
[Desktop Entry]
Type=Application
Name=$Name
Exec=x11docker $Parsedoptions
Icon=x11docker
Comment=
Categories=System
Keywords=docker x11docker $(echo $Name | tr -c '[:alpha:][:digit:][:blank:]' ' ' )"
      case $(command -v x11docker) in 
        "")echo "TryExec=$0 $Parsedoptions" ;;
        *) echo "TryExec=x11docker $Parsedoptions" ;;
      esac
    } >> "$Cachefolder/$Name.desktop"
    
    $Mksu "xdg-desktop-icon install --novendor '$Cachefolder/$Name.desktop'"
    exit
  fi
}

{ #### part: wait for and watch X server, [start xpra] and run xtermrc-> dockerrc-> docker run
  # wait for X server
  waitforfilecreation $Cachefolder/Xready 24 || error "Startup of X server $Xserver failed. 
  Last lines of xinit logfile:
$(tail $Xinitlogfile)"
  
  [ -s "$Compositorpidfile" ] && {
    Compositorpid=$(cat $Compositorpidfile)
    ps -p $Compositorpid >/dev/null 2>&1 && storepid $Compositorpid compositor
  }
  
  # --xpra / --xpra-xwayland: start xpra server&client
  case $Xserver in      
    --xpra|--xpra-xwayland) 
      notify-send 'Please be patient, xpra will start soon ...' 2>/dev/null
      
      [ "$Desktopmode" = "yes" ] && Xpraservercommand="xpra start-desktop" || Xpraservercommand="xpra start"
      Xpraservercommand="$Xpraservercommand $Newdisplay --use-display $Xpraoptions"
      Xpraclientcommand="xpra attach $Newdisplay $Xpraoptions"
      verbose "Xpra server command:
  $Xpraservercommand"
      verbose "Xpra client command:
  $Xpraclientcommand"
  
      [ -e "/run/user/$Hostuseruid" ] || {
        # can miss with option --hostuser, xpra needs it for socket
        verbose "Creating /run/user/$Hostuseruid"
        mkdir -p /run/user/$Hostuseruid
        chown $Hostuser /run/user/$Hostuseruid
        chmod 700 /run/user/$Hostuseruid
      }
      
      while [ ! -e "$Timetosaygoodbye" ] && [ -e "$Cachefolder" ] ; do
        ps -p $Xpraserverpid >/dev/null 2>&1 || {
          [ -n "$Xpraserverpid" ] && { 
            Xpracrashcount=$((Xpracrashcount + 1))
            [ "$Xpracrashcount" -eq 1 ] && {
              warning "xpra server has crashed.
  x11docker will add xpra option --mmap=no to hopefully fix that issue.
  xpra will need more CPU power, but will run more stable."
              Xpraservercommand="$Xpraservercommand --mmap=no"
              Xpraclientcommand="$Xpraclientcommand --mmap=no"
            }
            [ "$Xpracrashcount" -eq 3 ] && alertbox "xpra server has crashed $Xpracrashcount times.
  After crashing 6 times, x11docker will terminate."
            [ "$Xpracrashcount" -eq 6 ] && error "Xpra server crashed $Xpracrashcount times.
  x11docker stops now. Try out other X server options
  like --nxagent --xephyr or --hostdisplay."
            warning "xpra server seems to have crashed the $Xpracrashcount. time.
  After 6 crashes, x11docker will terminate on itself.
  Will restart xpra now. Last lines of xpra server log:
$(tail $Xpraserverlogfile)"
            notify-send "x11docker: xpra server crashed. Restarting xpra now."
            rm $Xpraserverlogfile && mkfile $Xpraserverlogfile
          }
          verbose "starting Xpra server"
          $Mksu "env $Newxenv XPRA_OPENGL_DOUBLE_BUFFERED=1 $Xpraservercommand" >> $Xpraserverlogfile 2>&1 &
          Xpraserverpid=$!
          storepid $Xpraserverpid xpraserver
          waitforlogentry "xpra server" $Xpraserverlogfile 'xpra is ready' && verbose "Xpra server is ready" || {
            [ -e "$Xpraserverlogfile" ] && error "Xpra server startup failed.
  Last lines of Xpra server log:
$(tail $Xpraserverlogfile)

  Last lines of docker log:
$(tail $Dockerlogfile)"
          }
        }
        ps -p $Xpraclientpid >/dev/null 2>&1 && kill $Xpraclientpid
        verbose "starting Xpra client"
        [ -n "$Xpraclientpid" ] && note "Restarting Xpra client."
        $Mksu "env $Hostxenv XPRA_PADDING_COLORS='0,0.2,1' $Xpraclientcommand" >> $Xpraclientlogfile 2>&1 &
        Xpraclientpid=$!
        storepid $Xpraclientpid xpraclient

        sleep 1
        ps -p $Xpraclientpid >/dev/null 2>&1 && mywatch "ls $Timetosaygoodbye 2>/dev/null; ps -p $Xpraclientpid -o pid ; ps -p $Xpraserverpid -o pid #xpra"
        sleep 1
      done & storepid $! xpraloop
    ;;
  esac
  
  # option '--showenv': show display infos on stdout (after X server is ready)
  [ "$Showdisplayenvironment" = "yes" ] && echo $Newxenv
  # create easy to find file with latest created X environment for custom access
  mkfile "$Cacherootfolder/Xenv.latest"
  for Line in $Newxenv ; do echo $Line >> "$Cacherootfolder/Xenv.latest" ; done
  
  #### watch X server and/or Wayland compositor ####
  case $Xserver in
    --nothing|--hostwayland) ;;
    --weston|--kwin)
      {  # catch closing compositor window
        sleep 1
        ps -p $Compositorpid >/dev/null 2>&1 && {
          mywatch "ls $Timetosaygoodbye 2>/dev/null; ps -p $Compositorpid -o pid #compositor" ||:
        } || error "Startup of compositor failed.
  Last lines of compositor log:
$(tail $Compositorlogfile)"
        saygoodbye
      } & storepid $! mywatch
    ;;
    --weston-xwayland|--kwin-xwayland|--xpra-xwayland|--xdummy-xwayland)
      {  # catch closing X server or compositor window
        sleep 1
        ps -p $Compositorpid >/dev/null 2>&1 && {
          mywatch "ls $Timetosaygoodbye $Newxsocket 2>/dev/null ; ps -p $Compositorpid -o pid #compositor+Xserver" ||:
        } || error "Startup of compositor or X failed.
  Last lines of compositor log:
$(tail $Compositorlogfile)"
        saygoodbye
      } & storepid $! mywatch
    ;;
    *)
      {  # catch closing X server
        mywatch "ls $Timetosaygoodbye $Newxsocket 2>/dev/null #Xserver"
        saygoodbye
      } & storepid $! mywatch
    ;;
  esac

  #### start docker ####
  case $X11dockermode in
    run)
      # prefer asking for password on host X
      [ -n "$Hostdisplay" ]     && export $Hostxenv || export $Newxenv 
      [ "$Fullscreen" = "yes" ] && export $Newxenv ### FIXME could cause trouble with Wayland if terminal is not Wayland capable

      # start docker in xtermrc
      case $Passwordprompt in
        su|sudo)
          [ "$Passwordterminal" = "bash -c" ] && Passwordterminal=""
          #[ -z "$Passwordterminal" ] && exec </dev/tty
          case $Needpassword in
            no) /bin/bash $Xtermrc ;; 
            yes) $Passwordterminal /bin/bash $Xtermrc ;;
          esac
        ;;
        *) $Passwordterminal "/bin/bash $Xtermrc" ;;
      esac
      waitforfilecreation $Cachefolder/xtermready infinity
      
      sleep 1 # wait for late messages of docker daemon
      [ -s "$Containerpidfile" ] && { 
        Containerpid=$(cat $Containerpidfile)
        ps -p $Containerpid >/dev/null 2>&1 || {
          [ "$Xserver" = "--nothing" ] && saygoodbye || {
            error "Docker startup seems to have failed! 

  Last lines of docker.log:
$(tail $Dockerlogfile)

  Last lines of command stderr:
$(tail $Cmdstderrlogfile)"
          }
        }
        storepid $Containerpid container
        
        # wait for docker until it terminates. bash builtin wait does not work in this case
        ps -p $Containerpid >/dev/null 2>&1 && mywatch "ls $Timetosaygoodbye 2>/dev/null; ps -p $Containerpid -o pid #container" 
        :
      } || { 
        error "docker startup was not successfull.
  Maybe you mistyped your password, or image does not exist.
  Or the chosen password prompt does not match your setup;
  you can try option --pw with f.e. --pw=su or --pw=sudo.
  Last lines of docker logfile:
$(tail $Dockerlogfile)"
      }
    ;;
    
    exe) # run host application without docker. includes --xonly
      declare -f mywatch verbose >> $Imagecommandscript
      echo "export $Newxenv" >> $Imagecommandscript
      [ "$Benutzerhosthome" = "yes" ] && {
        echo "export HOME='$Benutzerhosthomefolder'"
        echo "cd '$Benutzerhosthomefolder'"
      } >>  $Imagecommandscript
      [ -s $Cmdstdinfile ] && {
        echo "cat $Cmdstdinfile | $Hostexe" >> $Imagecommandscript
      } || {
        echo "$Hostexe" >> $Imagecommandscript
      }
      cat $Imagecommandscript | nl -ba >> $Dockerlogfile
      $Mksubenutzer "bash $Imagecommandscript" >> $Cmdstdoutlogfile 2>>$Cmdstderrlogfile & Hostexepid=$! && storepid $! hostexe
      sleep 1 # wait for possible startup failure
      ps -p $Hostexepid >/dev/null 2>&1 && {
        mywatch "ls $Timetosaygoodbye 2>/dev/null; ps -p $Hostexepid -o pid #hostexe" ||:
      } || error "Startup of '$Hostexe' failed.
  Last lines of log:
$(tail $Dockerlogfile)"
    ;;
  esac
  saygoodbye
} & storepid $! x11docker-run

{ #### part: start X server
  case $Xserver in
    --xorg|--xpra|--xephyr|--xdummy|--xvfb|--xwayland|--nxagent)
      $Mksu                                              "xinit $Xinitrc -- $Xcommand          >> $Xinitlogfile  2>&1" 
    ;;
    --hostdisplay|--hostwayland)
      $Mksu                                              "bash  $Xinitrc                       >> $Xinitlogfile  2>&1 " 
    ;;
    --xpra-xwayland|--xdummy-xwayland)
      [ -z "$Hostwayland" ] || { [ "$Scaling" != "0" ] && [ "1" = "$(awk -v a="$Scaling" 'BEGIN {print (a < 1)}')" ] ;} && {
        # Weston is needed for Xwayland if no Wayland is running already, and also 
        # if option scale has a value smaller than 1 to provide a virtual display larger than monitor
        $Mksu "$Compositorcommand                                                              >> $Compositorlogfile 2>&1 & echo \$! >>$Compositorpidfile"
        waitforfilecreation $XDG_RUNTIME_DIR/$Waylandsocket
        waitforlogentry weston $Compositorlogfile "weston-desktop-shell"                       || error "Weston startup failed. Can not run $Xserver.
  Last lines of weston log:
$(tail $Compositorlogfile)"
        # hide weston window
        $Mksu "xdotool windowunmap 0x$(printf '%x\n' $(cat $Compositorlogfile | grep 'window id' | rev | cut -d' ' -f1 | rev))"
      }
      $Mksu "env WAYLAND_DISPLAY=$Waylandsocket           xinit $Xinitrc -- $Xcommand          >> $Xinitlogfile  2>&1 " 
    ;;
    --weston-xwayland)
      $Mksu "$Compositorcommand                                                                >> $Compositorlogfile 2>&1 & echo \$! >>$Compositorpidfile"
      waitforfilecreation $XDG_RUNTIME_DIR/$Waylandsocket
      waitforlogentry weston $Compositorlogfile "weston-desktop-shell"                         || error "Weston startup failed. Can not run $Xserver.
  Last lines of weston log:
$(tail $Compositorlogfile)"      
      $Mksu "env WAYLAND_DISPLAY=$Waylandsocket           xinit $Xinitrc -- $Xcommand          >> $Xinitlogfile  2>&1 " 
    ;;
    --weston)
      $Mksu "$Compositorcommand                                                                >> $Compositorlogfile 2>&1  & echo \$! >>$Compositorpidfile"
      waitforfilecreation $XDG_RUNTIME_DIR/$Waylandsocket
      waitforlogentry weston $Compositorlogfile "weston-desktop-shell"                         || error "Weston startup failed. Can not run $Xserver.
  Last lines of weston log:
$(tail $Compositorlogfile)"
      $Mksu                                              "bash  $Xinitrc                       >> $Xinitlogfile  2>&1" 
    ;;
    --kwin-xwayland)
      $Mksu "$Compositorcommand --exit-with-session='$Waitforgoodbye'                          >> $Compositorlogfile 2>&1 & echo \$! >>$Compositorpidfile"
      waitforfilecreation $XDG_RUNTIME_DIR/$Waylandsocket
      waitforlogentry kwin   $Compositorlogfile "X-Server"                                     || error "Kwin startup failed. Can not run $Xserver.
  Last lines of kwin log:
$(tail $Compositorlogfile)"
      $Mksu "env WAYLAND_DISPLAY=$Waylandsocket           xinit $Xinitrc -- $Xcommand          >> $Xinitlogfile  2>&1 " 
    ;;
    --kwin)
      $Mksu "dbus-launch $Compositorcommand --exit-with-session='$Waitforgoodbye'              >> $Compositorlogfile 2>&1 & echo \$! >>$Compositorpidfile"
      waitforfilecreation $XDG_RUNTIME_DIR/$Waylandsocket
      waitforlogentry kwin   $Compositorlogfile "X-Server"                                     || error "Kwin startup failed. Can not run $Xserver.
  Last lines of kwin log:
$(tail $Compositorlogfile)"
      $Mksu                                              "bash  $Xinitrc                       >> $Xinitlogfile  2>&1 " 
    ;;
    --nothing)
      $Mksu                                              "bash  $Xinitrc                       >> $Xinitlogfile  2>&1 " 
    ;;
  esac
  exit 0 # trap to finish()
}

######### ToDo notes for development
todo() {
# --fullscreen: --weston[-x] in weston crashes. Use X backend if DISPLAY is available.
# work on traperror(). 'set -u' possible without a stop?
# --update: regard possible location in /opt
# outsource x11docker.png from x11docker-gui
# escape more option arguments: --add, custom docker options, --workdir, --user, --homedir, --sharedir, --wm, --lang, --xhost
# --dbus-system: policykit must not have no-new-privileges. Seems to use setuid? Core issue AccountsService?
#                starting polkitd and accounts-daemon in setupscript helps:
#                -> cinnamon starts up with lots of (harmless?) error messages
#                -> deepin needs --pulseaudio again
# --wayland --dbus-system GTK3 seems to work now!?
# check fgconsole
# bestwu/deepin: why sh is replaced by bash?
# BUG opensuse/arch: issues with x11docker/fluxbox, background missing, sometimes no context menu. where is the difference?
# check echo especially in sh scripts, replace with printf if needed (#25)
# avoid possible confusions --home --sharedir. --sharedir mounts can overlap --home folder. What about softlinks with existing target in --home? Maybe avoid /home/$USER at all
# --xpra --desktop restarts client if closing desktop window
# bug report to docker about --volume in --volume

# check out possibilities to allow 'sudo docker' directly again.
# --lang: find out locale package names for several distris for documentation
# --keymap does not work on tty with --kwin and --kwin-xwayland. No idea how to set it.
# xpra restart on tty switch -> bug report
# further check of xpra server crashes with jess/atom and chromium. --mmap=no avoids the bug: xpra bug report?

# BUG check whether VT is not in use with --xorg/--xpra/--xdummy, bug if accidently using vt that is already in use
# check all FIXME 
# note: SYS_PTRACE allows polkit in docker?
# --systemd: try to avoid xhost +SI:localuser:$Benutzer
# --xpra-xwayland, xdummy-xwayland: use kwin-wayland as fallback for missing weston? 
# --xorg: getty and autologin to avoid Xwrapper.config changes?
# gnome3 based desktop failing due to gnome bugs: pantheon budgie gnome3
# check Xorg version for +iglx, check security implications, maybe option --iglx?
# GTK3 in Wayland: --dbus once worked with $Dbusdaemon=yes
# --wayland --user/--hostuser: wayland socket access denied due to XDG_RUNTIME_DIR
# --nxagent 3.5.0: Mageia 6: seamless mode fails
# fedora: SElinux issue: '--security-opt label=type:container_runtime_t': need more restrictive setting
#         https://unix.stackexchange.com/questions/386767/selinux-and-docker-allow-access-to-x-unix-socket-in-tmp-x11-unix
# multimonitor support for --scale and --size
# check current multimonitor behaviour for weston on tty
# --xdummy --gpu on tty allows real resolutions only
# --xorg: check custom systemd start of X #7
# check X in container #7
# some tests with Xephyrglamor=no

### BUG collection: non x11docker bugs
# BUG Xwayland does not always sit at 0:0 on multiple outputs. 
#     bugreport: https://bugzilla.redhat.com/show_bug.cgi?id=1498665
# BUG nxagent with x11docker/lxde: segmentation fault of lxpanel with --userns-remap. bug in nxagent, lxpanel or x11docker?
# BUG --kwin*: wrong fullscreen and crashes in gnome-wayland, strange in weston, WAYLAND_DISPLAY="" does not help, probably bug in kwin
# BUG scale>1 Xwayland in Weston is too large (Xwayland bug), rendering issues on tty (switching scaled/unscaled Xwayland on keyboard/mouse events) 
#     bugreport: https://bugzilla.redhat.com/show_bug.cgi?id=1498669
# BUG x11docker-gui in weston freezes weston in combo boxes. Weston bug ? QT3/4 bug?
# BUG debian bug report lightdm/sddm contra gdm, dm can crash on tty switch if multiple graphical sessions are running
  :
}